
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Phrase Tag Viewer — Installation Guide</title>
  <style>
    :root { --bg:#0b1220; --panel:#0f1629; --text:#e6eefc; --muted:#9fb3d9; --accent:#7aa2ff; --ok:#2bd48f; }
    * { box-sizing:border-box; }
    body { margin:0; background:var(--bg); color:var(--text); font:16px/1.55 system-ui,-apple-system,"Segoe UI",Roboto,Inter,Arial,sans-serif; }
    .wrap { max-width:960px; margin:40px auto; padding:0 20px; }
    h1 { font-size:28px; margin:0 0 8px; }
    h2 { margin:28px 0 10px; font-size:20px; }
    p  { color:var(--muted); }
    .card { background:var(--panel); border:1px solid rgba(255,255,255,.07); border-radius:12px; padding:18px; margin:16px 0; }
    ol.steps { padding-left:20px; }
    .codewrap { position:relative; margin-top:12px; max-height:400px; overflow-y: auto; border-radius: 10px; }
    .copybtn {
      position:absolute; top:10px; right:10px; padding:8px 12px; border-radius:8px;
      background:var(--accent); color:#06131f; border:none; font-weight:700; cursor:pointer;
      box-shadow:0 6px 16px rgba(0,0,0,.25); z-index: 10;
    }
    .copybtn:active { transform:translateY(1px); }
    pre { margin:0; max-height:400px; overflow:auto; background:#0a1020; border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:16px; }
    code { color:#c7d7ff; font-family:ui-monospace,Menlo,Consolas,Monaco,monospace; font-size:13px;
           white-space:pre-wrap; overflow-wrap:anywhere; word-break:break-word; }
    .tip { color:#b7c7ee; font-size:14px; }
    .ok { color:var(--ok); font-weight:700; }
    a.btn {
      display:inline-block; padding:10px 14px; border-radius:10px; text-decoration:none;
      background:#18233b; color:#dbe7ff; border:1px solid rgba(255,255,255,.08);
    }
    a.btn:hover { background:#1b2744; }
    ul { margin:0; padding-left:20px; }
    .notice { font-size:14px; color:#c8d6ff; opacity:.9; margin:8px 0 0; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Phrase Tag Viewer</h1>
    <p class="tip">
      A small helper that reads the <b>active target segment</b> in Phrase/Memsource and shows a
      copy-ready string where <b>Phrase tag widgets are replaced by their literal values</b>.
      It supports <code>mq:rxt</code> (via <code>displaytext</code>/<code>val</code>) and
      paired tags (<code>bpt/ept</code>, e.g. <code>&lt;strong&gt;</code>…<code>&lt;/strong&gt;</code>).
      Numbers inside braces like <code>{{123}}</code> are output as <code>123</code>.
    </p>

    <div class="card">
      <h2>1) Install Tampermonkey</h2>
      <p>Install the Tampermonkey extension for your browser:</p>
      <p><a class="btn" href="https://www.tampermonkey.net/" target="_blank" rel="noopener noreferrer">Go to tampermonkey.net</a></p>
      <p class="tip">On that page, pick your browser (Chrome, Edge, Firefox, etc.) and follow the store link to install.</p>
    </div>

    <div class="card">
      <h2>2) Create a new userscript</h2>
      <ol class="steps">
        <li>Click the Tampermonkey icon in your browser toolbar (you may need to enable it in your browser's extension settings).</li>
        <li>Click <b>+ Create a new script…</b>.</li>
      </ol>
    </div>

    <div class="card">
      <h2>3) Paste the script, then save</h2>
      <p>Copy the script below by clicking <b>Copy code</b>, then paste into the Tampermonkey editor, replacing any previous content. Save by going to <b>File → Save</b> or using <b>Ctrl+S</b>.</p>

      <div class="codewrap">
        <button class="copybtn" id="copyCodeBtn">Copy code</button>
        <pre><code id="codeblock">(no script pasted yet)</code></pre>
      </div>
      <!-- The payload below is NEVER executed and NEVER parsed as HTML/JS. It's plain text. -->
      <script id="payload" type="text/plain">
// ==UserScript==
// @name         Phrase Tag Viewer
// @namespace    hs.phrase.copyexport
// @version      1.3.0
// @description  Copy-ready export of active Phrase target segment: tag widgets → values (mq:rxt) and bpt/ept inner markup; strip {123}→123; ignore [[...]] in preview/copy and when choosing the relevant @; colored tags by theme; light/dark w/ memory; iframe-safe; selection-safe; variable toggles (single-@ and |4) in one vertical list with switch controls above the “Toggle Variables” checkbox.
// @match        https://app.phrase.com/*
// @match        https://*.phrase.com/*
// @match        https://cloud.memsource.com/*
// @match        https://*.memsource.com/*
// @exclude      https://cloud.memsource.com/web/project*
// @exclude      https://cloud.memsource.com/web/job2/list*
// @exclude      https://cloud.memsource.com/tms/transMemory/list*
// @exclude      https://cloud.memsource.com/tms/setup/*
// @exclude      https://cloud.memsource.com/web/setup/*
// @run-at       document-idle
// @grant        GM_setClipboard
// ==/UserScript==

(() => {
  /* ===================== Base / utils ===================== */
  const IS_TOP = window.top === window;
  const ORIGIN_ID = `${location.origin}${location.pathname}`;
  const THEME_KEY = 'ptv-theme';         // 'light' | 'dark'
  const VARS_KEY  = 'ptv-vars-enabled';  // remember toggle ON/OFF per user
  const $ = (s, r = document) => r.querySelector(s);

  let ui, showBtn, lastActive = null;
  let PTV_SELECTING = false;
  const PTV_RENDER_CACHE = { plain: '', html: '' };

  // Variable mode state for current segment
  let VARS_ENABLED = false;
  let VARS_TOGGLE;
  let VARS_FLY; // compact vertical flyout above the Toggle Variables control

  // choices: at = 'before'|'after' (single); or = array of 'a'|'b'
  let VAR_CHOICES = { at: 'before', or: [] };
  // selected @ in the original string: nth occurrence (1-based). 0 = none/useful not found
  let VAR_AT_NTH = 0;

  let PREV_BASE_PLAIN = ''; // to detect segment change and rebuild panel

  // Button click feedback
  function addClickFeedback(btn){
    if (!btn || btn.dataset._ptvClickFx) return;
    btn.dataset._ptvClickFx = '1';
    btn.addEventListener('click', () => {
      btn.classList.add('ptv-pressed');
      setTimeout(() => btn.classList.remove('ptv-pressed'), 150);
    }, true);
  }

  /* ===================== UI ===================== */
  function ensureUI() {
    if (!IS_TOP) return;
    if ($('#hs-copybox')) {
      ui = $('#hs-copybox');
      showBtn = $('#hs-showbtn');
      VARS_TOGGLE = $('#hs-vars-toggle');
      if (!VARS_FLY) createVarsFlyout(); // ensure flyout exists if reusing UI
      return;
    }

    ui = document.createElement('div');
    ui.id = 'hs-copybox';
    ui.innerHTML = `
      <div class="hs-head">
        <strong>Phrase Tag Viewer</strong>
        <div class="hs-menu">
          <label class="hs-vars-toggle" title="Resolve variables">
            <input id="hs-vars-toggle" type="checkbox"/><span>Toggle Variables</span>
          </label>
          <label class="hs-fontctrl" title="Preview font size (px)">
            <span class="hs-fs-label">A</span>
            <input id="hs-fs" type="number" min="10" max="48" step="1" value="14"/>
          </label>
          <label class="hs-theme-toggle" title="Toggle dark mode">
            <input id="hs-theme" type="checkbox"/><span>Dark</span>
          </label>
        </div>
      </div>
      <div id="hs-body">
        <div class="hs-textwrap">
          <div id="hs-pretty" aria-label="Converted preview" tabindex="0"></div>
          <textarea id="hs-out" aria-hidden="true"></textarea>
        </div>
        <div class="hs-buttons">
          <button id="hs-copybtn" title="Copy to clipboard">Copy</button>
          <button id="hs-hide" title="Hide panel">Hide</button>
        </div>
      </div>`;

    Object.assign(ui.style, {
      position:'fixed', left:'12px', bottom:'40px', width:'1420px', height:'110px', maxWidth:'98vw',
      zIndex:2147483647, borderRadius:'10px', boxShadow:'0 8px 24px rgba(0,0,0,.4)',
      font:'12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif', padding:'10px',
      display:'flex', flexDirection:'column'
    });

    const style = document.createElement('style');
    style.textContent = `
      /* Layout */
      #hs-copybox .hs-head{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;min-height:20px}
      #hs-copybox .hs-menu{display:flex;gap:10px;align-items:center}
      #hs-copybox .hs-menu > * { display:flex; align-items:center; gap:6px; }
      #hs-body{display:flex;gap:6px;flex:1;min-height:0}
      #hs-body .hs-textwrap{flex:1;display:flex;min-width:0}
      #hs-pretty{width:100%;height:100%;border-radius:8px;padding:6px;box-sizing:border-box;overflow:auto;white-space:pre-wrap;word-break:break-word;line-height:1.4;font-size:14px;
        font-family:"Inter","IBM Plex Sans","Segoe UI",system-ui,-apple-system,Roboto,Arial,sans-serif}
      #hs-out{display:none}
      #hs-copybox .hs-buttons{display:flex;flex-direction:column;gap:6px;align-items:stretch;justify-content:flex-start;min-width:110px}
      #hs-copybox button{border-radius:6px;cursor:pointer;font-size:12px;line-height:1;height:32px;padding:6px 10px;min-width:72px}

      /* Font size control */
      #hs-copybox .hs-fontctrl{user-select:none}
      #hs-copybox .hs-fs-label{font-weight:700;opacity:.85;display:inline-block;width:14px;text-align:center;font-size:12px}
      #hs-copybox #hs-fs{width:56px;height:24px;border-radius:6px;padding:2px 6px;font-size:12px}

      /* Toggle Variables (small, inline) */
      #hs-copybox .hs-vars-toggle{user-select:none;cursor:pointer;font-size:12px}

      /* Compact Vertical Variables Flyout */
      #hs-vars-flyout{
        position:fixed; z-index:2147483647;
        /* auto width/height based on content; compact vertical layout */
        border:1px solid; border-radius:10px; padding:10px; font:12px/1.4 system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;
        box-shadow:0 10px 24px rgba(0,0,0,.35);
        max-width:340px; max-height:50vh; overflow:auto;
      }
      #hs-vars-flyout.hidden{ display:none!important }
      #hs-vars-flyout .vars-list{display:flex;flex-direction:column;gap:8px}
      #hs-vars-flyout .vars-item{display:flex;align-items:center;justify-content:space-between;gap:10px}
      #hs-vars-flyout .vars-label{flex:1;display:flex;align-items:center;gap:8px;min-width:0}
      #hs-vars-flyout .vars-option{white-space:nowrap;opacity:.9}
      #hs-vars-flyout .vars-option.right{margin-left:10px}

      /* Switch control */
      .ptv-switch{position:relative;width:46px;height:22px;flex:0 0 auto}
      .ptv-switch input{position:absolute;opacity:0;width:0;height:0}
      .ptv-switch .track{
        position:absolute;inset:0;border-radius:999px;border:1px solid currentColor;opacity:.7;
      }
      .ptv-switch .thumb{
        position:absolute;top:1px;left:1px;width:20px;height:20px;border-radius:50%;
        background:currentColor;transition:transform 160ms ease;
      }
      .ptv-switch input:checked + .track + .thumb{ transform:translateX(24px); }

      /* Show button */
      #hs-showbtn{position:fixed;z-index:2147483647;border-radius:999px;padding:6px 10px;cursor:pointer;font:12px/1 system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;box-shadow:0 8px 24px rgba(0,0,0,.4)}
      #hs-showbtn.hidden{display:none!important}

      /* Theme: light (default) */
      #hs-copybox.ptv-light{background:#f7f8fa;color:#0b0f12;border:1px solid #cfd8e3}
      #hs-copybox.ptv-light #hs-pretty{background:#fff;color:#111827;border:1px solid #cfd8e3}
      #hs-copybox.ptv-light .hs-taglit{color:#1d4ed8;font-weight:600}
      #hs-copybox.ptv-light button{background:#eef2f7;color:#0b0f12;border:1px solid #cbd5e1}
      #hs-copybox.ptv-light button:hover{background:#e6edf7}
      #hs-copybox.ptv-light #hs-fs{background:#fff;color:#0b0f12;border:1px solid #cbd5e1}
      #hs-vars-flyout.ptv-light{background:#ffffff;border-color:#cfd8e3;color:#0b0f12}
      #hs-showbtn.ptv-light{background:#eef2f7;color:#0b0f12;border:1px solid #cbd5e1}
      #hs-showbtn.ptv-light:hover{background:#e6edf7}

      /* Theme: dark */
      #hs-copybox.ptv-dark{background:#0b0f12;color:#d7e2ea;border:1px solid #1f2a33}
      #hs-copybox.ptv-dark #hs-pretty{background:#0e1317;color:#e8f3ff;border:1px solid #1e2a33}
      #hs-copybox.ptv-dark .hs-taglit{color:#f6c560;font-weight:600}
      #hs-copybox.ptv-dark button{background:#10202a;color:#bfe8ff;border:1px solid #1e2f3a}
      #hs-copybox.ptv-dark button:hover{background:#143040}
      #hs-copybox.ptv-dark #hs-fs{background:#0e1317;color:#e8f3ff;border:1px solid #1e2a33}
      #hs-vars-flyout.ptv-dark{background:#0e1317;border-color:#1e2a33;color:#d7e2ea}
      #hs-copybox.hidden{display:none!important}
      #hs-showbtn.ptv-dark{background:#10202a;color:#bfe8ff;border:1px solid #1e2f3a}
      #hs-showbtn.ptv-dark:hover{background:#143040}

      /* Selection: allow text dragging fully */
      #hs-pretty, #hs-pretty *{-webkit-user-select:text!important;-moz-user-select:text!important;user-select:text!important;pointer-events:auto!important}
      #hs-pretty{cursor:text}

      /* Button press feedback */
      #hs-copybox button{transition:transform 120ms ease, filter 120ms ease, background-color 120ms ease}
      #hs-copybox button:active{transform:translateY(1px) scale(0.99);filter:brightness(0.96)}
      #hs-copybox button.ptv-pressed{transform:translateY(1px) scale(0.98);filter:brightness(0.92)}
    `;
    document.documentElement.append(style, ui);

    // Bind once: selection guard to prevent mid-drag rerenders
    const prettyEl = $('#hs-pretty');
    if (prettyEl && !prettyEl.dataset._ptvBound) {
      prettyEl.dataset._ptvBound = '1';
      prettyEl.addEventListener('mousedown', () => { PTV_SELECTING = true; }, true);
      window.addEventListener('mouseup', () => { PTV_SELECTING = false; }, true);
    }

    // Persistent Show button
    showBtn = document.createElement('button');
    showBtn.id = 'hs-showbtn'; showBtn.textContent = 'Show'; showBtn.className = 'hidden';
    document.documentElement.appendChild(showBtn);

    // Theme
    const themeInput = $('#hs-theme');
    const applyTheme = t => {
      ui.classList.toggle('ptv-light', t==='light');
      ui.classList.toggle('ptv-dark',  t==='dark');
      showBtn.classList.toggle('ptv-light', t==='light');
      showBtn.classList.toggle('ptv-dark',  t==='dark');
      if (VARS_FLY) {
        VARS_FLY.classList.toggle('ptv-light', t==='light');
        VARS_FLY.classList.toggle('ptv-dark',  t==='dark');
      }
      localStorage.setItem(THEME_KEY, t);
      themeInput.checked = (t === 'dark');
    };
    applyTheme(localStorage.getItem(THEME_KEY) || 'light');
    themeInput.addEventListener('change', () => applyTheme(themeInput.checked ? 'dark' : 'light'));

    // Toggle Variables
    VARS_TOGGLE = $('#hs-vars-toggle');
    VARS_ENABLED = false; // default OFF
VARS_TOGGLE.checked = VARS_ENABLED;
// (optional) keep storage in sync:
localStorage.setItem(VARS_KEY, '0');
    VARS_TOGGLE.checked = VARS_ENABLED;
    VARS_TOGGLE.addEventListener('change', () => {
      VARS_ENABLED = VARS_TOGGLE.checked;
      localStorage.setItem(VARS_KEY, VARS_ENABLED ? '1' : '0');
      if (VARS_ENABLED) { if (!VARS_FLY) createVarsFlyout(); positionVarsFlyout(); VARS_FLY.classList.remove('hidden'); }
      else { VARS_FLY?.classList.add('hidden'); }
      // Reset choices on toggle (fresh from current segment)
      PREV_BASE_PLAIN = ''; // force rebuild on next render
      render();
    });

    // Copy
    const copyHandler = async () => {
      const text = $('#hs-out')?.value || '';
      try {
        if (typeof GM_setClipboard === 'function') return GM_setClipboard(text, { type:'text', mimetype:'text/plain' });
        await navigator.clipboard.writeText(text);
      } catch {
        const ta = $('#hs-out'); if (ta) { ta.focus(); ta.select(); document.execCommand('copy'); }
      }
    };
    $('#hs-copybtn').addEventListener('click', copyHandler);
    addClickFeedback($('#hs-copybtn'));

    // Font size controller
    const fsInput = $('#hs-fs'), applyFs = () => {
      const px = Math.max(10, Math.min(48, Number(fsInput.value || 14) || 14));
      const pretty = $('#hs-pretty'); if (pretty) pretty.style.fontSize = px + 'px';
    };
    fsInput.addEventListener('input', applyFs);
    fsInput.addEventListener('change', applyFs);
    applyFs();

    // Show button near panel's right edge
    const positionShowButtonNearHide = () => {
      if (!ui || !showBtn) return;
      const r = ui.getBoundingClientRect();
      showBtn.style.left = Math.round(r.left + r.width - 88) + 'px';
      showBtn.style.bottom = Math.max(8, Math.round(window.innerHeight - r.bottom)) + 'px';
    };

    // Hide/Show
    const doHide = () => { positionShowButtonNearHide(); ui.classList.add('hidden'); showBtn.classList.remove('hidden'); VARS_FLY?.classList.add('hidden'); };
    const doShow = () => { ui.classList.remove('hidden'); showBtn.classList.add('hidden'); if (VARS_ENABLED) { positionVarsFlyout(); VARS_FLY?.classList.remove('hidden'); } };
    $('#hs-hide').addEventListener('click', doHide);
    addClickFeedback($('#hs-hide'));
    showBtn.addEventListener('click', doShow);

    // Reposition flyout / show button on resize
    window.addEventListener('resize', () => {
      if (ui.classList.contains('hidden')) { positionShowButtonNearHide(); }
      if (VARS_ENABLED && !ui.classList.contains('hidden')) positionVarsFlyout();
    });

    // Keyboard toggle (Alt+P)
    window.addEventListener('keydown', e => {
      if (e.altKey && (e.key==='p'||e.key==='P')) ui.classList.contains('hidden') ? showBtn.click() : $('#hs-hide').click();
    }, true);

    // Create the flyout after UI exists
    createVarsFlyout();
    // Initial visibility
    if (VARS_ENABLED) { positionVarsFlyout(); VARS_FLY.classList.remove('hidden'); }
    else { VARS_FLY.classList.add('hidden'); }
  }

  function createVarsFlyout(){
    if (VARS_FLY) return;
    VARS_FLY = document.createElement('div');
    VARS_FLY.id = 'hs-vars-flyout';
    VARS_FLY.className = 'hidden'; // visible only when enabled
    // match theme
    const t = localStorage.getItem(THEME_KEY) || 'light';
    VARS_FLY.classList.add(t === 'dark' ? 'ptv-dark' : 'ptv-light');
    VARS_FLY.innerHTML = `<div class="vars-list" id="hs-vars-list"></div>`;
    document.documentElement.appendChild(VARS_FLY);
  }

  function positionVarsFlyout(){
    if (!ui || !VARS_FLY) return;
    const toggleLabel = $('.hs-vars-toggle'); // label that contains the checkbox + text
    const r = toggleLabel?.getBoundingClientRect();
    if (!r) return;
    // Align left to the label's left; place directly above it with a small gap.
    VARS_FLY.style.left = Math.round(r.left) + 'px';
    VARS_FLY.style.bottom = Math.max(8, Math.round(window.innerHeight - r.top + 6)) + 'px';
  }

  const setPreview = (plain, html) => {
    const pretty = $('#hs-pretty'), ta = $('#hs-out');
    if (!pretty || !ta) return;
    if (PTV_RENDER_CACHE.plain === (plain||'') && PTV_RENDER_CACHE.html === (html||'')) return; // no-op
    PTV_RENDER_CACHE.plain = plain || ''; PTV_RENDER_CACHE.html = html || '';
    pretty.innerHTML = PTV_RENDER_CACHE.html; ta.value = PTV_RENDER_CACHE.plain;
  };

  /* ===================== Decoding / conversion ===================== */
  const decodeHtml = s => { const t = document.createElement('textarea'); t.innerHTML = s; return t.value; };
  const escapeHtml = s => String(s ?? '').replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch]));
  const stripNumericBraces = s => String(s ?? '').replace(/\{(\d+)\}/g, '$1'); // "{123}" → "123"

  // Remove everything between [[...]] non-greedily (works on plain or html; spans are fine)
  const stripDoubleBrackets = s => String(s ?? '').replace(/\[\[[\s\S]*?\]\]/g, '');

  // For logic that must *ignore* bracketed text (without modifying original), compute ranges.
  function findBracketRanges(s) {
    const ranges = [];
    const re = /\[\[|\]\]/g;
    let m, stack = [];
    while ((m = re.exec(s))) {
      if (m[0] === '[[') stack.push(m.index);
      else if (m[0] === ']]' && stack.length) {
        const start = stack.pop();
        ranges.push([start, m.index + 2]); // half-open [start,end)
      }
    }
    return ranges.sort((a,b)=>a[0]-b[0]);
  }
  function indexInRanges(i, ranges){
    for (const [a,b] of ranges) { if (i>=a && i<b) return true; if (i<b) continue; }
    return false;
  }
  const removeBracketed = s => stripDoubleBrackets(s); // alias for clarity

  function extractPhraseTagValue(el) {
    const meta = el.querySelector?.('.tag_metadata_content')?.textContent || el.getAttribute?.('tmp-title') || el.getAttribute?.('title') || '';
    if (!meta) return { text:'', fromTag:true };
    const un = decodeHtml(meta);
    // mq:rxt
    let m = un.match(/displaytext="([^"]*)"/i) || un.match(/val="([^"]*)"/i);
    if (m) return { text: decodeHtml(m[1]||''), fromTag:true };
    // bpt/ept or generic inner
    let inner = un.match(/<(?:bpt|ept)\b[^>]*>([\s\S]*?)<\/(?:bpt|ept)>/i) || un.match(/<\w+\b[^>]*>([\s\S]*?)<\/\w+>/i);
    if (inner) return { text: decodeHtml(inner[1]||''), fromTag:true };
    // placeholder fallback
    return { text: el.getAttribute?.('data-tag-content') || '', fromTag:true };
  }

  function rebuildConvertedRich(container) {
    if (!container) return { plain:'', html:'' };
    let plain = '', html = '';
    container.childNodes.forEach(n => {
      if (n.nodeType === 3) { const t = n.nodeValue || ''; plain += t; html += escapeHtml(t); return; }
      if (n.nodeType !== 1) return;
      const el = n;
      if (el.classList?.contains('te_txt')) {
        const t = el.textContent || ''; plain += t; html += escapeHtml(t); return;
      }
      if (el.classList?.contains('te_tag') || el.matches?.('[data-testid="tag"],[data-tag],[data-tag-type]')) {
        const { text } = extractPhraseTagValue(el);
        const m = /^\{(\d+)\}$/.exec(text);
        if (m) { const num = m[1]; plain += num; html += `<span class="hs-taglit">${escapeHtml(num)}</span>`; }
        else   { plain += text; html += `<span class="hs-taglit">${escapeHtml(text)}</span>`; }
      }
    });
    return { plain: stripNumericBraces(plain), html };
  }

  /* ===================== Variable scanning / applying ===================== */
  // Utility: scan all '@' positions and also return 1-based index for each (@#)
  function scanAtPositions(s) {
    const pos = [];
    for (let i = 0, nth = 0; i < s.length; i++) if (s[i] === '@') { nth++; pos.push({ idx:i, nth }); }
    return pos;
  }

  // Collect all |4(a,b) occurrences (in textual order)
  function scanOrPairs(s) {
    const re = /\|4\(\s*([^,]*?)\s*,\s*([^)]+?)\s*\)/g;
    const out = [];
    let m; while ((m = re.exec(s))) {
      out.push({ a: m[1].trim(), b: m[2].trim() });
    }
    return out;
  }

  // --------- Normalization + Dice overlap scoring ---------
  const DICE_MIN = 0.55;      // tweakable
  const RATIO_MIN = 0.65;     // min(min(nL,nR)/max(nL,nR))
  const MIN_TOKENS = 4;       // avoid tiny stubs

  function neutralizeOr(s) { return s.replace(/\|4\(\s*[^,]+?\s*,\s*[^)]+?\s*\)/g, ' ALT '); }
  function stripHtmlTags(s) { return s.replace(/<[^>]+>/g, ' '); }
  function tokenize(s) {
    const m = s.toLowerCase().match(/[0-9A-Za-zÀ-ÖØ-öø-ÿ]+/g);
    return m ? m : [];
  }
  function bag(tokens) {
    const map = new Map();
    for (const t of tokens) map.set(t, (map.get(t)||0) + 1);
    return map;
  }
  function bagSize(map) { let n = 0; for (const v of map.values()) n += v; return n; }
  function bagIntersectionSize(a, b) {
    let n = 0; for (const [tok, ca] of a.entries()) { const cb = b.get(tok); if (cb) n += Math.min(ca, cb); } return n;
  }

  // Choose ONE useful '@' split by Dice + size sanity, ignoring any @ inside [[...]].
  // Return {nth} where nth is the 1-based ordinal in the ORIGINAL string (including bracketed areas).
  function pickBestAtNth(original) {
    const ranges = findBracketRanges(original);
    const atPos = scanAtPositions(original).filter(p => !indexInRanges(p.idx, ranges));
    if (!atPos.length) return { nth: 0 };

    // Prepare a bracket-stripped copy for size/similarity decisions
    const s = removeBracketed(original);

    // Map from original index to index in stripped string to slice cleanly
    // (We can approximate by rebuilding with a walk.)
    const mapOrigToStripped = (() => {
      const arr = new Array(original.length).fill(-1);
      let j = 0, k = 0;
      while (k < original.length) {
        // If we're inside a bracket range, skip until end of that range
        let skipped = false;
        for (const [a,b] of ranges) {
          if (k >= a && k < b) { k = b; skipped = true; break; }
        }
        if (skipped) continue;
        arr[k] = j; j++; k++;
      }
      return arr;
    })();

    let bestNth = 0;
    let bestDice = -1;

    for (const { idx, nth } of atPos) {
      const si = mapOrigToStripped[idx];
      if (si < 0) continue; // shouldn't happen; safety

      const left  = s.slice(0, si);
      const right = s.slice(si + 1);

      // normalize: neutralize |4(...), strip tags, collapse spaces
      let Ls = stripHtmlTags(neutralizeOr(left)).replace(/\s+/g, ' ').trim();
      let Rs = stripHtmlTags(neutralizeOr(right)).replace(/\s+/g, ' ').trim();

      const L = tokenize(Ls), R = tokenize(Rs);
      const nL = L.length, nR = R.length;
      if (nL < MIN_TOKENS || nR < MIN_TOKENS) continue;

      const ratio = Math.min(nL, nR) / Math.max(nL, nR);
      if (ratio < RATIO_MIN) continue;

      const BL = bag(L), BR = bag(R);
      const inter = bagIntersectionSize(BL, BR);
      const dice = (2 * inter) / (bagSize(BL) + bagSize(BR));

      if (dice >= DICE_MIN && dice > bestDice) {
        bestDice = dice; bestNth = nth; // NOTE: nth refers to original-string order
      }
    }

    return { nth: bestNth };
  }

  // Resolve the Nth '@' (1-based, in ORIGINAL string). If nth=0 or not found, return original.
  // choice: 'before' -> keep left side; 'after' -> keep right side
  function resolveAtNth(text, choice, nth) {
    if (!nth || (choice !== 'before' && choice !== 'after')) return text;
    let seen = 0;
    for (let i = 0; i < text.length; i++) {
      if (text[i] === '@') {
        seen++;
        if (seen === nth) {
          return (choice === 'after') ? text.slice(i+1) : text.slice(0, i);
        }
      }
    }
    return text;
  }

  // Resolve |4(a,b) with provided choices (array of 'a'|'b')
  function resolveOr(text, choices) {
    const re = /\|4\(\s*([^,]*?)\s*,\s*([^)]+?)\s*\)/g;
    let k = 0;
    return text.replace(re, (_, a, b) => ((choices && choices[k++] === 'b') ? b : a));
  }

  // Build/refresh variable flyout for a given base text (vertical list, unified, switch controls)
  function buildVarsFlyout(basePlain) {
    if (!VARS_FLY) return;
    const list = $('#hs-vars-list');
    if (!list) return;
    list.textContent = '';

    // Choose the single useful '@' (or none), ignoring [[...]]
    const picked = pickBestAtNth(basePlain);
    VAR_AT_NTH = picked.nth || 0;

    // Scan all |4 pairs
    const orPairs = scanOrPairs(basePlain);

    // Reset choices on segment change
    VAR_CHOICES = {
      at: 'before',
      or: new Array(orPairs.length).fill('a')
    };

    // Helper to make a switch row
    function makeSwitchRow(leftLabel, rightLabel, checked, onChange) {
      const row = document.createElement('div');
      row.className = 'vars-item';

      const left = document.createElement('span');
      left.className = 'vars-option left';
      left.textContent = leftLabel;

      const right = document.createElement('span');
      right.className = 'vars-option right';
      right.textContent = rightLabel;

      const sw = document.createElement('label');
      sw.className = 'ptv-switch';
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.checked = !!checked;
      const track = document.createElement('span'); track.className = 'track';
      const thumb = document.createElement('span'); thumb.className = 'thumb';
      input.addEventListener('change', () => onChange(input.checked));

      sw.appendChild(input); sw.appendChild(track); sw.appendChild(thumb);

      const labelWrap = document.createElement('div');
      labelWrap.className = 'vars-label';
      // layout: LeftLabel  [switch]  RightLabel
      labelWrap.appendChild(left);
      labelWrap.appendChild(sw);
      labelWrap.appendChild(right);

      row.appendChild(labelWrap);
      return row;
    }

    // Single @ toggle (only if we found a useful split)
    if (VAR_AT_NTH > 0) {
      // Checked (ball on right) → "After @"
      const row = makeSwitchRow('Before @', 'After @', false, (checked) => {
        VAR_CHOICES.at = checked ? 'after' : 'before';
        render();
      });
      list.appendChild(row);
    }

    // |4 toggles (each pair in its own vertical row)
    orPairs.forEach((p, i) => {
      // Checked (ball on right) → choose 'b'
      const row = makeSwitchRow(p.a || 'a', p.b || 'b', false, (checked) => {
        VAR_CHOICES.or[i] = checked ? 'b' : 'a';
        render();
      });
      list.appendChild(row);
    });

    if (list.children.length === 0) {
      const none = document.createElement('div');
      none.className = 'vars-item';
      none.textContent = 'No variables found in this segment.';
      list.appendChild(none);
    }
  }

  // Apply variable choices to both plain and html strings, then strip [[...]] for final output
  function applyVariablesToOutputs(basePlain, baseHtml) {
    // Resolve the selected @ (same Nth in both plain/html based on ORIGINAL strings)
    let p = resolveAtNth(basePlain, VAR_CHOICES.at, VAR_AT_NTH);
    let h = resolveAtNth(baseHtml,  VAR_CHOICES.at, VAR_AT_NTH);
    // Then resolve |4(a,b)
    p = resolveOr(p, VAR_CHOICES.or);
    h = resolveOr(h, VAR_CHOICES.or);
    // Finally, remove double-bracketed content from both outputs for printing
    p = stripDoubleBrackets(p);
    h = stripDoubleBrackets(h);
    return { plain: p, html: h };
  }

  /* ===================== Active row ===================== */
  const finders = {
    byCaret: d => d.getElementById?.('segment-text-editor-input')?.closest?.('.twe_segment') || null,
    byCursor: d => d.querySelector?.('.twe_segment .twe_target .te_selection_container .te_cursor')?.closest?.('.twe_segment') || null,
    byFocusedInput(d) {
      const a = d.activeElement; if (!a) return null;
      return a.matches?.('input.twe-main-input, textarea.twe-main-input, [contenteditable="true"]')
        ? (a.closest('.twe_segment') || a.closest('[data-testid="segment"]') || null) : null;
    },
    byActiveClass: d => d.querySelector?.('.twe_segment.twe_active, .twe_segment.twe_active_background, [data-testid="segment"][data-selected="true"]')
  };

  function readActiveFromDoc(doc) {
    const row = finders.byCaret(doc) || finders.byCursor(doc) || finders.byFocusedInput(doc) || finders.byActiveClass(doc);
    if (!row) return { row:null, plain:'', html:'' };
    const cont = row.querySelector?.('.twe_target .te_text_container') ||
                 row.querySelector?.('[data-testid="target"] .te_text_container') ||
                 row.querySelector?.('.twe_target [data-role="text-container"]');
    if (cont) return { row, ...rebuildConvertedRich(cont) };
    const live = row.querySelector?.('.twe_target .twe-main-input, textarea.twe-main-input, [contenteditable="true"]');
    const raw = (live && (live.value || live.textContent)) || '';
    return { row, plain: stripNumericBraces(raw), html: escapeHtml(raw) };
  }

  /* ===================== Iframes (same-origin sweep) ===================== */
  function getAllDocs(rootDoc = document, acc = new Set()) {
    if (!rootDoc || acc.has(rootDoc)) return { docs: Array.from(acc), totalFrames:0, okFrames:0 };
    acc.add(rootDoc);
    const ifr = rootDoc.querySelectorAll('iframe'); let total=0, ok=0;
    for (const f of ifr) {
      total++;
      try {
        const d = f.contentDocument || f.contentWindow?.document;
        if (d) { ok++; const nested = getAllDocs(d, acc); total += nested.totalFrames; ok += nested.okFrames; }
      } catch {}
    }
    return { docs: Array.from(acc), totalFrames:total, okFrames:ok };
  }

  /* ===================== Bridge ===================== */
  const MSG_MARK = '__hs_bridge__';
  const postToChildren = msg => { if (!IS_TOP) return; for (let i=0;i<window.frames.length;i++) { try { window.frames[i].postMessage({[MSG_MARK]:true, ...msg}, '*'); } catch {} } };
  const postToParent   = msg => { if (IS_TOP) return; try { window.parent.postMessage({[MSG_MARK]:true, ...msg }, '*'); } catch {} };

  window.addEventListener('message', e => {
    const d = e?.data; if (!d || !d[MSG_MARK]) return;
    if (IS_TOP) {
      if (d.type === 'ACTIVE') {
        lastActive = { plain: (d.payload?.plain ?? d.payload?.text) || '', html: d.payload?.html || '' };
        ensureUI(); render();
      }
    } else {
      if (d.type === 'PING')            postToParent({ type:'PONG', frameId:ORIGIN_ID, info:'editor-frame' });
      if (d.type === 'REQUEST_ACTIVE') {
        const r = readActiveFromDoc(document);
        postToParent({ type:'ACTIVE', frameId:ORIGIN_ID, info:'editor-frame', payload:{ plain:r.plain||'', html:r.html||'' } });
      }
    }
  }, true);

  /* ===================== Render/update ===================== */
  function render() {
    if (!IS_TOP || PTV_SELECTING) return;
    ensureUI();

    // same-origin first
    const { docs } = getAllDocs(document);
    let found = null;
    for (const d of docs) { const r = readActiveFromDoc(d); if (r.row) { found = r; break; } }
    const active = found || lastActive || null;

    const basePlain = active?.plain || '';
    const baseHtml  = active?.html  || '';

    if (!VARS_ENABLED) {
      // Even without variables, we must hide [[...]] in preview/copy
      const p = stripDoubleBrackets(basePlain);
      const h = stripDoubleBrackets(baseHtml);
      setPreview(p, h);
      PREV_BASE_PLAIN = basePlain; // cache even when off
      VARS_FLY?.classList.add('hidden'); // ensure flyout hidden when disabled
      return;
    }

    // VARS mode: ensure flyout visible & positioned
    positionVarsFlyout();
    VARS_FLY?.classList.remove('hidden');

    // Rebuild flyout if segment changed
    if (PREV_BASE_PLAIN !== basePlain) {
      buildVarsFlyout(basePlain);
      PREV_BASE_PLAIN = basePlain;
    }

    // Apply choices → outputs (then strip [[...]])
    const resolved = applyVariablesToOutputs(basePlain, baseHtml);
    setPreview(resolved.plain, resolved.html);
  }

  function wireInstantSignals() {
    const instant = () => { IS_TOP ? render() : tickFrame(); };
    ['input','keyup','selectionchange','pointerup','focusin'].forEach(ev => document.addEventListener(ev, instant, true));
  }

  function tickTop()   { postToChildren({type:'PING'}); postToChildren({type:'REQUEST_ACTIVE'}); render(); }
  function tickFrame() {
    const r = readActiveFromDoc(document);
    if (r && (r.row || r.plain || r.html)) postToParent({ type:'ACTIVE', frameId:ORIGIN_ID, info:'editor-frame', payload:{ plain:r.plain||'', html:r.html||'' } });
    else                                   postToParent({ type:'PONG',   frameId:ORIGIN_ID, info:'probe' });
  }

  /* ===================== Boot ===================== */
  function boot() {
    if (IS_TOP) ensureUI();
    // Load last-used variable toggle preference
    VARS_ENABLED = false; // default OFF on every load
if (IS_TOP && $('#hs-vars-toggle')) $('#hs-vars-toggle').checked = VARS_ENABLED;
// (optional)
localStorage.setItem(VARS_KEY, '0');
    if (IS_TOP && $('#hs-vars-toggle')) $('#hs-vars-toggle').checked = VARS_ENABLED;
    wireInstantSignals();
    const tick = IS_TOP ? tickTop : tickFrame;
    setTimeout(tick, 300);
    setInterval(tick, 350);
  }
  boot();
})();
      </script>
    </div>

    <div class="card">
      <h2>4) Open Phrase and try it</h2>
      <ul>
        <li>Open a job in <b>app.phrase.com</b> (or your Memsource domain).</li>
        <li>Select a <b>target segment</b>.</li>
        <li>Look for the “<b>Phrase Tag Viewer</b>” panel at the bottom-left of the page.</li>
        <li>Use <b>Copy</b> to copy the plain converted string, or toggle Dark mode / font size from the menu.</li>
      </ul>
      <p class="ok">If you see text appearing in the panel as you click segments, you’re all set!</p>
    </div>

    <div class="card">
      <h2>Troubleshooting</h2>
      <ul>
        <li>Make sure the userscript is <b>Enabled</b> in Tampermonkey’s Dashboard.</li>
        <li>Ensure the tab URL matches the script’s <code>@match</code> lines (e.g., <code>https://app.phrase.com/…</code>).</li>
        <li>Open the browser console (F12 → Console) and check for red error messages.</li>
        <li>If your team uses multiple Phrase domains, add extra <code>@match</code> lines as needed.</li>
      </ul>
    </div>
  </div>

  <script>
    (function(){
      const payloadTag = document.getElementById('payload');   // <script type="text/plain">
      const codeblock  = document.getElementById('codeblock'); // <code> preview
      const btn        = document.getElementById('copyCodeBtn');

      // Read the userscript as raw text (safe; not parsed/executed)
      const userscript = (payloadTag && payloadTag.textContent) ? payloadTag.textContent.trim() : '';

      // Show in the visible code box (use textContent for safety)
      codeblock.textContent = userscript || '(no script pasted yet)';

      btn.addEventListener('click', async () => {
        const text = userscript || '';
        if (!text) { btn.textContent = 'Nothing to copy'; setTimeout(()=>btn.textContent='Copy code', 1300); return; }
        try {
          await navigator.clipboard.writeText(text);
          btn.textContent = 'Copied!';
          setTimeout(() => btn.textContent = 'Copy code', 1400);
        } catch (e) {
          // Fallback
          const ta = document.createElement('textarea');
          ta.value = text; ta.style.position = 'fixed'; ta.style.left='-9999px'; ta.style.top='-9999px';
          document.body.appendChild(ta); ta.focus(); ta.select();
          const ok = document.execCommand('copy');
          document.body.removeChild(ta);
          btn.textContent = ok ? 'Copied!' : 'Select & Ctrl+C';
          setTimeout(() => btn.textContent = 'Copy code', 1400);
        }
      });
    })();
  </script>

  <h2>Improved Tag Viewer ("Phrase Buddy" beta version)</h2>
  <div class="codewrap">
    <button class="copybtn" id="copyPBCodeBtn">Copy code</button>
    <pre><code id="pbCodeblock">(no script pasted yet)</code></pre>
  </div>
  <script id="pb-payload" type="text/plain">
// ==UserScript==
// @name         Phrase Buddy
// @namespace    http://tampermonkey.net/
// @version      0.9.0
// @description  Buddy shell with modular panels and Unicode tooling.
// @match        https://app.phrase.com/*
// @match        https://*.phrase.com/*
// @match        https://cloud.memsource.com/*
// @match        https://*.memsource.com/*
// @exclude      https://cloud.memsource.com/web/project*
// @exclude      https://cloud.memsource.com/web/job2/list*
// @exclude      https://cloud.memsource.com/tms/transMemory/list*
// @exclude      https://cloud.memsource.com/tms/setup/*
// @exclude      https://cloud.memsource.com/web/setup/*
// @run-at       document-idle
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_deleteValue
// @grant        GM_addValueChangeListener
// ==/UserScript==

/**
 * Module: tool-defaults
 * Responsibility: Define factory default states for all Phrase Buddy tools.
 *                 These are immutable, hardcoded defaults that represent the
 *                 desired initial state when tools are first installed.
 *                 Separate from runtime state (which can be changed and persisted).
 *                 Centralize all tool IDs and state keys for consistency.
 * Dependencies: None
 */

// ============================================================================
// Tool IDs - Single source of truth for all tool identifiers
// ============================================================================
const TOOL_IDS = {
  TAG_VIEWER: 'phrase-tag-viewer',
  CHARACTER_DETECTOR: 'character-detector',
};

// ============================================================================
// Tool State Keys - Single source of truth for all persisted tool states
// ============================================================================
const TOOL_STATE_KEYS = {
  // Tag Viewer - Master enable (handled by tool-state-manager with TOOL_IDS.TAG_VIEWER)
  TAG_CLICK_ENABLED: 'pb.tags.clickToViewer.v1',
  TAG_WINDOW_ENABLED: 'pb.tags.modalWindow.v1',
  // Font sizes (handled by tool-state-manager numeric settings)
  TAB_FONT_SIZE: 'pb_tv_tab_font_size',
  WINDOW_FONT_SIZE: 'pb_tv_window_font_size',
};

// ============================================================================
// Tool Defaults - Factory configuration for all tools
// ============================================================================
const TOOL_DEFAULTS = {
  'phrase-tag-viewer': {
    enabled: false,  // Master enable - disabled by default
    name: 'Tag Viewer',
    
    // Tag clicking feature
    tagClickingEnabled: true,  // Enable tag clicking by default
    
    // Tag Viewer window feature
    windowEnabled: false,  // Disable window by default
    windowPosition: { left: 8, top: 'auto', bottom: 8 },  // Bottom-left corner
    windowSize: { w: 650, h: 160 },  // Default dimensions
    
    // Font sizes (in pixels)
    tabFontSize: 15,  // Default tab viewport font size
    windowFontSize: 15,  // Default window viewport font size
    
    // Legacy / compatibility
    fontSizePx: 15,  // Deprecated, use tabFontSize
    windowState: null,  // Will be set on first modal open
  },
  'character-detector': {
    enabled: false,  // Disabled by default
    name: 'Character Detector',
  },
};

/**
 * Get all factory defaults
 * @returns {Object} TOOL_DEFAULTS object
 */
function getAllDefaults() {
  return TOOL_DEFAULTS;
}

/**
 * Get default enabled state for a specific tool
 * @param {string} toolId - The tool ID
 * @returns {boolean} The default enabled state (defaults to false if tool not found)
 */
function getDefaultState(toolId) {
  return TOOL_DEFAULTS[toolId]?.enabled ?? false;
}

/**
 * Get default config for a specific tool
 * @param {string} toolId - The tool ID
 * @returns {Object|null} The tool's default config or null if not found
 */
function getDefaultConfig(toolId) {
  return TOOL_DEFAULTS[toolId] ?? null;
}

// Export public API
window.PB_ToolDefaults = {
  TOOL_IDS,
  TOOL_STATE_KEYS,
  getAllDefaults,
  getDefaultState,
  getDefaultConfig,
};

/**
 * Module: tool-state-manager
 * Responsibility: Manage persistence and retrieval of tool enable/disable states.
 *                 Handles storage via Tampermonkey GM_setValue/GM_getValue.
 *                 Separate from tool defaults (which are factory config).
 * Dependencies: Tampermonkey GM_* functions
 */

const STORAGE_PREFIX = 'pb_tool_state_';

/**
 * Get the storage key for a tool
 * @param {string} toolId - The tool ID
 * @returns {string} The storage key
 */
function getStorageKey(toolId) {
  return `${STORAGE_PREFIX}${toolId}`;
}

/**
 * Get saved state for a specific tool
 * @param {string} toolId - The tool ID
 * @returns {boolean|null} The saved state (true/false) or null if not set
 */
function getToolState(toolId) {
  // Safety check: ensure GM_getValue is available
  if (typeof GM_getValue !== 'function') {
    console.warn(`[Phrase Buddy] GM_getValue not available when getting state for ${toolId}`);
    return null;
  }
  
  try {
    const saved = GM_getValue(getStorageKey(toolId));
    return saved !== undefined ? saved : null;  // null means not yet saved
  } catch (error) {
    console.error(`[Phrase Buddy] Error getting state for ${toolId}:`, error);
    return null;
  }
}

/**
 * Set and persist state for a specific tool
 * @param {string} toolId - The tool ID
 * @param {boolean} enabled - The new enabled state
 */
function setToolState(toolId, enabled) {
  // Safety check: ensure GM_setValue is available
  if (typeof GM_setValue !== 'function') {
    console.warn(`[Phrase Buddy] GM_setValue not available when saving state for ${toolId}`);
    return;
  }
  
  try {
    GM_setValue(getStorageKey(toolId), enabled);

  } catch (error) {
    console.error(`[Phrase Buddy] Error saving state for ${toolId}:`, error);
  }
}

/**
 * Get all saved tool states
 * @returns {Object} Object with toolId -> boolean mapping
 */
function getAllToolStates() {
  const toolIds = ['phrase-tag-viewer', 'character-detector'];
  const states = {};
  
  toolIds.forEach((toolId) => {
    const saved = getToolState(toolId);
    if (saved !== null) {
      states[toolId] = saved;
    }
  });
  
  return states;
}

/**
 * Initialize tool states on first run.
 * If a tool has no saved state, initialize it with the default.
 * If already saved, leave it untouched (preserves user choices).
 * @param {Object} defaults - Object with toolId -> defaultEnabled mapping
 */
function initializeToolStates(defaults) {
  Object.entries(defaults).forEach(([toolId, defaultState]) => {
    const saved = getToolState(toolId);
    
    if (saved === null) {
      // Not yet saved, initialize with default
      setToolState(toolId, defaultState);
    }
    // Else: already saved, keep user's choice
  });
}

/**
 * Reset all tools to their default states and persist
 * @param {Object} defaults - Object with toolId -> defaultEnabled mapping
 * @returns {Object} The reset states
 */
function resetAllToolsToDefaults(defaults) {
  const resetStates = {};
  
  Object.entries(defaults).forEach(([toolId, defaultState]) => {
    setToolState(toolId, defaultState);
    resetStates[toolId] = defaultState;
  });
  
  return resetStates;
}

/**
 * Get saved numeric setting (e.g., font sizes)
 * @param {string} settingKey - The setting key
 * @returns {number|null} The saved value or null if not set
 */
function getNumericSetting(settingKey) {
  if (typeof GM_getValue !== 'function') {
    console.warn(`[Phrase Buddy] GM_getValue not available when getting setting ${settingKey}`);
    return null;
  }
  
  try {
    const saved = GM_getValue(settingKey);
    if (saved !== undefined && Number.isFinite(Number(saved))) {
      return Number(saved);
    }
  } catch (error) {
    console.error(`[Phrase Buddy] Error getting setting ${settingKey}:`, error);
  }
  
  return null;
}

/**
 * Set and persist a numeric setting
 * @param {string} settingKey - The setting key
 * @param {number} value - The value to save
 */
function setNumericSetting(settingKey, value) {
  if (typeof GM_setValue !== 'function') {
    console.warn(`[Phrase Buddy] GM_setValue not available when saving setting ${settingKey}`);
    return;
  }
  
  try {
    const numValue = Number(value);
    if (Number.isFinite(numValue)) {
      GM_setValue(settingKey, numValue);
    }
  } catch (error) {
    console.error(`[Phrase Buddy] Error saving setting ${settingKey}:`, error);
  }
}

/**
 * Load tab font size from storage
 * @returns {number|null} Font size in pixels or null if not saved
 */
function getTabFontSize() {
  return getNumericSetting('pb_tv_tab_font_size');
}

/**
 * Save tab font size to storage
 * @param {number} fontSize Font size in pixels
 */
function saveTabFontSize(fontSize) {
  setNumericSetting('pb_tv_tab_font_size', fontSize);
}

/**
 * Load window font size from storage
 * @returns {number|null} Font size in pixels or null if not saved
 */
function getWindowFontSize() {
  return getNumericSetting('pb_tv_window_font_size');
}

/**
 * Save window font size to storage
 * @param {number} fontSize Font size in pixels
 */
function saveWindowFontSize(fontSize) {
  setNumericSetting('pb_tv_window_font_size', fontSize);
}

// Export public API
window.PB_ToolStateManager = {
  getToolState,
  setToolState,
  getAllToolStates,
  initializeToolStates,
  resetAllToolsToDefaults,
  getNumericSetting,
  setNumericSetting,
  getTabFontSize,
  saveTabFontSize,
  getWindowFontSize,
  saveWindowFontSize,
};

console.log('[Phrase Buddy] Tool state manager initialized');

/**
 * Module: tool-runtime-manager
 * Responsibility: Manage the runtime activation/deactivation of tools.
 *                 Fires events when tools are activated or deactivated.
 *                 Separate from tool state (which is persisted) - this tracks
 *                 which tools are currently active at runtime.
 * Dependencies: None, but other modules listen for tool:activated/tool:deactivated events
 */

/**
 * Stores which tools are currently active at runtime
 * Format: { toolId: boolean }
 */
const TOOL_RUNTIME_ACTIVE = {};

/**
 * Check if a tool is currently active at runtime
 * @param {string} toolId - The tool ID
 * @returns {boolean} Whether the tool is active
 */
function getToolActive(toolId) {
  return TOOL_RUNTIME_ACTIVE[toolId] ?? false;
}

/**
 * Activate or deactivate a tool at runtime and fire events
 * @param {string} toolId - The tool ID
 * @param {boolean} active - Whether to activate or deactivate
 */
function setToolActive(toolId, active) {
  // Check if tool has been initialized - undefined means never set
  const wasActive = TOOL_RUNTIME_ACTIVE.hasOwnProperty(toolId) 
    ? TOOL_RUNTIME_ACTIVE[toolId] 
    : undefined;
  
  // Only skip if explicitly initialized and value matches
  // This ensures first state change always fires an event
  if (wasActive !== undefined && wasActive === active) {
    return;
  }
  
  // Update runtime state
  TOOL_RUNTIME_ACTIVE[toolId] = active;
  
  // Fire appropriate event
  if (active) {
    const event = new CustomEvent('tool:activated', {
      detail: { toolId },
      bubbles: true,
      cancelable: true,
    });
    document.dispatchEvent(event);
    console.log(`[Phrase Buddy] Tool activated: ${toolId}`);
  } else {
    const event = new CustomEvent('tool:deactivated', {
      detail: { toolId },
      bubbles: true,
      cancelable: true,
    });
    document.dispatchEvent(event);
    console.log(`[Phrase Buddy] Tool deactivated: ${toolId}`);
  }
}

/**
 * Get all currently active tools
 * @returns {Array} Array of active tool IDs
 */
function getAllActiveTools() {
  return Object.entries(TOOL_RUNTIME_ACTIVE)
    .filter(([, active]) => active)
    .map(([toolId]) => toolId);
}

/**
 * Initialize runtime state based on tool state
 * Sets up initial active/inactive status for all tools
 * Uses setToolActive to ensure proper event firing on subsequent changes
 * @param {Object} toolStates - Object with toolId -> boolean mapping
 */
function initializeToolRuntime(toolStates) {
  Object.entries(toolStates).forEach(([toolId, isEnabled]) => {
    // Set runtime state directly WITHOUT firing events during initialization
    // This ensures first setToolActive() call will see wasActive correctly
    TOOL_RUNTIME_ACTIVE[toolId] = isEnabled;
  });
}

/**
 * Deactivate all tools (useful for cleanup or reset)
 */
function deactivateAllTools() {
  Object.keys(TOOL_RUNTIME_ACTIVE).forEach((toolId) => {
    setToolActive(toolId, false);
  });
}

// Export public API
window.PB_ToolRuntimeManager = {
  getToolActive,
  setToolActive,
  getAllActiveTools,
  initializeToolRuntime,
  deactivateAllTools,
};

console.log('[Phrase Buddy] Tool runtime manager initialized');

/**
 * Module: state-synchronizer
 * Responsibility: Ensure tool state is synchronized across tabs and handle edge cases.
 *                 Monitors external state changes (from other tabs), validates state integrity,
 *                 recovers from errors, and prevents race conditions.
 * Dependencies: tool-state-manager, tool-runtime-manager
 */

/**
 * Tracks pending state changes to debounce rapid updates
 * Format: { toolId: timeoutId }
 */
const PENDING_CHANGES = {};

/**
 * Debounce delay (ms) before syncing external changes to runtime
 */
const SYNC_DEBOUNCE_DELAY = 100;

/**
 * Listen for external state changes (from other tabs)
 * When another tab changes a tool state, sync it to our runtime
 */
function installCrossTabSyncListener() {
  // Check if GM_addValueChangeListener is available
  if (typeof GM_addValueChangeListener !== 'function') {
    console.warn('[Phrase Buddy] GM_addValueChangeListener not available, cross-tab sync disabled');
    return;
  }
  
  const toolIds = ['phrase-tag-viewer', 'character-detector'];
  
  toolIds.forEach((toolId) => {
    const storageKey = `pb_tool_state_${toolId}`;
    
    try {
      GM_addValueChangeListener(storageKey, (key, oldValue, newValue, remote) => {
        // Only sync if change came from another context (not our own write)
        if (remote) {
          handleExternalStateChange(toolId, newValue);
        }
      });
    } catch (error) {
      console.warn(`[Phrase Buddy] Failed to install cross-tab listener for ${toolId}:`, error);
    }
  });
  
  console.log('[Phrase Buddy] Cross-tab sync listener installed');
}

/**
 * Handle state change from another tab
 * @param {string} toolId - The tool ID
 * @param {any} newValue - The new value from external source
 */
function handleExternalStateChange(toolId, newValue) {
  // Debounce rapid changes from other tabs
  clearTimeout(PENDING_CHANGES[toolId]);
  
  PENDING_CHANGES[toolId] = setTimeout(() => {
    const isEnabled = !!newValue;  // Ensure boolean
    
    // Validate the change
    if (!validateStateChange(toolId, isEnabled)) {
      console.warn(`[Phrase Buddy] Invalid external state change for ${toolId}`);
      return;
    }
    
    // Sync to runtime without re-persisting (already saved in other tab)
    window.PB_ToolRuntimeManager?.setToolActive?.(toolId, isEnabled);
    
    // Fire event to notify UI of external change
    const event = new CustomEvent('tool:state-synced', {
      detail: { toolId, isEnabled, source: 'external' },
      bubbles: true,
      cancelable: true,
    });
    document.dispatchEvent(event);
    
    console.log(`[Phrase Buddy] External state synced: ${toolId} = ${isEnabled}`);
  }, SYNC_DEBOUNCE_DELAY);
}

/**
 * Validate a state change for correctness
 * @param {string} toolId - The tool ID
 * @param {boolean} newState - The new state value
 * @returns {boolean} Whether the state change is valid
 */
function validateStateChange(toolId, newState) {
  // Check if tool exists
  const isValidTool = ['phrase-tag-viewer', 'character-detector'].includes(toolId);
  if (!isValidTool) {
    return false;
  }
  
  // Check if value is boolean
  if (typeof newState !== 'boolean') {
    return false;
  }
  
  return true;
}

/**
 * Validate all stored tool states for integrity
 * @returns {Object} Validation result with status and details
 */
function validateAllStoredStates() {
  const result = {
    valid: true,
    errors: [],
    repaired: [],
  };
  
  const toolIds = ['phrase-tag-viewer', 'character-detector'];
  
  toolIds.forEach((toolId) => {
    const stored = window.PB_ToolStateManager?.getToolState?.(toolId);
    
    // Null is valid (not yet initialized)
    if (stored === null) {
      return;
    }
    
    // Non-boolean is invalid
    if (typeof stored !== 'boolean') {
      result.valid = false;
      result.errors.push(`${toolId}: invalid type (${typeof stored})`);
      
      // Attempt repair: default to false
      window.PB_ToolStateManager?.setToolState?.(toolId, false);
      result.repaired.push(toolId);
      
      console.warn(`[Phrase Buddy] Repaired corrupted state for ${toolId}`);
    }
  });
  
  if (!result.valid) {
    console.warn('[Phrase Buddy] State validation errors:', result.errors);
  }
  
  return result;
}

/**
 * Recover from GM storage errors by re-initializing
 * Useful if storage becomes temporarily unavailable
 * @returns {boolean} Whether recovery was successful
 */
function recoverFromStorageError() {
  try {
    // Check if GM storage functions are available
    if (typeof GM_setValue !== 'function' || typeof GM_getValue !== 'function') {
      throw new Error('GM storage functions not available');
    }
    
    // Test if GM storage is working
    const testKey = 'pb_storage_test';
    GM_setValue(testKey, true);
    const testValue = GM_getValue(testKey);
    
    // Try to delete test key if function is available
    if (typeof GM_deleteValue === 'function') {
      GM_deleteValue(testKey);
    }
    
    if (testValue !== true) {
      throw new Error('Storage test failed');
    }
    
    console.log('[Phrase Buddy] Storage recovery successful');
    return true;
  } catch (error) {
    console.error('[Phrase Buddy] Storage recovery failed:', error);
    return false;
  }
}

/**
 * Initialize state synchronization
 * Sets up cross-tab listening and validates existing state
 */
function initializeStateSynchronization() {
  // Validate all stored states
  const validation = validateAllStoredStates();
  
  if (!validation.valid) {
    console.warn('[Phrase Buddy] Some tool states were corrupted and have been repaired');
  }
  
  // Test storage availability
  const storageOk = recoverFromStorageError();
  if (!storageOk) {
    console.error('[Phrase Buddy] Warning: Storage may not be fully available');
  }
  
  // Install cross-tab sync listener
  installCrossTabSyncListener();
  
  console.log('[Phrase Buddy] State synchronization initialized');
}

/**
 * Get synchronization status (for debugging)
 * @returns {Object} Current sync status
 */
function getSyncStatus() {
  return {
    pendingChanges: Object.keys(PENDING_CHANGES),
    debounceDelay: SYNC_DEBOUNCE_DELAY,
  };
}

// Export public API
window.PB_StateSynchronizer = {
  initializeStateSynchronization,
  validateAllStoredStates,
  recoverFromStorageError,
  getSyncStatus,
};

/**
 * Module: ui-theme
 * Responsibility: Sample and apply Phrase UI colors and typography.
 *                 Samples Phrase's native accent color (Phrase Blue) and typography (font-family, size, weight, line-height).
 *                 Creates CSS variables for adaptive styling that responds to theme changes.
 *                 Applies sampled typography to internal typography variants (header, paragraph, tooltip).
 * Dependencies: None
 */

/**
 * Sample Phrase primary color from native UI elements.
 */
function samplePhrasePrimaryColor() {
  const norm = (s) => String(s || '').trim();

  // Try active tabs first (most reliable)
  try {
    const activeTab = document.querySelector('#right-panel-navigation-tabs .sidebar-tab.active');
    if (activeTab) {
      const cs = getComputedStyle(activeTab);
      const borderColor = norm(cs.borderLeftColor);
      
      if (borderColor && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)') {
        return borderColor;
      }
    }
  } catch (e) {
    // Silently fail over to fallback
  }

  // Fallback
  return '#0052CC';
}

/**
 * Set --pb-phrase-blue CSS variable from sampled Phrase color.
 * This makes Phrase Buddy's colors adapt to any Phrase theme changes.
 */
function refreshPhraseBlueVar() {
  try {
    const c = samplePhrasePrimaryColor();
    const prev = (getComputedStyle(document.documentElement).getPropertyValue('--pb-phrase-blue') || '').trim();
    const next = String(c || '').trim();
    if (next) document.documentElement.style.setProperty('--pb-phrase-blue', next);
    else if (!prev) document.documentElement.style.setProperty('--pb-phrase-blue', '#2F6FED');
  } catch (e) {
    try {
      const prev = (getComputedStyle(document.documentElement).getPropertyValue('--pb-phrase-blue') || '').trim();
      if (!prev) document.documentElement.style.setProperty('--pb-phrase-blue', '#2F6FED');
    } catch (e2) {}
  }
}

/**
 * Paint checkbox SVG paths with Phrase blue color.
 */
function paintCheckboxes() {
  const color = samplePhrasePrimaryColor();
  const checkboxPaths = document.querySelectorAll('.syn_checkbox-icon path');
  
  checkboxPaths.forEach((path) => {
    path.setAttribute('fill', color);
  });
}

/**
 * Sample Phrase's native label typography (font, size, weight, line-height).
 * Searches for visible Phrase labels outside of Buddy to avoid re-sampling our own overrides.
 * Returns typography properties from the first visible native label found.
 * @returns {Object|null} { fontFamily, fontSize, fontWeight, lineHeight, color } or null
 */
function samplePhraseLabelTypography() {
  const isInBuddy = (el) => {
    try {
      return !!(el?.closest?.('.pb-buddy-pane, .pb-beta-modal, .pb-beta-modal-overlay'));
    } catch (e) {
      return false;
    }
  };

  const isVisible = (el) => {
    try {
      if (!(el instanceof HTMLElement)) return false;
      const r = el.getBoundingClientRect();
      if (!r || r.width <= 0 || r.height <= 0) return false;
      const cs = getComputedStyle(el);
      if (!cs || cs.display === 'none' || cs.visibility === 'hidden' || cs.opacity === '0') return false;
      return true;
    } catch (e) {
      return false;
    }
  };

  const pick = (el) => {
    if (!el) return null;
    try {
      const cs = getComputedStyle(el);
      return {
        fontFamily: cs.fontFamily || '',
        fontSize: cs.fontSize || '',
        fontWeight: cs.fontWeight || '',
        lineHeight: cs.lineHeight || '',
        color: cs.color || '',
      };
    } catch (e) {
      return null;
    }
  };

  // Prefer Phrase-native labels that are NOT inside Buddy
  const nodes = Array.from(document.querySelectorAll('.syn_form-row__label'))
    .filter(el => el && !isInBuddy(el) && isVisible(el));

  // Heuristic: prefer labels in the right panel / cat panel
  const preferred = nodes.find(el => el.closest?.('#cat-panel-content, #right-panel-navigation-tabs')) || nodes[0] || null;

  const st = pick(preferred);
  if (st && (st.fontFamily || st.fontSize || st.fontWeight || st.lineHeight || st.color)) return st;

  return null;
}

/**
 * Apply sampled Phrase typography to Buddy CSS variables.
 * Creates three typography variants: header (bold), paragraph (regular), tooltip (small).
 * Called on initialization and when typography might change.
 */
function applyBuddyTypographyAuthority() {
  const st = samplePhraseLabelTypography();
  if (!st) return;

  const root = document.documentElement;

  // Base typography variables (from sampled native typography)
  if (st.fontFamily) root.style.setProperty('--pb-ui-font-family', st.fontFamily);
  if (st.fontSize) root.style.setProperty('--pb-ui-font-size', st.fontSize);
  if (st.fontWeight) root.style.setProperty('--pb-ui-font-weight', st.fontWeight);
  if (st.lineHeight) root.style.setProperty('--pb-ui-line-height', st.lineHeight);

  // Do not freeze color into CSS var; let Phrase control label color per theme.
  root.style.setProperty('--pb-ui-color', 'inherit');

  // Typography variants with deltas for differentiation
  // Header: bold version (9/700 = 1.2857x weight increase)
  root.style.setProperty('--pb-header-font-weight', '700');
  root.style.setProperty('--pb-header-line-height', 'normal');

  // Paragraph: regular version of base (use base variables directly via css classes)
  root.style.setProperty('--pb-paragraph-line-height', 'normal');

  // Tooltip: small version (smaller font, regular weight)
  // Extract numeric font size and reduce by ~20% (11px for 12px base, 12px for 14px base)
  let tooltipSize = st.fontSize || '12px';
  try {
    const sizeMatch = tooltipSize.match(/^(\d+(?:\.\d+)?)/);
    if (sizeMatch) {
      const baseSize = parseFloat(sizeMatch[1]);
      const smaller = Math.round(baseSize * 0.85);
      tooltipSize = `${smaller}px`;
    }
  } catch (e) {
    tooltipSize = '11px';
  }
  root.style.setProperty('--pb-tooltip-font-size', tooltipSize);
  root.style.setProperty('--pb-tooltip-font-weight', '400');
  root.style.setProperty('--pb-tooltip-line-height', '1.3');
}

// Export public API
window.PB_UITheme = {
  samplePhrasePrimaryColor,
  samplePhraseLabelTypography,
  refreshPhraseBlueVar,
  applyBuddyTypographyAuthority,
  paintCheckboxes,
};

/**
 * Module: tooltip-manager
 * Responsibility: Manage global tooltip lifecycle and display.
 *                 Creates, positions, and removes tooltips using Phrase's native syn_tooltip class.
 *                 Tracks "warm" state for UX optimization (faster re-show on rapid interactions).
 *                 Provides helpers for wiring tooltips to any UI element.
 * Dependencies: None
 */

/**
 * Tooltip configuration constants matching old code.
 */
const TOOLTIP_CONFIG = {
  DELAY_MS: 650,           // Initial hover delay before showing tooltip
  MAX_WIDTH_PX: 350,       // Maximum tooltip width
  X_OFFSET: 12,            // Horizontal offset from anchor element
  Y_OFFSET: 0,             // Vertical offset from anchor element
  WARM_MS: 1600,           // Duration of "warm" state (faster re-show)
};

/**
 * Global tooltip state (only one tooltip visible at a time).
 */
let tooltipTimer = null;          // setTimeout ID for delayed show
let tooltipWrapper = null;        // Container div for the tooltip
let tooltipId = null;             // Unique ID for tooltip element
let tooltipAnchorEl = null;       // Element the tooltip is anchored to
let tooltipWarmUntil = 0;         // Timestamp when "warm" state expires

/**
 * Mark tooltip state as "warm" for 1600ms.
 * Used to provide faster re-show on rapid hover interactions.
 */
function markTooltipWarm() {
  tooltipWarmUntil = Date.now() + TOOLTIP_CONFIG.WARM_MS;
}

/**
 * Check if tooltip is in "warm" state.
 * Returns true if warm timer still active OR any tooltip currently visible.
 */
function isTooltipWarm() {
  return Date.now() < tooltipWarmUntil || !!document.querySelector('.syn_tooltip');
}

/**
 * Cancel any pending tooltip show timer.
 */
function clearTooltipTimer() {
  if (tooltipTimer) {
    clearTimeout(tooltipTimer);
    tooltipTimer = null;
  }
}

/**
 * Create a new tooltip DOM node using Phrase's native tooltip class.
 * @param {string} text - The tooltip text to display
 * @returns {Object} { outer, tip, id } - Wrapper div, tooltip div, and unique ID
 */
function createTooltipNode(text) {
  const outer = document.createElement('div');
  const tip = document.createElement('div');
  
  outer.style.pointerEvents = 'none';
  tip.style.pointerEvents = 'none';

  // Generate unique ID for accessibility
  tooltipId = `syn_tooltip-component-v-buddy-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

  // Use Phrase's native tooltip class for automatic theme support
  tip.setAttribute('role', 'tooltip');
  tip.id = tooltipId;
  tip.className = 'syn_tooltip';
  tip.setAttribute('data-testid', 'tooltip-content');

  // Position: fixed to prevent layout shifts
  tip.style.position = 'fixed';
  tip.style.left = '0px';
  tip.style.top = '0px';
  tip.style.zIndex = '2147483000';
  tip.style.maxWidth = `${TOOLTIP_CONFIG.MAX_WIDTH_PX}px`;
  tip.style.maxHeight = `${Math.max(200, window.innerHeight - 50)}px`;

  // Content structure (matches Phrase's native tooltip markup)
  const textWrap = document.createElement('div');
  textWrap.className = 'syn_tooltip_text syn_tooltip_text--unlimited';

  const inner = document.createElement('div');
  inner.textContent = text;

  textWrap.appendChild(inner);
  tip.appendChild(textWrap);
  outer.appendChild(tip);

  return { outer, tip, id: tooltipId };
}

/**
 * Position a tooltip relative to its anchor element.
 * Default: right of anchor, vertically centered.
 * Flips to left if would go off-screen.
 * @param {HTMLElement} tipEl - The tooltip element to position
 * @param {HTMLElement} anchorBtn - The element the tooltip is anchored to
 */
function positionTooltip(tipEl, anchorBtn) {
  const r = anchorBtn.getBoundingClientRect();
  const tipRect = tipEl.getBoundingClientRect();
  const tipH = tipRect.height || 24;

  // Default: position to the right of anchor, vertically centered
  let x = r.right + TOOLTIP_CONFIG.X_OFFSET;
  let y = (r.top + (r.height / 2) - (tipH / 2)) + TOOLTIP_CONFIG.Y_OFFSET;

  const padding = 8;
  const maxX = window.innerWidth - padding;
  const maxY = window.innerHeight - padding;

  const tipW = tipRect.width || 180;

  // Flip to left if tooltip would go off-screen right
  if (x + tipW > maxX) x = Math.max(padding, r.left - tipW - TOOLTIP_CONFIG.X_OFFSET);

  // Clamp vertical position to viewport
  y = Math.max(padding, Math.min(y, maxY - tipH));

  // Use transform for better performance than left/top
  tipEl.style.transform = `translate(${x}px, ${y}px)`;
}

/**
 * Remove the currently displayed tooltip.
 */
function removeTooltip() {
  clearTooltipTimer();

  // Clean up accessibility attributes
  if (tooltipAnchorEl && tooltipId && tooltipAnchorEl.getAttribute('aria-describedby') === tooltipId) {
    tooltipAnchorEl.removeAttribute('aria-describedby');
  }

  // Remove from DOM
  if (tooltipWrapper && tooltipWrapper.isConnected) tooltipWrapper.remove();

  // Clear state
  tooltipWrapper = null;
  tooltipId = null;
  tooltipAnchorEl = null;
}

/**
 * Show tooltip immediately without delay.
 * Used for action feedback (e.g., "Copied to clipboard").
 * @param {HTMLElement} anchorBtn - The element to anchor the tooltip to
 * @param {string} text - The tooltip text
 */
function showTooltipImmediate(anchorBtn, text) {
  clearTooltipTimer();
  if (!anchorBtn || !anchorBtn.isConnected) return;

  removeTooltip();

  const { outer, tip, id } = createTooltipNode(text);
  tooltipWrapper = outer;
  tooltipAnchorEl = anchorBtn;

  document.body.appendChild(outer);
  anchorBtn.setAttribute('aria-describedby', id);

  positionTooltip(tip, anchorBtn);
  markTooltipWarm();

  // Re-position after first layout (in case content changed DOM)
  requestAnimationFrame(() => {
    if (tip.isConnected && anchorBtn.isConnected) positionTooltip(tip, anchorBtn);
  });
}

/**
 * Show tooltip with delay, respecting "warm" state.
 * If tooltip was recently shown, delay is 0ms (immediate).
 * Otherwise, delay is 650ms (standard UX pattern).
 * @param {HTMLElement} anchorBtn - The element to anchor the tooltip to
 * @param {string} text - The tooltip text
 */
function scheduleTooltip(anchorBtn, text) {
  clearTooltipTimer();

  // If tooltip was recently shown, don't delay (warm state)
  const delay = isTooltipWarm() ? 0 : TOOLTIP_CONFIG.DELAY_MS;

  const show = () => {
    if (!anchorBtn || !anchorBtn.isConnected) return;

    removeTooltip();

    const { outer, tip, id } = createTooltipNode(text);
    tooltipWrapper = outer;
    tooltipAnchorEl = anchorBtn;

    document.body.appendChild(outer);
    anchorBtn.setAttribute('aria-describedby', id);

    positionTooltip(tip, anchorBtn);
    markTooltipWarm();

    requestAnimationFrame(() => {
      if (tip.isConnected && anchorBtn.isConnected) positionTooltip(tip, anchorBtn);
    });
  };

  if (delay === 0) requestAnimationFrame(show);
  else tooltipTimer = setTimeout(show, delay);
}

/**
 * Wire tooltip behavior to an element (show on hover/focus).
 * Shows tooltip on pointerenter/focus with 650ms delay.
 * Hides tooltip on pointerleave/blur/scroll/resize.
 * @param {HTMLElement} element - The element to wire tooltips to
 * @param {string} text - The tooltip text to display
 */
function wireTooltip(element, text) {
  if (!element || element.dataset.pbTooltipWired === '1') return;
  element.dataset.pbTooltipWired = '1';

  const btn = element.querySelector('button') || element;
  if (!btn) return;

  const onEnter = () => scheduleTooltip(btn, text);
  const onLeave = () => removeTooltip();

  // Show tooltip on hover
  element.addEventListener('pointerenter', onEnter, { passive: true });
  element.addEventListener('pointerleave', onLeave, { passive: true });

  // Show tooltip on keyboard focus
  btn.addEventListener('focus', onEnter, { passive: true });
  btn.addEventListener('blur', onLeave, { passive: true });

  // Hide tooltip if page scrolls or resizes
  window.addEventListener('scroll', onLeave, { passive: true });
  window.addEventListener('resize', onLeave, { passive: true });
}

// Export public API
window.PB_TooltipManager = {
  show: showTooltipImmediate,
  schedule: scheduleTooltip,
  remove: removeTooltip,
  wire: wireTooltip,
  markWarm: markTooltipWarm,
};

/**
 * Module: tab-integration
 * Responsibility: Creates and manages the Buddy tab button in Phrase's left-hand menu.
 *                 Handles DOM cloning of Phrase tab elements to maintain consistent styling.
 *                 Inserts the Buddy tab below the last native tab button while managing
 *                 insertion position relative to the toggle-side-panel control.
 * Dependencies: icon-manager (setBuddyIcon), ui-state (setBuddyTabActiveVisual)
 */

// Constants for element IDs and selectors
const TAB_ID = 'phrase-buddy-tab';
const PANE_ID = 'phrase-buddy-pane';

/**
 * Finds the container holding all sidebar tab buttons.
 * @returns {HTMLElement|null} The tabs container or null if not found.
 */
function findTabsContainer() {
  // Try the specific path first
  let container = document.querySelector('#right-panel-navigation-tabs .sidebar-tabs-container');
  if (container) return container;

  // Try the navigation tabs element itself
  container = document.querySelector('#right-panel-navigation-tabs');
  if (container) {
    const tabs = container.querySelector('.sidebar-tabs-container');
    if (tabs) return tabs;
    // If no inner container, the navigation-tabs itself might be the container
    if (container.querySelector('.sidebar-tab')) return container;
  }

  // Try generic class patterns
  container = document.querySelector('.sidebar-tabs-container');
  if (container) return container;

  // Look for a container with sidebar-tab children
  const firstTab = document.querySelector('.sidebar-tab');
  if (firstTab && firstTab.parentElement) {
    return firstTab.parentElement;
  }

  return null;
}

/**
 * Finds the CAT pane element to use as a template for cloning.
 * @returns {HTMLElement|null} The CAT pane element or null if not found.
 */
function findCatPane() {
  return document.querySelector('#right-panel-navigation-tabs #cat-tab-pane') ||
         document.querySelector('#cat-tab-pane') ||
         document.querySelector('.tab-pane[id*="cat"]');
}

/**
 * Finds the Search pane element as an alternative template for cloning.
 * @returns {HTMLElement|null} The Search pane element or null if not found.
 */
function findSearchPane() {
  return document.querySelector('#right-panel-navigation-tabs #search-tab-pane') ||
         document.querySelector('#search-tab-pane') ||
         document.querySelector('.tab-pane[id*="search"]');
}

/**
 * Finds the panes container (parent of all tab panes).
 * @returns {HTMLElement|null} The panes container or null if not found.
 */
function findPanesContainer() {
  // Try direct ID first
  let container = document.querySelector('#right-panel-navigation-panes');
  if (container) return container;

  // Try common class patterns
  container = document.querySelector('.tab-panes-container');
  if (container) return container;

  container = document.querySelector('[class*="tab-panes"]');
  if (container) return container;

  // Try finding parent that contains .tab-pane elements
  const firstPane = document.querySelector('.tab-pane');
  if (firstPane && firstPane.parentElement) {
    return firstPane.parentElement;
  }

  // Last resort: try siblings of tabs container
  const tabsContainer = findTabsContainer();
  if (tabsContainer && tabsContainer.parentElement) {
    const siblings = tabsContainer.parentElement.querySelectorAll('[class*="pane"]');
    if (siblings.length > 0) {
      return siblings[0].parentElement;
    }
  }

  return null;
}

/**
 * Creates or retrieves the Buddy tab button element.
 * Clones an existing tab to preserve Phrase styling and structure.
 * @param {HTMLElement} tabsContainer - The container where tabs are inserted.
 * @returns {HTMLElement|null} The Buddy tab element or null if cloning failed.
 */
function ensureBuddyTab(tabsContainer) {
  let tab = document.getElementById(TAB_ID);
  if (tab && tab.isConnected) return tab;

  // Find a template tab to clone (preserves all Phrase styling and structure)
  const template =
    document.querySelector('#right-panel-navigation-tabs #search-tab') ||
    document.querySelector('#right-panel-navigation-tabs #qa-tab') ||
    document.querySelector('#right-panel-navigation-tabs .sidebar-tab') ||
    document.querySelector('.sidebar-tab');

  if (!template) return null;

  // Clone the template and set up the Buddy tab structure
  tab = template.cloneNode(true);
  tab.id = TAB_ID;
  tab.classList.remove('active');

  const btn = tab.querySelector('button');
  if (btn) {
    btn.setAttribute('aria-label', 'Phrase Buddy');
    btn.removeAttribute('data-active');
    btn.classList.remove('syn_btn--invisible--active');
  }

  // Icon will be set by icon-manager.setBuddyIcon()
  // Insert tab before toggle-side-panel if it exists, otherwise append
  const toggleTab = document.querySelector('#right-panel-navigation-tabs #toggle-side-panel');
  if (toggleTab && toggleTab.parentElement === tabsContainer) {
    tabsContainer.insertBefore(tab, toggleTab);
  } else {
    tabsContainer.appendChild(tab);
  }

  return tab;
}

/**
 * Creates or retrieves the Buddy pane (content container) element.
 * Clones an existing pane to preserve Phrase styling and structure.
 * @param {HTMLElement} panesContainer - The container where panes are inserted.
 * @returns {HTMLElement|null} The Buddy pane element or null if cloning failed.
 */
function ensureBuddyPane(panesContainer) {
  let pane = document.getElementById(PANE_ID);
  if (pane && pane.isConnected) return pane;

  // Find a source pane to clone
  const sourcePane = findCatPane() || findSearchPane();
  if (!sourcePane) return null;

  pane = sourcePane.cloneNode(true);
  pane.id = PANE_ID;
  pane.classList.add('pb-buddy-pane');
  pane.style.display = 'none';

  // Update pane header if present
  const header = pane.querySelector('.side-panel-header');
  const titleEl = header?.querySelector('.side-panel-header--title') ||
                  header?.querySelector('[class*="header--title"]') ||
                  header?.querySelector('h1, h2, h3, span');
  if (titleEl) titleEl.textContent = 'Phrase Buddy';

  // Clear any right-side header content (settings, close buttons, etc.)
  const rightSide =
    pane.querySelector('.side-panel-header--right') ||
    pane.querySelector('[class*="header--right"]');
  if (rightSide) rightSide.innerHTML = '';

  // Ensure body wrapper exists and is visible
  let bodyWrapper = header ? header.nextElementSibling : null;
  if (!bodyWrapper) {
    bodyWrapper =
      pane.querySelector('.tab-pane-content') ||
      pane.querySelector('.side-panel-content') ||
      pane.querySelector('[class*="side-panel-content"]') ||
      pane;
  }

  bodyWrapper.style.display = bodyWrapper.style.display || 'block';
  bodyWrapper.style.minHeight = bodyWrapper.style.minHeight || '0';

  panesContainer.appendChild(pane);
  return pane;
}

/**
 * Hides all native panes and stores their previous display values.
 * Allows restoration when Buddy closes.
 * @param {HTMLElement} panesContainer - The container with all panes.
 * @param {HTMLElement} buddyPaneEl - The Buddy pane (should remain visible).
 */
function snapshotAndHideNativePanes(panesContainer, buddyPaneEl) {
  if (!panesContainer) return;

  const panes = Array.from(panesContainer.querySelectorAll('.tab-pane')).filter(
    p => p !== buddyPaneEl && p.id !== PANE_ID
  );

  // Store original display values so we can restore them later
  window.PB_NATIVE_PANES_SNAPSHOT = new Map();
  panes.forEach(p => {
    window.PB_NATIVE_PANES_SNAPSHOT.set(p, p.style.display);
    p.style.display = 'none';
  });
}

/**
 * Restores all native panes to their original display state.
 */
function restoreNativePanes() {
  const snapshot = window.PB_NATIVE_PANES_SNAPSHOT;
  if (!snapshot) return;

  for (const [pane, prevDisplay] of snapshot.entries()) {
    if (!pane || !pane.isConnected) continue;
    pane.style.display = prevDisplay || '';
  }

  window.PB_NATIVE_PANES_SNAPSHOT = null;
}

// Export public API
window.PB_TabIntegration = {
  findTabsContainer,
  findCatPane,
  findSearchPane,
  findPanesContainer,
  ensureBuddyTab,
  ensureBuddyPane,
  snapshotAndHideNativePanes,
  restoreNativePanes,
  TAB_ID,
  PANE_ID,
};

/**
 * Module: icon-manager
 * Responsibility: Manages the smiley icon for the Buddy tab. Handles icon rendering,
 *                 dynamic color updates based on Phrase's native tab icon colors
 *                 (active vs. inactive states), and color synchronization to match
 *                 the host's visual theme.
 * Dependencies: None
 */

// Cached color values sampled from Phrase's native tab icons
const phraseIconColors = {
  active: '#0052CC',   // Phrase blue (default)
  inactive: '#666666', // Phrase gray (default)
};

/**
 * Smiley face SVG path data (Font Awesome smiley icon).
 * Simple, clean icon that works well at small sizes.
 */
const SMILEY_SVG_VIEWBOX = '0 0 640 640';
const SMILEY_SVG_PATH = `
  <path d="M528 320C528 205.1 434.9 112 320 112C205.1 112 112 205.1 112 320C112 434.9 205.1 528 320 528C434.9 528 528 434.9 528 320zM64 320C64 178.6 178.6 64 320 64C461.4 64 576 178.6 576 320C576 461.4 461.4 576 320 576C178.6 576 64 461.4 64 320zM241.3 383.4C256.3 399 282.4 416 320 416C357.6 416 383.7 399 398.7 383.4C407.9 373.8 423.1 373.5 432.6 382.7C442.1 391.9 442.5 407.1 433.3 416.6C411.2 439.6 373.3 464 320 464C266.7 464 228.8 439.6 206.7 416.6C197.5 407 197.8 391.8 207.4 382.7C217 373.6 232.2 373.8 241.3 383.4zM240 244C224.5 244 212 256.5 212 272L212 280C212 291 203 300 192 300C181 300 172 291 172 280L172 272C172 234.4 202.4 204 240 204C277.6 204 308 234.4 308 272L308 280C308 291 299 300 288 300C277 300 268 291 268 280L268 272C268 256.5 255.5 244 240 244zM372 272L372 280C372 291 363 300 352 300C341 300 332 291 332 280L332 272C332 234.4 362.4 204 400 204C437.6 204 468 234.4 468 272L468 280C468 291 459 300 448 300C437 300 428 291 428 280L428 272C428 256.5 415.5 244 400 244C384.5 244 372 256.5 372 272z"/>
`;

/**
 * Checks if a native tab button is currently in pressed (:active) state.
 * Used to avoid sampling colors during transient press states.
 * @param {HTMLElement} tabsContainer - The tabs container to check.
 * @returns {boolean} True if any native tab button is pressed.
 */
function pbTabs_hasPressedNativeTab(tabsContainer) {
  try {
    const root = tabsContainer || document;
    const pressedBtn = root.querySelector?.(
      '#right-panel-navigation-tabs .sidebar-tab button:active, .sidebar-tab button:active'
    );
    return !!pressedBtn;
  } catch (e) {
    return false;
  }
}

/**
 * Samples the actual computed fill color from inactive Phrase tabs.
 * Used to determine what color inactive Buddy icon should be.
 * @param {HTMLElement} tabsContainer - The tabs container to sample from.
 * @returns {string|null} The CSS fill color or null if not found.
 */
function getInactiveIconFill(tabsContainer) {
  if (!tabsContainer) return null;

  // Avoid sampling during a pressed state (transient visual artifacts)
  if (pbTabs_hasPressedNativeTab(tabsContainer)) {
    return phraseIconColors.inactive || null;
  }

  // Look for SVG elements in inactive tabs
  const candidates = [
    ...tabsContainer.querySelectorAll('.sidebar-tab:not(.active) svg path'),
    ...tabsContainer.querySelectorAll('.sidebar-tab:not(.active) svg'),
  ];

  let refEl = null;
  for (const el of candidates) {
    if (!el) continue;
    try {
      const btn = el.closest?.('button');
      if (btn && btn.matches?.(':active')) continue;
      refEl = el;
      break;
    } catch (e) {}
  }

  if (!refEl) return phraseIconColors.inactive || null;

  const cs = window.getComputedStyle(refEl);
  return cs && cs.fill && cs.fill !== 'none' ? cs.fill : (phraseIconColors.inactive || null);
}

/**
 * Gets the actual computed fill color from active Phrase tabs.
 * Used to determine what color active Buddy icon should be.
 * @param {HTMLElement} tabsContainer - The tabs container to sample from.
 * @param {string} buddyTabId - The Buddy tab ID to exclude from sampling.
 * @returns {string|null} The CSS fill color or null if not found.
 */
function getActiveIconFill(tabsContainer, buddyTabId) {
  if (!tabsContainer) return null;

  if (pbTabs_hasPressedNativeTab(tabsContainer)) {
    return phraseIconColors.active || null;
  }

  const candidates = [
    ...tabsContainer.querySelectorAll(`.sidebar-tab.active:not(#${buddyTabId}) svg path`),
    ...tabsContainer.querySelectorAll(`.sidebar-tab.active:not(#${buddyTabId}) svg`),
  ];

  let refEl = null;
  for (const el of candidates) {
    if (!el) continue;
    try {
      const btn = el.closest?.('button');
      if (btn && btn.matches?.(':active')) continue;
      refEl = el;
      break;
    } catch (e) {}
  }

  if (!refEl) return phraseIconColors.active || null;

  const cs = window.getComputedStyle(refEl);
  return cs && cs.fill && cs.fill !== 'none' ? cs.fill : (phraseIconColors.active || null);
}

/**
 * Updates the cached phrase icon colors by sampling from native tabs.
 * Called periodically or when theme changes to keep colors in sync.
 * @param {HTMLElement} tabsContainer - The tabs container to sample from.
 * @param {string} buddyTabId - The Buddy tab ID to exclude from sampling.
 */
function updatePhraseIconColors(tabsContainer, buddyTabId) {
  if (!tabsContainer) return;

  if (pbTabs_hasPressedNativeTab(tabsContainer)) return;

  const inactiveFill = getInactiveIconFill(tabsContainer);
  if (inactiveFill && inactiveFill !== 'none') {
    phraseIconColors.inactive = inactiveFill;
  }

  // Only sample active color if Buddy pane is not open
  if (document.documentElement.classList.contains('pb-buddy-open')) return;

  const activeFill = getActiveIconFill(tabsContainer, buddyTabId);
  if (activeFill && activeFill !== 'none') {
    phraseIconColors.active = activeFill;
  }
}

/**
 * Renders the smiley icon SVG into a tab button.
 * Replaces any existing SVG with the Buddy smiley.
 * @param {HTMLElement} tabEl - The tab element containing a button.
 */
function setBuddyIcon(tabEl) {
  const btn = tabEl?.querySelector('button');
  const svg = btn?.querySelector('svg');
  if (!svg) return;

  svg.setAttribute('viewBox', SMILEY_SVG_VIEWBOX);
  svg.innerHTML = SMILEY_SVG_PATH;
}

/**
 * Applies dynamic color to all SVG elements in the Buddy icon.
 * Paints active color if isActive is true, inactive color otherwise.
 * @param {HTMLElement} tabEl - The tab element containing the icon.
 * @param {boolean} isActive - Whether the tab is in active state.
 */
function paintBuddyIcon(tabEl, isActive) {
  const btn = tabEl?.querySelector('button');
  const svg = btn?.querySelector('svg');
  if (!svg) return;

  const target = isActive ? phraseIconColors.active : phraseIconColors.inactive;
  if (!target) return;

  // Paint the main SVG element
  svg.style.setProperty('fill', target, 'important');
  svg.style.setProperty('color', target, 'important');
  svg.style.setProperty('stroke', target, 'important');

  // Paint all child SVG elements (paths, groups, circles, etc.)
  const children = svg.querySelectorAll('path, g, circle, rect, polygon, polyline, line, use');
  children.forEach(el => {
    el.style.setProperty('fill', target, 'important');
    el.style.setProperty('color', target, 'important');
    el.style.setProperty('stroke', target, 'important');
  });
}

/**
 * Initializes icon color sampling and applies initial colors.
 * Call this once at startup.
 * @param {HTMLElement} tabEl - The Buddy tab element.
 * @param {HTMLElement} tabsContainer - The tabs container for sampling.
 * @param {string} buddyTabId - The Buddy tab ID.
 */
function initializeIconColors(tabEl, tabsContainer, buddyTabId) {
  updatePhraseIconColors(tabsContainer, buddyTabId);
  paintBuddyIcon(tabEl, false); // Initially inactive
}

// Export public API
window.PB_IconManager = {
  updatePhraseIconColors,
  getInactiveIconFill,
  getActiveIconFill,
  setBuddyIcon,
  paintBuddyIcon,
  initializeIconColors,
  phraseIconColors,
};

/**
 * Module: ui-state
 * Responsibility: Manages the visual and functional state of the Buddy tab and its pane.
 *                 Handles active/inactive styling, native tab suppression when Buddy is open,
 *                 and restoration of native UI when Buddy closes. Maintains snapshot state
 *                 to cleanly restore previous tab selections.
 * Dependencies: icon-manager (paintBuddyIcon)
 */

// State tracking
let buddyOpen = false;
let nativeActiveTabSnapshot = null;
let nativeActiveSuppression = null;

const CSS = {
  HTML_OPEN_CLASS: 'pb-buddy-open',
};

/**
 * Takes a snapshot of the currently active native tab's visual state.
 * Used to restore it exactly when Buddy closes.
 * @param {HTMLElement} tabsContainer - The tabs container.
 * @param {string} buddyTabId - The Buddy tab ID to exclude from the query.
 */
function snapshotAndNeutralizeNativeActiveTab(tabsContainer, buddyTabId) {
  if (!tabsContainer) return;

  // Find the currently active native tab (not the Buddy tab)
  const activeNativeTab = tabsContainer.querySelector(
    `.sidebar-tab.active:not(#${buddyTabId})`
  );
  if (!activeNativeTab) return;

  // If we already snapped this exact tab and it's still in the DOM, do nothing
  if (nativeActiveTabSnapshot && 
      nativeActiveTabSnapshot.tabEl === activeNativeTab && 
      activeNativeTab.isConnected) {
    return;
  }

  // Always restore prior snapshot before taking a new one
  restoreNativeActiveTabState();

  const btn = activeNativeTab.querySelector('button');

  // Capture the current state
  nativeActiveTabSnapshot = {
    tabEl: activeNativeTab,
    hadActiveClass: activeNativeTab.classList.contains('active'),
    btnHadDataActive: btn ? btn.hasAttribute('data-active') : false,
    btnDataActiveVal: btn ? btn.getAttribute('data-active') : null,
    btnHadActiveClass: btn ? btn.classList.contains('syn_btn--invisible--active') : false,
    ariaSelected: activeNativeTab.getAttribute('aria-selected'),
  };

  // Neutralize the native tab's visual active state
  activeNativeTab.classList.remove('active');
  if (btn) {
    btn.removeAttribute('data-active');
    btn.classList.remove('syn_btn--invisible--active');
  }
  try {
    activeNativeTab.setAttribute('aria-selected', 'false');
  } catch (e) {}
}

/**
 * Restores the previously snapped native tab to its original state.
 */
function restoreNativeActiveTabState() {
  if (!nativeActiveTabSnapshot) return;

  const s = nativeActiveTabSnapshot;
  nativeActiveTabSnapshot = null;

  const tabEl = s.tabEl;
  if (!tabEl || !tabEl.isConnected) return;

  const btn = tabEl.querySelector('button');

  // Restore class
  if (s.hadActiveClass) {
    tabEl.classList.add('active');
  }

  // Restore button state
  if (btn) {
    if (s.btnHadDataActive) {
      btn.setAttribute('data-active', s.btnDataActiveVal !== null ? s.btnDataActiveVal : 'true');
    } else {
      btn.removeAttribute('data-active');
    }

    if (s.btnHadActiveClass) {
      btn.classList.add('syn_btn--invisible--active');
    } else {
      btn.classList.remove('syn_btn--invisible--active');
    }
  }

  // Restore aria-selected
  try {
    if (s.ariaSelected !== null && s.ariaSelected !== undefined) {
      tabEl.setAttribute('aria-selected', s.ariaSelected);
    } else {
      tabEl.removeAttribute('aria-selected');
    }
  } catch (e) {}
}

/**
 * Suppresses the visual appearance of the active native tab's icon.
 * Makes it appear as if no native tab is active while Buddy is open.
 * @param {HTMLElement} tabsContainer - The tabs container.
 * @param {string} buddyTabId - The Buddy tab ID to exclude.
 */
function suppressNativeActiveVisuals(tabsContainer, buddyTabId) {
  if (!tabsContainer) return;

  const activeNativeTab = tabsContainer.querySelector(
    `.sidebar-tab.active:not(#${buddyTabId})`
  );
  if (!activeNativeTab) return;

  const btn = activeNativeTab.querySelector('button');
  if (!btn) return;

  const svg = btn.querySelector('svg');
  if (!svg) return;

  // Get the inactive color to paint the icon with
  const inactiveFill = window.PB_IconManager?.phraseIconColors?.inactive ||
                       window.PB_IconManager?.getInactiveIconFill(tabsContainer) ||
                       '#666666';

  if (!inactiveFill) return;

  // If we already suppressed this exact SVG, do nothing
  if (nativeActiveSuppression && 
      nativeActiveSuppression.svg === svg && 
      svg.isConnected) {
    return;
  }

  // Restore any prior suppression
  restoreNativeActiveVisuals();

  // Capture current styles so we can restore them exactly
  const paths = Array.from(svg.querySelectorAll(
    'path, g, circle, rect, polygon, polyline, line, use'
  ));

  nativeActiveSuppression = {
    svg,
    prevSvgFill: svg.style.getPropertyValue('fill'),
    prevSvgFillPrio: svg.style.getPropertyPriority('fill'),
    prevSvgColor: svg.style.getPropertyValue('color'),
    prevSvgColorPrio: svg.style.getPropertyPriority('color'),
    paths: paths.map(el => ({
      el,
      prevFill: el.style.getPropertyValue('fill'),
      prevFillPrio: el.style.getPropertyPriority('fill'),
      prevColor: el.style.getPropertyValue('color'),
      prevColorPrio: el.style.getPropertyPriority('color'),
    })),
  };

  // Paint the icon with inactive color
  svg.style.setProperty('fill', inactiveFill, 'important');
  svg.style.setProperty('color', inactiveFill, 'important');

  paths.forEach(el => {
    el.style.setProperty('fill', inactiveFill, 'important');
    el.style.setProperty('color', inactiveFill, 'important');
  });
}

/**
 * Restores the previously suppressed native tab icon to its original styles.
 */
function restoreNativeActiveVisuals() {
  if (!nativeActiveSuppression) return;

  const s = nativeActiveSuppression;
  nativeActiveSuppression = null;

  const svg = s.svg;
  if (svg && svg.isConnected) {
    if (s.prevSvgFill) {
      svg.style.setProperty('fill', s.prevSvgFill, s.prevSvgFillPrio || '');
    } else {
      svg.style.removeProperty('fill');
    }

    if (s.prevSvgColor) {
      svg.style.setProperty('color', s.prevSvgColor, s.prevSvgColorPrio || '');
    } else {
      svg.style.removeProperty('color');
    }
  }

  // Restore all path elements
  for (const p of s.paths) {
    const el = p.el;
    if (!el || !el.isConnected) continue;

    if (p.prevFill) {
      el.style.setProperty('fill', p.prevFill, p.prevFillPrio || '');
    } else {
      el.style.removeProperty('fill');
    }

    if (p.prevColor) {
      el.style.setProperty('color', p.prevColor, p.prevColorPrio || '');
    } else {
      el.style.removeProperty('color');
    }
  }
}

/**
 * Sets the Buddy tab's visual active state (adds/removes active class and styling).
 * @param {HTMLElement} tabEl - The Buddy tab element.
 * @param {boolean} isActive - True to mark as active, false otherwise.
 */
function setBuddyTabActiveVisual(tabEl, isActive) {
  if (!tabEl) return;

  const btn = tabEl.querySelector('button');

  if (isActive) {
    tabEl.classList.add('active');
    if (btn) {
      btn.setAttribute('data-active', 'true');
      btn.classList.add('syn_btn--invisible--active');
      btn.setAttribute('aria-selected', 'true');
    }
  } else {
    tabEl.classList.remove('active');
    if (btn) {
      btn.removeAttribute('data-active');
      btn.classList.remove('syn_btn--invisible--active');
      btn.setAttribute('aria-selected', 'false');
    }
  }

  // Paint the icon with the appropriate color
  if (window.PB_IconManager?.paintBuddyIcon) {
    window.PB_IconManager.paintBuddyIcon(tabEl, isActive);
  }
}

/**
 * Applies UI mode changes when Buddy opens (disables Phrase's native UI visibility).
 * @param {boolean} isOpen - True when opening, false when closing.
 */
function setBuddyOpenUiMode(isOpen) {
  const html = document.documentElement;
  if (isOpen) {
    html.classList.add(CSS.HTML_OPEN_CLASS);
  } else {
    html.classList.remove(CSS.HTML_OPEN_CLASS);
  }
}

/**
 * Opens the Buddy tab and hides all native tabs/panes.
 * @param {HTMLElement} tabEl - The Buddy tab element.
 * @param {HTMLElement} buddyPaneEl - The Buddy pane element.
 * @param {HTMLElement} panesContainer - The panes container.
 * @param {HTMLElement} tabsContainer - The tabs container.
 */
function openBuddy(tabEl, buddyPaneEl, panesContainer, tabsContainer) {
  if (buddyOpen) return;
  buddyOpen = true;

  setBuddyOpenUiMode(true);

  // Update icon colors to match current theme
  if (window.PB_IconManager?.updatePhraseIconColors) {
    window.PB_IconManager.updatePhraseIconColors(tabsContainer, tabEl.id);
  }

  // Neutralize the last active native tab
  snapshotAndNeutralizeNativeActiveTab(tabsContainer, tabEl.id);

  // Make the native active tab's icon appear inactive
  suppressNativeActiveVisuals(tabsContainer, tabEl.id);

  // Hide all native panes
  if (window.PB_TabIntegration?.snapshotAndHideNativePanes) {
    window.PB_TabIntegration.snapshotAndHideNativePanes(panesContainer, buddyPaneEl);
  }

  // Show Buddy pane and mark Buddy tab as active
  if (buddyPaneEl) buddyPaneEl.style.display = '';
  setBuddyTabActiveVisual(tabEl, true);
}

/**
 * Closes the Buddy tab and restores all native tabs/panes.
 * @param {HTMLElement} tabEl - The Buddy tab element.
 * @param {HTMLElement} buddyPaneEl - The Buddy pane element.
 */
function closeBuddy(tabEl, buddyPaneEl) {
  setBuddyOpenUiMode(false);
  restoreNativeActiveVisuals();
  restoreNativeActiveTabState();

  if (buddyPaneEl) buddyPaneEl.style.display = 'none';
  setBuddyTabActiveVisual(tabEl, false);

  if (window.PB_TabIntegration?.restoreNativePanes) {
    window.PB_TabIntegration.restoreNativePanes();
  }

  buddyOpen = false;
}

/**
 * Toggles the Buddy tab open/closed state.
 * @param {HTMLElement} tabEl - The Buddy tab element.
 * @param {HTMLElement} buddyPaneEl - The Buddy pane element.
 * @param {HTMLElement} panesContainer - The panes container.
 * @param {HTMLElement} tabsContainer - The tabs container.
 */
function toggleBuddy(tabEl, buddyPaneEl, panesContainer, tabsContainer) {
  if (buddyOpen) {
    closeBuddy(tabEl, buddyPaneEl);
  } else {
    openBuddy(tabEl, buddyPaneEl, panesContainer, tabsContainer);
  }
}

/**
 * Returns the current open state.
 * @returns {boolean} True if Buddy is open.
 */
function isBuddyOpen() {
  return buddyOpen;
}

// Export public API
window.PB_UiState = {
  snapshotAndNeutralizeNativeActiveTab,
  restoreNativeActiveTabState,
  suppressNativeActiveVisuals,
  restoreNativeActiveVisuals,
  setBuddyTabActiveVisual,
  setBuddyOpenUiMode,
  openBuddy,
  closeBuddy,
  toggleBuddy,
  isBuddyOpen,
  CSS,
};

/**
 * Module: styles
 * Responsibility: Injects CSS styling for the Buddy pane, tabs, layout, and typography variants.
 *                 Defines header, paragraph, and tooltip typography classes.
 *                 Provides consistent styling for Tag Viewer, Character Detector, and Settings tabs.
 *                 Applies sampled Phrase typography to internal UI elements.
 * Dependencies: None
 */

/**
 * Injects CSS styles for the Buddy module host and internal tabs.
 */
function injectStyles() {
  const styleId = 'pb-buddy-styles';
  
  // Avoid injecting twice
  if (document.getElementById(styleId)) {
    return;
  }

  const style = document.createElement('style');
  style.id = styleId;
  style.textContent = `
    /* ============================================================ */
    /* TYPOGRAPHY: Built on Phrase native syn_form-row__label       */
    /* ============================================================ */

    :root {
      --pb-ui-font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      --pb-ui-font-size: 14px;
      --pb-ui-font-weight: 400;
      --pb-ui-line-height: 21px;
      --pb-ui-color: inherit;
    }

    .pb-header .syn_form-row__label,
    .pb-paragraph .syn_form-row__label,
    .pb-tooltip .syn_form-row__label {
      font-family: var(--pb-ui-font-family);
      display: block;
      text-align: left;
    }

    .pb-header .syn_form-row__label {
      font-size: 14px;
      font-weight: 700;
      line-height: 21px;
    }

    .pb-paragraph .syn_form-row__label {
      font-size: 14px;
      font-weight: 400;
      line-height: 21px;
    }

    .pb-tooltip .syn_form-row__label {
      font-size: 11px;
      font-weight: 400;
      line-height: 20.9px;
    }

    .pb-header {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .pb-header--inline {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .pb-paragraph {
      display: block;
    }

    .pb-tooltip {
      display: block;
    }

    .pb-info-icon {
      border: none;
      background: transparent;
      padding: 0;
      margin: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      border-radius: 999px;
      cursor: help;
      color: inherit;
    }

    /* ============================================================ */
    /* TAG CLICKING CURSOR AFFORDANCE                              */
    /* ============================================================ */

    /* When tag clicking is enabled, show pointer cursor on tags */
    html[data-pb-tag-clicking="1"] .te_tag,
    html[data-pb-tag-clicking="1"] [data-testid="tag"],
    html[data-pb-tag-clicking="1"] [data-tag],
    html[data-pb-tag-clicking="1"] [data-tag-type],
    html[data-pb-tag-clicking="1"] .tag_content {
      cursor: pointer !important;
    }

    /* Buddy Module Host Container - structural only */
    .pb-buddy-module-host {
      display: flex;
      flex-direction: column;
      height: 100%;
      width: 100%;
      overflow: hidden;
    }

    /* Subtabs container - centered layout, minimal CSS */
    .pb-buddy-subtabs {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Tab buttons - set padding to 8px to match other menu items */
    .pb-buddy-subtabs .syn_tab {
      position: relative;
      padding: 8px !important;
    }

    /* Settings Button - icon-only, centered */
    .pb-buddy-subtabs .syn_tab[data-pb-module-id="global-settings"] {
      min-width: 16px;
      min-height: 16px;
      justify-content: center;
    }

    /* Prefix span - no padding, centered alignment */
    .pb-buddy-subtabs .syn_tab__prefix {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 !important;
      margin: 0;
    }

    /* Ensure cogwheel icon inherits text color */
    .pb-buddy-subtabs .syn_tab .syn_icon {
      color: inherit;
      fill: currentColor;
    }

    /* Subpanels Container (Content Areas) - structural only */
    .pb-buddy-subpanels {
      display: flex;
      flex-direction: column;
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 0;
    }

    /* Individual Subpanel - structural only, NO padding */
    .pb-buddy-subpanel {
      flex: 0 0 auto;
      padding: 0;
      min-height: auto;
    }

    /* Module Two: Viewport - add 12px padding */
    .pb-buddy-subpanel.pb-buddy-module-two {
      padding: 12px;
    }

    /* Module Three: Settings - add 12px padding */
    .pb-buddy-subpanel.pb-buddy-module-three {
      padding: 12px;
    }

    /* Deactivated Message - add 12px padding */
    .pb-buddy-subpanel.pb-buddy-tag-viewer-deactivated {
      padding: 12px;
    }

    /* Ensure side-panel-content is hidden to prevent conflict */
    .pb-buddy-pane .side-panel-content:not(.pb-buddy-module-host) {
      display: none;
    }

    /* Override Phrase's default side-panel padding for Buddy pane */
    .pb-buddy-pane .side-panel-content {
      padding: 0 !important;
    }

    /* Remove padding from empty state container below header */
    .pb-buddy-pane .side-panel--empty-state {
      padding: 0 !important;
    }

    /* ============================================================ */
    /* STACKED MODULES: Enable/Disable & Conditional Visibility    */
    /* ============================================================ */

    /* Enable/disable section - checkbox at top of tool tab */
    .pb-buddy-subpanel-enable {
      display: flex;
      align-items: center;
      margin: 0 -12px;
      padding: 0 12px;
    }

    /* Checkbox styling - rely on syn_icon--compact class for sizing */
    .pb-buddy-subpanel-enable .syn_checkbox {
      margin: 0;
      padding: 0;
    }

    /* Checkbox SVG icons - force proper sizing and color */
    .syn_checkbox-icon {
      width: 16px !important;
      height: 16px !important;
      flex-shrink: 0;
    }

    .syn_checkbox-icon path {
      fill: inherit;
    }

    /* Checkbox label text - larger font for better readability */
    .syn_checkbox__label {
      font-size: 14px;
      margin-left: 0;
    }

    /* Fullbleed separator between sections */
    .pb-buddy-separator {
      height: 1px;
      background-color: var(--syn-color-neutral-200, #e0e0e0);
      border: none;
      margin: 0;
      width: calc(100% + 80px);
      margin-left: -40px;
      margin-right: -40px;
    }

    /* Content container - shown/hidden based on enable checkbox */
    .pb-buddy-subpanel-content {
      padding: 16px 40px;
      display: block;
    }

    /* Module sections - each get their own subpanel container */
    /* Module 1: Compact enable button container */
    .pb-buddy-module-one {
      padding: 12px;
      margin: 0;
      margin-bottom: 0;
    }

    /* Separator container - NO padding, spans full width */
    .pb-buddy-separator-container {
      padding: 0;
      margin: 0;
      flex: 0 0 auto;
    }

    .pb-buddy-separator-container .syn_divider--horizontal {
      margin: 0 !important;
    }

    .pb-buddy-module-deactivated {
      padding: 12px;
      display: block;
      min-height: auto;
    }

    .pb-buddy-module-deactivated p {
      margin: 8px 0;
      font-size: 13px;
      text-align: center;
      color: var(--syn-color-neutral-600, #666666);
      font-style: italic;
    }

    .pb-buddy-module-content {
      padding: 12px;
      display: block;
      min-height: auto;
    }    /* Hidden state - when tool is disabled */
    .pb-buddy-subpanel-content.pb-hidden {
      display: none;
    }

    /* Individual module within stacked content */
    .pb-buddy-module {
      padding: 8px 0;
    }

    .pb-buddy-module h3 {
      margin: 8px 0 4px 0;
      font-size: 14px;
      font-weight: 600;
    }

    .pb-buddy-module p {
      margin: 4px 0;
      font-size: 13px;
      line-height: 1.5;
    }

    /* Disabled message - shown when tool is disabled */
    .pb-buddy-disabled-message {
      padding: 24px 40px;
      text-align: center;
      color: var(--syn-color-neutral-600, #666666);
      font-style: italic;
    }

    .pb-buddy-disabled-message p {
      margin: 0;
      font-size: 13px;
    }

    /* ============================================================ */
    /* TAG VIEWER VIEWPORT STYLING                                 */
    /* ============================================================ */

    /* Tag Viewer viewport container (inline tab version) */
    .pb-tv-viewport {
      position: relative;
      width: 100%;
      min-height: 0;
      overflow-y: auto;
      overflow-x: hidden;
    }

    /* Scrollbar styling for viewport */
    .pb-tv-viewport::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    .pb-tv-viewport::-webkit-scrollbar-track {
      background: transparent;
    }

    .pb-tv-viewport::-webkit-scrollbar-thumb {
      background-color: rgba(128, 128, 128, 0.4);
      border-radius: 4px;
      border: 2px solid transparent;
      background-clip: content-box;
    }

    .pb-tv-viewport::-webkit-scrollbar-thumb:hover {
      background-color: rgba(128, 128, 128, 0.6);
      background-clip: content-box;
    }

    /* Firefox scrollbar styling for viewport */
    .pb-tv-viewport {
      scrollbar-color: rgba(128, 128, 128, 0.4) transparent;
      scrollbar-width: thin;
    }

    /* Inline pretty - fixed height for TAB viewport */
    #pb-tv-pretty-inline {
      width: 100%;
      height: 140px;
      max-height: 140px;
      overflow-y: auto;
      overflow-x: hidden;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: var(--pb-tv-font-size, 15px);
      font-weight: 400;
      line-height: var(--pb-tv-line-height, 25.5px);
      border-radius: 10px;
      padding: 10px;
      box-sizing: border-box;
    }

    /* Scrollbar styling for inline viewport */
    #pb-tv-pretty-inline::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    #pb-tv-pretty-inline::-webkit-scrollbar-track {
      background: transparent;
    }

    #pb-tv-pretty-inline::-webkit-scrollbar-thumb {
      background-color: rgba(128, 128, 128, 0.4);
      border-radius: 4px;
      border: 2px solid transparent;
      background-clip: content-box;
    }

    #pb-tv-pretty-inline::-webkit-scrollbar-thumb:hover {
      background-color: rgba(128, 128, 128, 0.6);
      background-clip: content-box;
    }

    /* Firefox scrollbar styling for inline */
    #pb-tv-pretty-inline {
      scrollbar-color: rgba(128, 128, 128, 0.4) transparent;
      scrollbar-width: thin;
    }

    /* Modal pretty should flex to available space */
    #pb-tv-pretty-modal {
      width: 100%;
      flex: 1 1 auto;
      min-height: 0;
      max-height: 100%;
      overflow-y: auto;
      overflow-x: hidden;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: var(--pb-tv-font-size, 15px);
      font-weight: 400;
      line-height: var(--pb-tv-line-height, 25.5px);
      border-radius: 10px;
      padding: 10px;
      box-sizing: border-box;
    }

    /* Scrollbar styling for modal viewport */
    #pb-tv-pretty-modal::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    #pb-tv-pretty-modal::-webkit-scrollbar-track {
      background: transparent;
    }

    #pb-tv-pretty-modal::-webkit-scrollbar-thumb {
      background-color: rgba(128, 128, 128, 0.4);
      border-radius: 4px;
      border: 2px solid transparent;
      background-clip: content-box;
    }

    #pb-tv-pretty-modal::-webkit-scrollbar-thumb:hover {
      background-color: rgba(128, 128, 128, 0.6);
      background-clip: content-box;
    }

    /* Firefox scrollbar styling for modal */
    #pb-tv-pretty-modal {
      scrollbar-color: rgba(128, 128, 128, 0.4) transparent;
      scrollbar-width: thin;
    }

    /* Generic shared styles */
    .pb-tv-pretty {
      border: 1px solid rgba(128,128,128,0.22);
      background: rgba(128,128,128,0.08);
      text-align: left;
    }

    .pb-tv-pretty, .pb-tv-pretty * {
      -webkit-user-select: text !important;
      -moz-user-select: text !important;
      user-select: text !important;
    }

    .pb-tv-quickcopy {
      position: absolute;
      right: 25px;
      bottom: 8px;
      z-index: 2;
      border: none;
      background: transparent;
      padding: 0;
      margin: 0;
      color: inherit;
      font: inherit;
      font-size: 11px;
      font-weight: 700;
      line-height: 20.9px;
      cursor: pointer;
      opacity: 0;
      pointer-events: none;
      text-decoration: none;
    }

    .pb-tv-viewport:hover .pb-tv-quickcopy {
      opacity: 1;
      pointer-events: auto;
    }

    .pb-tv-quickcopy:hover,
    .pb-tv-quickcopy:focus-visible {
      outline: none;
      text-decoration: underline;
    }

    .pb-tv-taglit {
      color: var(--pb-tv-tag-color, var(--pb-phrase-blue, var(--syn-color-primary, var(--syn_color_primary, #2F6FED))));
      font-weight: 650 !important;
    }

    /* ============================================================ */
    /* GLOBAL TOOLTIP STYLING                                       */
    /* ============================================================ */

    /* Tooltip wrapper container - transparent overlay */
    .pb-tooltip-wrapper {
      pointer-events: none;
      user-select: none;
    }

    /* Tooltip uses Phrase's native syn_tooltip class for automatic theming */
    /* No custom styling needed - inherits light/dark mode automatically */
    .pb-tooltip-wrapper .syn_tooltip {
      /* Phrase's native class handles all styling and theming */
    }

    .pb-tv-hidden {
      display: none !important;
    }

    /* Tag Viewer placeholders: matches disabled message style */
    .pb-tv-placeholder {
      font-size: 13px !important;
      text-align: center;
      color: var(--syn-color-neutral-600, #666666);
      font-style: italic;
      font-weight: 400 !important;
      line-height: 1.3 !important;
    }

    /* Tag viewer tree structure for formatted output */
    .pb-tagviewer-tree {
      display: flex;
      flex-direction: column;
      gap: 0;
    }

    .pb-tagviewer-tag {
      display: block;
      margin: 0;
      padding: 0;
    }

    .pb-tagviewer-tag-name {
      color: #d63384;
      font-weight: 300;
      cursor: pointer;
    }

    .pb-tagviewer-tag-close {
      color: #6f42c1;
      font-weight: 200;
    }

    .pb-tagviewer-tag-children {
      margin-left: 16px;
      display: block;
    }

    .pb-tagviewer-tag--self .pb-tagviewer-tag-name {
      color: #28a745;
    }

    /* ============================================================ */
    /* TAG VIEWER SETTINGS STYLING                                 */
    /* ============================================================ */

    .pb-buddy-settings-checkbox-row {
      display: flex;
      align-items: center;
      margin-top: 10px;
    }

    .pb-buddy-settings-checkbox-row .syn_checkbox {
      margin: 0;
      padding: 0;
    }

    /* Range slider styling */
    .pb-range {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: linear-gradient(to right, 
        var(--pb-phrase-blue, var(--syn-color-primary, #2F6FED)) 0%, 
        var(--pb-phrase-blue, var(--syn-color-primary, #2F6FED)) calc(var(--pb-range-pct, 0%)), 
        var(--syn-color-neutral-200, #e0e0e0) calc(var(--pb-range-pct, 0%)), 
        var(--syn-color-neutral-200, #e0e0e0) 100%);
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .pb-range::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--pb-phrase-blue, var(--syn-color-primary, #2F6FED));
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      transition: all 0.15s ease;
      margin-top: -5px;
    }

    .pb-range::-webkit-slider-thumb:hover {
      width: 18px;
      height: 18px;
      margin-top: -6px;
      box-shadow: 0 2px 6px rgba(47, 111, 237, 0.4);
    }

    .pb-range::-webkit-slider-thumb:active {
      width: 18px;
      height: 18px;
      margin-top: -6px;
      box-shadow: 0 2px 8px rgba(47, 111, 237, 0.6);
    }

    .pb-range::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--pb-phrase-blue, var(--syn-color-primary, #2F6FED));
      cursor: pointer;
      border: none;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      transition: all 0.15s ease;
      margin-top: -5px;
    }

    .pb-range::-moz-range-thumb:hover {
      width: 18px;
      height: 18px;
      margin-top: -6px;
      box-shadow: 0 2px 6px rgba(47, 111, 237, 0.4);
    }

    .pb-range::-moz-range-thumb:active {
      width: 18px;
      height: 18px;
      margin-top: -6px;
      box-shadow: 0 2px 8px rgba(47, 111, 237, 0.6);
    }

    .pb-range::-webkit-slider-runnable-track {
      background: transparent;
      height: 6px;
      border-radius: 3px;
    }

    .pb-range::-moz-range-track {
      background: transparent;
      border: none;
      height: 6px;
    }

    /* ============================================================ */
    /* MODAL DRAG CURSOR BEHAVIOR                                   */
    /* ============================================================ */

    /* Default: no drag cursor on modal */
    .pb-beta-modal {
      cursor: default;
    }

    /* Show move cursor only on footer */
    .pb-beta-modal__footer {
      cursor: move;
    }

    /* Hide move cursor everywhere else */
    .pb-beta-modal .pb-tv-viewport,
    .pb-beta-modal .pb-beta-modal__action-btn,
    .pb-beta-modal .pb-beta-modal__resizer,
    .pb-beta-modal__title,
    .pb-beta-modal__title-text {
      cursor: auto;
    }
  `;

  document.head.appendChild(style);
}

// Export public API
window.PB_Styles = {
  injectStyles,
};

/**
 * Module: checkbox-factory
 * Responsibility: Creates checkbox elements using Phrase's native styles.
 *                 Provides factory function to build checkboxes that match Phrase design.
 *                 Relies on Phrase's existing CSS for colors and styling.
 * Dependencies: None
 * Reference: Phrase's .syn_checkbox* classes
 */

// SVG paths - constants shared across all checkboxes
const CHECKBOX_SVG_PATHS = {
  unchecked: 'M18 3H6a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h12a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3ZM6 0a6 6 0 0 0-6 6v12a6 6 0 0 0 6 6h12a6 6 0 0 0 6-6V6a6 6 0 0 0-6-6H6Z',
  checked: 'M6 0a6 6 0 0 0-6 6v12a6 6 0 0 0 6 6h12a6 6 0 0 0 6-6V6a6 6 0 0 0-6-6H6Zm13.12 8.498-2.24-1.996-6.972 7.822-2.855-2.816-2.106 2.136 5.101 5.032L19.12 8.498Z',
};

/**
 * Creates a checkbox element with label and SVG icons.
 * 
 * @param {Object} options - Configuration object
 * @param {string} options.label - Label text (e.g., "Enable Tag Viewer")
 * @param {string} [options.dataAttribute] - Data attribute for the input (e.g., "data-pb-setting-id" or "data-pb-module-enable")
 * @param {string} [options.dataValue] - Value for the data attribute (e.g., "tags" or "character-detector")
 * @param {string} [options.size] - Checkbox size class: "sm", "md" (default), "lg"
 * @param {boolean} [options.checked] - Initial checked state (default: false)
 * @param {string} [options.id] - Optional ID for the input element
 * @param {string} [options.name] - Optional name attribute for the input element
 * @param {Function} [options.onToggle] - Callback when checkbox state changes (receives dataValue and checked state)
 * 
 * @returns {Object} Object with checkbox element and utility methods
 *   @returns {HTMLElement} .element - The label element containing the full checkbox
 *   @returns {HTMLInputElement} .input - Reference to the hidden checkbox input
 *   @returns {Function} .setChecked(bool) - Set checked state
 *   @returns {Function} .getChecked() - Get checked state
 *   @returns {Function} .toggle() - Toggle checked state
 *   @returns {Function} .onChange(callback) - Register change listener
 * 
 * @example
 * const cb = createCheckbox({
 *   label: 'Enable Tag Viewer',
 *   dataAttribute: 'data-pb-module-enable',
 *   dataValue: 'tags',
 *   checked: true
 * });
 * 
 * container.appendChild(cb.element);
 * cb.onChange((isChecked) => {
 *   console.log('Checkbox changed:', isChecked);
 * });
 */
function createCheckbox(options = {}) {
  const {
    label = 'Option',
    dataAttribute = 'data-pb-checkbox',
    dataValue = '',
    size = 'md',
    checked = false,
    id = null,
    name = null,
    onToggle = null,
  } = options;

  // Create root label element
  const labelEl = document.createElement('label');
  labelEl.className = `syn_checkbox syn_checkbox--${size}`;

  // Create icon wrapper
  const iconWrapper = document.createElement('span');
  iconWrapper.className = 'syn_checkbox-icon__wrapper';

  // Create hidden input element
  const input = document.createElement('input');
  input.type = 'checkbox';
  input.className = 'syn_checkbox-input';
  input.tabIndex = 0;
  input.checked = checked;
  
  if (id) input.id = id;
  if (name) input.name = name;
  if (dataAttribute && dataValue) {
    input.setAttribute(dataAttribute, dataValue);
  }

  // Create unchecked SVG
  const uncheckedSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  uncheckedSvg.setAttribute('viewBox', '0 0 24 24');
  uncheckedSvg.setAttribute('aria-hidden', 'true');
  uncheckedSvg.setAttribute('class', 'syn_icon syn_icon--compact syn_checkbox-icon');
  uncheckedSvg.setAttribute('data-pb-checkbox-svg', 'unchecked');
  uncheckedSvg.style.display = checked ? 'none' : 'block';

  const uncheckedPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  uncheckedPath.setAttribute('fill-rule', 'evenodd');
  uncheckedPath.setAttribute('clip-rule', 'evenodd');
  uncheckedPath.setAttribute('d', CHECKBOX_SVG_PATHS.unchecked);
  uncheckedSvg.appendChild(uncheckedPath);

  // Create checked SVG
  const checkedSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  checkedSvg.setAttribute('viewBox', '0 0 24 24');
  checkedSvg.setAttribute('aria-hidden', 'true');
  checkedSvg.setAttribute('class', 'syn_icon syn_icon--compact syn_checkbox-icon syn_checkbox-icon--checked');
  checkedSvg.setAttribute('data-pb-checkbox-svg', 'checked');
  checkedSvg.style.display = checked ? 'block' : 'none';

  const checkedPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  checkedPath.setAttribute('fill-rule', 'evenodd');
  checkedPath.setAttribute('clip-rule', 'evenodd');
  checkedPath.setAttribute('d', CHECKBOX_SVG_PATHS.checked);
  checkedSvg.appendChild(checkedPath);

  // Create label text
  const labelText = document.createElement('span');
  labelText.className = 'syn_checkbox__label';
  labelText.textContent = label;

  // Assemble icon wrapper
  iconWrapper.appendChild(input);
  iconWrapper.appendChild(uncheckedSvg);
  iconWrapper.appendChild(checkedSvg);

  // Assemble label
  labelEl.appendChild(iconWrapper);
  labelEl.appendChild(labelText);

  // Set up state management
  input.addEventListener('change', () => {
    uncheckedSvg.style.display = input.checked ? 'none' : 'block';
    checkedSvg.style.display = input.checked ? 'block' : 'none';
    
    // Call optional toggle callback with dataValue and checked state
    if (onToggle && dataValue) {
      onToggle(dataValue, input.checked);
    }
  });

  // Return public API
  return {
    element: labelEl,
    input: input,
    
    /**
     * Set the checked state programmatically.
     * @param {boolean} value - True to check, false to uncheck
     */
    setChecked(value) {
      if (input.checked !== value) {
        input.checked = value;
        input.dispatchEvent(new Event('change', { bubbles: true }));
      }
    },
    
    /**
     * Get the current checked state.
     * @returns {boolean} Current checked state
     */
    getChecked() {
      return input.checked;
    },
    
    /**
     * Toggle the checked state.
     */
    toggle() {
      this.setChecked(!input.checked);
    },
    
    /**
     * Register a callback for checkbox state changes.
     * @param {Function} callback - Called with boolean (checked state)
     */
    onChange(callback) {
      input.addEventListener('change', (e) => {
        callback(e.target.checked);
      });
    },
  };
}

// Export public API
window.PB_CheckboxFactory = {
  createCheckbox,
};

/**
 * Module: tag-viewer-logic
 * Responsibility: Parse XML tags from text, extract editor content, validate tag structure.
 *                 Provides data processing logic for Tag Viewer UI.
 *                 Handles malformed XML, special characters, and edge cases.
 *                 Manages side override (source/target) for tag clicking.
 * Dependencies: None
 */

// Side override state for tag clicking
const PB_TV_SIDE_OVERRIDE = {
  side: null, // 'source' or null
  segment: null, // segment element reference
};

/**
 * Set side override to display source instead of target.
 * Used when user clicks a tag in source segment.
 * @param {string} side - 'source' to override
 * @param {Element} segment - Segment element
 */
function setSideOverride(side, segment) {
  const segmentIndex = segment ? Array.from(document.querySelectorAll('.twe_segment, [data-testid="segment"]')).indexOf(segment) : -1;
  PB_TV_SIDE_OVERRIDE.side = side;
  PB_TV_SIDE_OVERRIDE.segment = segment;
}

/**
 * Clear side override, return to normal target display.
 */
function clearSideOverride() {
  PB_TV_SIDE_OVERRIDE.side = null;
  PB_TV_SIDE_OVERRIDE.segment = null;
}

/**
 * Get current side override state.
 * @returns {Object} { side, segment }
 */
function getSideOverride() {
  return { ...PB_TV_SIDE_OVERRIDE };
}

/**
 * Find the active segment's target text container in Phrase editor.
 * Returns rich HTML with text content and tag values from the actual rendered segment.
 * This matches the old code's behavior of reading from te_text_container.
 * Respects side override when set (shows source instead of target).
 * 
 * @returns {Object} { html: string, plain: string } HTML with tag styling, plain text with tag values
 */
function getEditorTargetText() {
  // Check if side override is active
  const sideOverride = PB_TV_SIDE_OVERRIDE.side;
  const overrideSegment = PB_TV_SIDE_OVERRIDE.segment;

  // Find active segment using multiple fallbacks (matches old code)
  const activeSegment = document.querySelector(
    '.twe_segment.twe_active, .twe_segment.twe_active_background, [data-testid="segment"][data-selected="true"]'
  );
  
  if (!activeSegment) return { html: '', plain: '' };
  
  // Use override segment if still active, otherwise use current active segment
  const segmentToRead = (sideOverride && overrideSegment) ? overrideSegment : activeSegment;
  
  const sideSel = (sideOverride === 'source') ? '.twe_source' : '.twe_target';
  const sideDataTestId = (sideOverride === 'source') ? 'source' : 'target';
  

  // Find text container in segment (source or target based on override)
  const container = segmentToRead.querySelector(
    `${sideSel} .te_text_container, [data-testid="${sideDataTestId}"] .te_text_container, ${sideSel} [data-role="text-container"]`
  );

  if (!container) {
    // Fallback: try to read from editable input
    const live = segmentToRead.querySelector(`${sideSel} .twe-main-input, textarea.twe-main-input, [contenteditable="true"]`);
    const raw = (live && (live.value || live.textContent)) || '';
    const plain = String(raw || '');
    return { plain, html: escapeHtml(plain) };
  }

  // Extract rich content with tag values from te_text_container
  return rebuildConvertedRich(container);
}

/**
 * Rebuild converted rich content from te_text_container.
 * Reconstructs HTML and plain text from rendered segments, including tag values.
 * Matches the old code's pbTv_rebuildConvertedRich logic.
 * 
 * @param {HTMLElement} container - The te_text_container element
 * @returns {Object} { plain: string, html: string }
 */
function rebuildConvertedRich(container) {
  if (!container) return { plain: '', html: '' };

  let plain = '';
  let html = '';

  const isUnicodeDecorator = (el) => {
    if (!el || el.nodeType !== 1) return false;
    if (el.classList?.contains('pb-unicode-badge')) return true;
    if (el.classList?.contains('pb-unicode-mark')) return true;
    if (el.matches?.('.pb-unicode-badge,.pb-unicode-mark')) return true;
    return false;
  };

  container.childNodes.forEach((n) => {
    if (n.nodeType === 3) {
      // Text node
      const t = n.nodeValue || '';
      plain += t;
      html += escapeHtml(t);
      return;
    }
    if (n.nodeType !== 1) return;

    const el = n;

    // Skip unicode decorators
    if (isUnicodeDecorator(el)) return;

    // Handle regular text spans
    if (el.classList?.contains('te_txt')) {
      const t = el.textContent || '';
      plain += t;
      html += escapeHtml(t);
      return;
    }

    // Handle Phrase tags - check multiple possible selectors
    // Tags can be: <span class="te_tag">, <ph>, [data-testid="tag"], [data-tag], or have te_tag class
    const isTag = el.classList?.contains('te_tag') || 
                  el.tagName?.toLowerCase() === 'ph' ||
                  el.matches?.('[data-testid="tag"],[data-tag],[data-tag-type]');
    if (isTag) {
      const { text } = extractPhraseTagValue(el);
      plain += text;
      html += `<span class="pb-tv-taglit">${escapeHtml(text)}</span>`;
      return;
    }

    // Fallback: use textContent
    const t = el.textContent || '';
    plain += t;
    html += escapeHtml(t);
  });

  return { plain, html };
}

/**
 * Extract the displayed value from a Phrase tag element.
 * Phrase tags are rendered as <ph> elements containing metadata in title/tmp-title attributes.
 * Extracts displaytext first, then val attribute from the tag metadata.
 * Matches the old code's pbTv_extractPhraseTagValue logic.
 * 
 * @param {HTMLElement} el - The tag element (usually <ph> or <span class="te_tag">)
 * @returns {Object} { text: string, fromTag: boolean }
 */
function extractPhraseTagValue(el) {
  const meta = el?.querySelector?.('.tag_metadata_content')?.textContent || 
               el?.getAttribute?.('tmp-title') || 
               el?.getAttribute?.('title') || '';
  
  if (!meta) return { text: '', fromTag: true };

  const un = decodeHtml(meta);

  // Priority 1: displaytext attribute
  const a = extractAttr(un, 'displaytext');
  if (a) return { text: decodeHtml(a), fromTag: true };

  // Priority 2: val attribute
  const b = extractAttr(un, 'val');
  if (b) return { text: decodeHtml(b), fromTag: true };

  // Priority 3: <bpt> inner content
  const innerBpt = extractInnerTag(un, 'bpt');
  if (innerBpt) return { text: decodeHtml(innerBpt), fromTag: true };

  // Priority 4: <ept> inner content
  const innerEpt = extractInnerTag(un, 'ept');
  if (innerEpt) return { text: decodeHtml(innerEpt), fromTag: true };

  // Priority 5: Generic inner tag content
  const lower = un.toLowerCase();
  const lt = lower.indexOf('<');
  const gt = lower.indexOf('>', lt + 1);
  if (lt !== -1 && gt !== -1) {
    const closeLt = lower.lastIndexOf('</');
    if (closeLt !== -1 && closeLt > gt) {
      const inner = un.slice(gt + 1, closeLt);
      if (inner) return { text: decodeHtml(inner), fromTag: true };
    }
  }

  // Priority 6: Fallback to data-tag-content attribute
  return { text: el?.getAttribute?.('data-tag-content') || '', fromTag: true };
}

/**
 * Extract attribute value from XML string.
 * Finds attr="value" pattern using simple string matching.
 * Matches old code's pbTv_extractAttr for robust XML parsing.
 * 
 * @param {string} xmlStr - XML/HTML string to search
 * @param {string} attrName - Attribute name to find
 * @returns {string} Attribute value (empty string if not found)
 */
function extractAttr(xmlStr, attrName) {
  if (!xmlStr || !attrName) return '';
  
  const needle = attrName + '="';
  const idx = xmlStr.toLowerCase().indexOf(needle);
  if (idx === -1) return '';
  
  const start = idx + needle.length;
  const end = xmlStr.indexOf('"', start);
  if (end === -1) return '';
  
  return xmlStr.slice(start, end);
}

/**
 * Extract content of inner XML tag from string.
 * Finds <tagname>content</tagname> pattern using simple string matching.
 * Matches old code's pbTv_extractInnerTag for robust XML parsing.
 * 
 * @param {string} xmlStr - XML string to search
 * @param {string} tagName - Tag name to find
 * @returns {string} Inner content (empty string if not found)
 */
function extractInnerTag(xmlStr, tagName) {
  if (!xmlStr || !tagName) return '';
  
  const lower = xmlStr.toLowerCase();
  const openIdx = lower.indexOf('<' + tagName);
  if (openIdx === -1) return '';
  
  const gt = lower.indexOf('>', openIdx);
  if (gt === -1) return '';
  
  const closeNeedle = '</' + tagName + '>';
  const closeIdx = lower.indexOf(closeNeedle, gt + 1);
  if (closeIdx === -1) return '';
  
  return xmlStr.slice(gt + 1, closeIdx);
}

/**
 * Decode HTML entities in a string.
 * Converts &lt; &gt; &quot; &amp; etc. back to actual characters.
 * Uses textarea like old code for more reliable entity decoding.
 * 
 * @param {string} str - String with HTML entities
 * @returns {string} Decoded string
 */
function decodeHtml(str) {
  if (!str || typeof str !== 'string') return '';
  
  const textarea = document.createElement('textarea');
  textarea.innerHTML = str;
  return textarea.value;
}

/**
 * Escape HTML special characters in a string.
 * Converts <, >, &, ", ' to HTML entities.
 * 
 * @param {string} str - String to escape
 * @returns {string} Escaped string
 */
function escapeHtml(str) {
  if (!str || typeof str !== 'string') return '';
  
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

/**
 * Parse XML/tags from text into a tree structure.
 * Handles both opening/closing tags and self-closing tags.
 * Returns array of tag nodes with nesting information.
 * 
 * @param {string} text - Text potentially containing tags (e.g., "<g1>text</g1>")
 * @returns {Array} Array of tag objects: { name, type: 'open'|'close'|'self', depth, content, fullTag }
 */
function parseTagsFromText(text) {
  if (!text || typeof text !== 'string') {
    return [];
  }

  const tags = [];
  const tagRegex = /<\/?[a-zA-Z0-9_:\-\.]*(?:\s+[^>]*)?\/?>/g;
  const matches = Array.from(text.matchAll(tagRegex));

  matches.forEach((match) => {
    const fullTag = match[0];
    
    // Determine tag type
    let type = 'open';
    let name = '';
    
    if (fullTag.startsWith('</')) {
      type = 'close';
      name = fullTag.slice(2, -1).trim();
    } else if (fullTag.endsWith('/>')) {
      type = 'self';
      name = fullTag.slice(1, -2).trim().split(/\s/)[0];
    } else {
      type = 'open';
      name = fullTag.slice(1, -1).trim().split(/\s/)[0];
    }

    tags.push({
      name: name || 'unknown',
      type,
      fullTag,
      position: match.index,
    });
  });

  return tags;
}

/**
 * Build a nested tree structure from flat tag list.
 * Handles nesting depth and parent-child relationships.
 * Returns tree that can be rendered recursively.
 * 
 * @param {Array} tags - Flat array from parseTagsFromText
 * @returns {Array} Tree structure: { name, type, children, depth, fullTag }
 */
function buildTagTree(tags) {
  const tree = [];
  const stack = [];

  tags.forEach((tag) => {
    if (tag.type === 'open') {
      const node = {
        name: tag.name,
        type: tag.type,
        fullTag: tag.fullTag,
        depth: stack.length,
        children: [],
      };

      if (stack.length > 0) {
        stack[stack.length - 1].children.push(node);
      } else {
        tree.push(node);
      }

      stack.push(node);
    } else if (tag.type === 'close') {
      // Pop from stack if matching
      if (stack.length > 0) {
        const lastOpen = stack[stack.length - 1];
        if (lastOpen.name === tag.name) {
          lastOpen.closed = true;
          stack.pop();
        } else {
          // Mismatched closing tag - add as warning
          console.warn(`[Tag Viewer] Mismatched closing tag: expected </${lastOpen.name}>, got </${tag.name}>`);
        }
      }
    } else if (tag.type === 'self') {
      const node = {
        name: tag.name,
        type: tag.type,
        fullTag: tag.fullTag,
        depth: stack.length,
        children: [],
        closed: true,
      };

      if (stack.length > 0) {
        stack[stack.length - 1].children.push(node);
      } else {
        tree.push(node);
      }
    }
  });

  // Mark unclosed tags as warnings
  stack.forEach((unclosed) => {
    unclosed.unclosed = true;
  });

  return tree;
}

/**
 * Validate tag structure for common errors.
 * Returns validation result with errors if any.
 * 
 * @param {Array} tagTree - Tree from buildTagTree
 * @returns {Object} { valid: boolean, errors: [] }
 */
function validateTagStructure(tagTree) {
  const errors = [];
  const openTags = new Map();

  function walkTree(node, stack) {
    if (node.type === 'open') {
      stack.push(node.name);
      openTags.set(node.name, (openTags.get(node.name) || 0) + 1);
    } else if (node.type === 'close') {
      if (!stack.includes(node.name)) {
        errors.push(`Closing tag </${node.name}> without opening tag`);
      } else {
        stack.pop();
      }
    }

    if (node.children && Array.isArray(node.children)) {
      node.children.forEach(child => walkTree(child, [...stack]));
    }

    if (node.unclosed) {
      errors.push(`Unclosed tag: <${node.name}>`);
    }
  }

  tagTree.forEach((node) => {
    walkTree(node, []);
  });

  return {
    valid: errors.length === 0,
    errors,
    tagCount: tagTree.length,
  };
}

/**
 * Get a human-readable representation of tag tree for debugging.
 * Useful for console logging and testing.
 * 
 * @param {Array} tagTree - Tree from buildTagTree
 * @returns {string} Formatted tree string
 */
function formatTagTree(tagTree) {
  let result = '';
  
  function indent(depth) {
    return '  '.repeat(depth);
  }

  function walk(node, depth = 0) {
    const prefix = indent(depth);
    
    if (node.type === 'self') {
      result += `${prefix}<${node.name} />\n`;
    } else if (node.type === 'open') {
      result += `${prefix}<${node.name}>\n`;
      if (node.children && node.children.length > 0) {
        node.children.forEach(child => walk(child, depth + 1));
      }
      result += `${prefix}</${node.name}>\n`;
    }
  }

  tagTree.forEach((node) => {
    walk(node, 0);
  });

  return result;
}

/**
 * Extract just tag names (no nesting info) for quick display.
 * Useful for simple tag listing.
 * 
 * @param {Array} tagTree - Tree from buildTagTree
 * @returns {Array} Array of { name, count }
 */
function getUniqueTagNames(tagTree) {
  const uniqueNames = new Map();

  function walk(node) {
    if (!uniqueNames.has(node.name)) {
      uniqueNames.set(node.name, 0);
    }
    uniqueNames.set(node.name, uniqueNames.get(node.name) + 1);

    if (node.children && node.children.length > 0) {
      node.children.forEach(child => walk(child));
    }
  }

  tagTree.forEach((node) => {
    walk(node);
  });

  return Array.from(uniqueNames.entries()).map(([name, count]) => ({
    name,
    count,
  }));
}

// Export public API
window.PB_TagViewerLogic = {
  getEditorTargetText,
  parseTagsFromText,
  buildTagTree,
  validateTagStructure,
  formatTagTree,
  getUniqueTagNames,
  setSideOverride,
  clearSideOverride,
  getSideOverride,
};

/**
 * Module: tag-viewer-modal-loader
 * Responsibility: Detect and wait for Phrase's loading indicators before showing modal.
 *                 Provides utilities to check if page is ready for modal display.
 * Dependencies: None (pure utility functions)
 */

// Loading/readiness detection - Phrase loading indicators
const PHRASE_LOADERS = [
  '#progress-bar-frame',
  '.syn_loader',
  '.syn_spinner',
  '[data-testid*="loading" i]',
  '[data-testid*="spinner" i]',
  '.loading',
  '.spinner',
];

/**
 * Check if Phrase's blocking loaders/spinners are currently visible
 * @returns {boolean} True if a loader/spinner is covering the UI
 */
function isPhraseLoaderVisible() {
  const isVisible = (el) => {
    try {
      if (!el || !(el instanceof HTMLElement)) return false;
      if (el.getAttribute('aria-hidden') === 'true') return false;

      const cs = getComputedStyle(el);
      if (!cs || cs.display === 'none' || cs.visibility === 'hidden') return false;

      const opacity = parseFloat(cs.opacity || '1');
      if (Number.isFinite(opacity) && opacity <= 0.05) return false;

      const rect = el.getBoundingClientRect();
      if (!rect || rect.width <= 0 || rect.height <= 0) return false;

      return true;
    } catch (e) {
      return false;
    }
  };

  let foundBlockingLoader = false;
  for (const selector of PHRASE_LOADERS) {
    const elements = Array.from(document.querySelectorAll(selector));
    for (const el of elements) {
      if (!isVisible(el)) continue;
      // Treat as "blocking" if it covers a significant portion of viewport
      const rect = el.getBoundingClientRect();
      const vw = window.innerWidth || 0;
      const vh = window.innerHeight || 0;
      if (vw && vh) {
        const coversViewport = rect.width >= vw * 0.6 && rect.height >= vh * 0.6;
        if (coversViewport) {
          foundBlockingLoader = true;
        }
      } else {
        foundBlockingLoader = true;
      }
    }
  }
  return foundBlockingLoader;
}

/**
 * Wait until Phrase's loaders disappear before showing modal
 * @param {Function} callback - Called when Phrase is ready
 * @param {Object} options - Configuration
 * @returns {Function} Cleanup function
 */
function waitForPhraseLoaders(callback, options = {}) {
  const {
    timeoutMs = 20000,
    quietMs = 300,
    pollMs = 200,
  } = options;

  if (typeof callback !== 'function') return () => {};

  let done = false;
  let lastMutationAt = Date.now();
  let checkCount = 0;
  const startTime = Date.now();

  const finish = () => {
    if (done) return;
    done = true;
    try { cleanup(); } catch (e) {}
    try { callback(); } catch (e) {}
  };

  const check = () => {
    if (done) return;
    checkCount++;
    
    const hasLoaders = isPhraseLoaderVisible();
    if (hasLoaders) {
      return;
    }

    const quietFor = Date.now() - lastMutationAt;
    
    if (quietFor >= quietMs) {
      finish();
    }
  };

  // Observe DOM changes
  let observer;
  let pollInterval;

  const cleanup = () => {
    try { observer?.disconnect?.(); } catch (e) {}
    try { window.clearInterval(pollInterval); } catch (e) {}
  };

  try {
    observer = new MutationObserver(() => {
      lastMutationAt = Date.now();
    });

    observer.observe(document.documentElement || document.body, {
      subtree: true,
      childList: true,
    });
  } catch (e) {
    // MutationObserver failed, will continue with polling
  }

  // Poll for readiness
  pollInterval = window.setInterval(() => {
    if (done) return;

    if ((Date.now() - startTime) > timeoutMs) {
      finish();  // Timeout - proceed anyway
      return;
    }

    check();
  }, Math.max(200, pollMs | 0));

  // Immediate check
  try { check(); } catch (e) {
    // Initial check failed, will continue with polling
  }

  return cleanup;
}

window.PB_TagViewerModalLoader = {
  isPhraseLoaderVisible,
  waitForPhraseLoaders,
};

/**
 * Module: tag-viewer-modal-persistence
 * Responsibility: Manage persistence and retrieval of modal state (position, size, collapsed).
 *                 Provides position/size calculations and viewport boundary helpers.
 * Dependencies: Tampermonkey GM_* functions (implicit)
 */

/**
 * Load modal window position from GM storage
 * @returns {{left: number, top: number}|null}
 */
function getModalPosition() {
  const storageKey = 'pb_tv_modal_position';
  if (typeof GM_getValue !== 'function') return null;
  
  try {
    const saved = GM_getValue(storageKey);
    if (saved && typeof saved === 'object' && 
        Number.isFinite(saved.left) && Number.isFinite(saved.top)) {
      return { left: Number(saved.left), top: Number(saved.top) };
    }
  } catch (error) {
    console.error('[Tag Viewer Modal] Error loading position:', error);
  }
  
  return null;
}

/**
 * Save modal window position to GM storage
 * @param {{left: number, top: number}} pos
 */
function saveModalPosition(pos) {
  const storageKey = 'pb_tv_modal_position';
  if (typeof GM_setValue !== 'function') return;
  if (!pos || typeof pos !== 'object') return;
  
  try {
    const left = Math.round(Number(pos.left));
    const top = Math.round(Number(pos.top));
    
    if (!Number.isFinite(left) || !Number.isFinite(top)) return;
    
    GM_setValue(storageKey, { left, top });
  } catch (error) {
    console.error('[Tag Viewer Modal] Error saving position:', error);
  }
}

/**
 * Load pill position from GM storage
 * @returns {{left: number, top: number}|null}
 */
function getPillPosition() {
  const storageKey = 'pb_tv_modal_pill_position';
  if (typeof GM_getValue !== 'function') return null;
  
  try {
    const saved = GM_getValue(storageKey);
    if (saved && typeof saved === 'object' && 
        Number.isFinite(saved.left) && Number.isFinite(saved.top)) {
      return { left: Number(saved.left), top: Number(saved.top) };
    }
  } catch (error) {
    console.error('[Tag Viewer Modal] Error loading pill position:', error);
  }
  
  return null;
}

/**
 * Save pill position to GM storage
 * @param {{left: number, top: number}} pos
 */
function savePillPosition(pos) {
  const storageKey = 'pb_tv_modal_pill_position';
  if (typeof GM_setValue !== 'function') return;
  if (!pos || typeof pos !== 'object') return;
  
  try {
    const left = Math.round(Number(pos.left));
    const top = Math.round(Number(pos.top));
    
    if (!Number.isFinite(left) || !Number.isFinite(top)) return;
    
    GM_setValue(storageKey, { left, top });
  } catch (error) {
    console.error('[Tag Viewer Modal] Error saving pill position:', error);
  }
}

/**
 * Get the bottom limit for modal positioning (actual page bottom, not status bar)
 * @returns {number} Maximum bottom Y coordinate
 */
function getBottomLimit() {
  const margin = 8;
  const vh = window.innerHeight || 0;
  return Math.max(margin, vh - margin);
}

/**
 * Clamp top position to keep modal in viewport (can overlap status bar)
 * @param {number} top - Desired top position
 * @param {number} height - Dialog height
 * @returns {number} Clamped top position
 */
function clampTop(top, height) {
  const margin = 8;
  const vh = window.innerHeight || 0;
  const maxTop = Math.max(margin, vh - Math.max(0, height || 0) - margin);
  const clampedValue = Math.max(margin, Math.min(top, maxTop));
  return clampedValue;
}

/**
 * Load modal window size from GM storage
 * @returns {{w: number, h: number}|null}
 */
function getModalSize() {
  const storageKey = 'pb_tv_modal_size';
  if (typeof GM_getValue !== 'function') return null;
  
  try {
    const saved = GM_getValue(storageKey);
    if (saved && typeof saved === 'object' && 
        Number.isFinite(saved.w) && Number.isFinite(saved.h)) {
      return { w: Number(saved.w), h: Number(saved.h) };
    }
  } catch (error) {
    console.error('[Tag Viewer Modal] Error loading size:', error);
  }
  
  return null;
}

/**
 * Save modal window size to GM storage
 * @param {{w: number, h: number}} size
 */
function saveModalSize(size) {
  const storageKey = 'pb_tv_modal_size';
  if (typeof GM_setValue !== 'function') return;
  if (!size || typeof size !== 'object') return;
  
  try {
    const w = Math.round(Number(size.w));
    const h = Math.round(Number(size.h));
    
    if (!Number.isFinite(w) || !Number.isFinite(h)) return;
    
    GM_setValue(storageKey, { w, h });
  } catch (error) {
    console.error('[Tag Viewer Modal] Error saving size:', error);
  }
}

/**
 * Load modal collapsed state from GM storage
 * @returns {boolean|null}
 */
function getModalCollapsedState() {
  const storageKey = 'pb_tv_modal_collapsed';
  if (typeof GM_getValue !== 'function') return null;
  
  try {
    const saved = GM_getValue(storageKey);
    if (typeof saved === 'boolean') {
      return saved;
    }
  } catch (error) {
    console.error('[Tag Viewer Modal] Error loading collapsed state:', error);
  }
  
  return null;
}

/**
 * Save modal collapsed state to GM storage
 * @param {boolean} isCollapsed
 */
function saveModalCollapsedState(isCollapsed) {
  const storageKey = 'pb_tv_modal_collapsed';
  if (typeof GM_setValue !== 'function') return;
  
  try {
    GM_setValue(storageKey, !!isCollapsed);
  } catch (error) {
    console.error('[Tag Viewer Modal] Error saving collapsed state:', error);
  }
}

// Export API
window.PB_TagViewerModalPersistence = {
  getModalPosition,
  saveModalPosition,
  getPillPosition,
  savePillPosition,
  getBottomLimit,
  clampTop,
  getModalSize,
  saveModalSize,
  getModalCollapsedState,
  saveModalCollapsedState,
};

/**
 * Module: tag-viewer-modal-theme
 * Responsibility: Theme sampling and application for Tag Viewer modal.
 *                 Samples Phrase's UI colors and applies them to modal.
 *                 Observes theme changes and updates modal accordingly.
 * Dependencies: None (pure utility functions)
 */

/**
 * Parse color string to RGBA components
 * @param {string} colorStr - Color string (rgb, rgba, hex)
 * @returns {{r: number, g: number, b: number, a: number}|null}
 */
function parseColor(colorStr) {
  if (!colorStr || typeof colorStr !== 'string') return null;
  
  const str = colorStr.trim();
  
  // Parse rgb/rgba
  const rgbMatch = str.match(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d.]+))?\s*\)/);
  if (rgbMatch) {
    return {
      r: parseInt(rgbMatch[1], 10),
      g: parseInt(rgbMatch[2], 10),
      b: parseInt(rgbMatch[3], 10),
      a: rgbMatch[4] !== undefined ? parseFloat(rgbMatch[4]) : 1,
    };
  }
  
  // Parse hex
  const hexMatch = str.match(/^#([0-9a-fA-F]{3,8})$/);
  if (hexMatch) {
    let hex = hexMatch[1];
    if (hex.length === 3) {
      hex = hex.split('').map(c => c + c).join('');
    }
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    const a = hex.length === 8 ? parseInt(hex.slice(6, 8), 16) / 255 : 1;
    return { r, g, b, a };
  }
  
  return null;
}

/**
 * Calculate relative luminance
 * @param {{r: number, g: number, b: number}} rgb
 * @returns {number}
 */
function getLuminance(rgb) {
  const { r, g, b } = rgb;
  const [rs, gs, bs] = [r, g, b].map(c => {
    const val = c / 255;
    return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
  });
  return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
}

/**
 * Calculate saturation
 * @param {{r: number, g: number, b: number}} rgb
 * @returns {number}
 */
function getSaturation(rgb) {
  const { r, g, b } = rgb;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  if (max === 0) return 0;
  return (max - min) / max;
}

/**
 * Sample Phrase's primary blue color from UI elements
 * @returns {string} CSS color value
 */
function samplePhrasePrimaryColor() {
  const fallback = '#2F6FED';
  
  // Expanded sampling order - look for actual colored UI elements
  const candidates = [
    // Save/Confirm buttons (usually blue primary)
    () => {
      const saveBtn = document.querySelector('button.syn_btn--primary:not(.syn_btn--small)');
      if (saveBtn) {
        const bg = window.getComputedStyle(saveBtn).backgroundColor;
        const color = window.getComputedStyle(saveBtn).color;
        // Try both background and text color, but only return if saturated enough
        const bgSat = bg ? getSaturation(parseColor(bg)) : 0;
        const colorSat = color ? getSaturation(parseColor(color)) : 0;
        if (bgSat >= 0.05 && bgSat > colorSat) return bg;  // Prefer saturated background
        if (colorSat >= 0.05) return color;                // Then saturated text color
      }
      return null;
    },
    // Links (often blue in web interfaces)
    () => {
      const links = document.querySelectorAll('a[href]:not([href="#"]):not([href="javascript:void(0)"])');
      for (const link of links) {
        const color = window.getComputedStyle(link).color;
        if (color && color !== 'rgb(0, 0, 0)' && color !== 'rgb(255, 255, 255)') {
          console.log('[PB_TV] Link color:', color);
          return color;
        }
      }
      return null;
    },
    // Active/selected states (tabs, list items)
    () => {
      const active = document.querySelector('[aria-selected="true"], .syn_tab--active, .syn_list_item--highlighted');
      if (active) {
        const color = window.getComputedStyle(active).color;
        const border = window.getComputedStyle(active).borderLeftColor || window.getComputedStyle(active).borderColor;
        const bg = window.getComputedStyle(active).backgroundColor;
        console.log('[PB_TV] Active element colors:', {color, border, bg});
        // Try border first (often accent color), then color, then bg
        const borderSat = border ? getSaturation(parseColor(border)) : 0;
        const colorSat = color ? getSaturation(parseColor(color)) : 0;
        const bgSat = bg ? getSaturation(parseColor(bg)) : 0;
        if (borderSat > 0.05) return border;
        if (colorSat > 0.05) return color;
        if (bgSat > 0.05) return bg;
      }
      return null;
    },
    // Icon colors (often use accent colors)
    () => {
      const icons = document.querySelectorAll('[class*="icon"], svg');
      for (const icon of icons) {
        const fill = window.getComputedStyle(icon).fill;
        const stroke = window.getComputedStyle(icon).stroke;
        const color = window.getComputedStyle(icon).color;
        if (fill && fill !== 'none' && fill !== 'rgb(0, 0, 0)' && fill !== 'rgb(255, 255, 255)') {
          console.log('[PB_TV] Icon fill:', fill);
          const sat = getSaturation(parseColor(fill));
          if (sat > 0.05) return fill;
        }
        if (stroke && stroke !== 'none') {
          const sat = getSaturation(parseColor(stroke));
          if (sat > 0.05) return stroke;
        }
        if (color) {
          const sat = getSaturation(parseColor(color));
          if (sat > 0.05) return color;
        }
      }
      return null;
    },
    // CSS variables
    () => {
      const root = document.documentElement;
      const vars = ['--syn-color-primary', '--syn_color_primary', '--primary-color', '--accent-color', '--link-color', '--brand-color'];
      for (const varName of vars) {
        const value = getComputedStyle(root).getPropertyValue(varName) || getComputedStyle(document.body).getPropertyValue(varName);
        if (value) {
          console.log(`[PB_TV] CSS variable ${varName}:`, value);
          const sat = getSaturation(parseColor(value.trim()));
          if (sat > 0.05) return value.trim();
        }
      }
      return null;
    },
  ];
  
  for (const fn of candidates) {
    try {
      const color = fn();
      if (!color) continue;
      
      const parsed = parseColor(color);
      if (!parsed || parsed.a < 0.25) {
        console.log('[PB_TV] Color rejected (alpha/parse):', color, parsed);
        continue;
      }
      
      const sat = getSaturation(parsed);
      const lum = getLuminance(parsed);
      
      console.log('[PB_TV] Candidate:', color, {saturation: sat, luminance: lum});
      
      // Accept colors with >= 0.05 saturation (relaxed from 0.10)
      // Luminance: 0.01-0.95 for readable colors in any mode
      if (sat >= 0.05 && lum > 0.01 && lum < 0.95) {
        console.log('[PB_TV] Color accepted:', color);
        return color;
      }
    } catch (e) {
      console.error('[PB_TV] Error sampling color:', e);
    }
  }
  
  console.log('[PB_TV] Using fallback phrase blue:', fallback);
  return fallback;
}

/**
 * Sample Phrase's surface tokens (background and foreground colors)
 * @returns {{bg: string, fg: string}}
 */
function samplePhraseSurfaceTokens() {
  const fallback = { bg: '#ffffff', fg: '#111111' };
  
  // Check if background is transparent
  const isTransparent = (bg) => {
    if (!bg) return true;
    if (bg === 'transparent') return true;
    if (bg === 'rgba(0, 0, 0, 0)') return true;
    const parsed = parseColor(bg);
    return parsed && parsed.a < 0.1;
  };
  
  // Sampling seeds in priority order (matches old code exactly)
  const seeds = [
    document.querySelector('#cat-panel-content'),
    document.querySelector('#right-panel-navigation-tabs'),
    document.querySelector('.tab-pane#cat'),
    document.querySelector('.side-panel--empty-state'),
    document.querySelector('.side-panel-header'),
    document.querySelector('[data-testid="app-shell"]'),
    document.querySelector('[data-testid="app"]'),
    document.querySelector('.syn_app'),
    document.body,
    document.documentElement,
  ].filter(Boolean);
  
  // Walk up DOM tree from each seed to find non-transparent background
  for (const seed of seeds) {
    let el = seed;
    let hops = 0;
    while (el && hops < 14) {
      try {
        const style = window.getComputedStyle(el);
        const bg = style.backgroundColor;
        const fg = style.color;
        
        if (!isTransparent(bg)) {
          return {
            bg: bg,
            fg: fg || fallback.fg,
          };
        }
      } catch (e) {
        // Continue to parent
      }
      
      el = el.parentElement;
      hops++;
    }
  }
  
  return fallback;
}

/**
 * Apply Phrase theme to modal elements
 * @param {HTMLElement} dialogEl - Modal dialog element
 * @param {HTMLElement} footerEl - Footer element
 */
function applyBetaModalTheme(dialogEl, footerEl) {
  if (!dialogEl) return;
  
  const { bg, fg } = samplePhraseSurfaceTokens();
  const primaryBlue = samplePhrasePrimaryColor();
  
  // Apply surface tokens
  dialogEl.style.backgroundColor = bg;
  if (fg) dialogEl.style.color = fg;
  
  // Remove footer border for seamless integration
  if (footerEl) {
    footerEl.style.borderTop = '0';
  }
  
  // Set CSS variable for tag highlighting
  document.documentElement.style.setProperty('--pb-phrase-blue', primaryBlue);
}

/**
 * Create theme observer to detect Phrase theme changes
 * @param {HTMLElement} dialogEl - Modal dialog element
 * @returns {MutationObserver} Observer instance
 */
function createThemeObserver(dialogEl) {
  if (!dialogEl || !dialogEl.isConnected) return null;
  
  let debounceTimer = null;
  let lastTokenStr = '';
  const mm = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
  
  const readToken = () => {
    try {
      const root = document.documentElement;
      const body = document.body;
      return [
        root ? (root.className || '') : '',
        root ? (root.getAttribute('data-theme') || '') : '',
        root ? (root.getAttribute('data-color-mode') || '') : '',
        root ? (root.getAttribute('style') || '') : '',
        body ? (body.className || '') : '',
        body ? (body.getAttribute('data-theme') || '') : '',
        body ? (body.getAttribute('data-color-mode') || '') : '',
        body ? (body.getAttribute('style') || '') : '',
        mm ? (mm.matches ? 'dark' : 'light') : '',
      ].join('|');
    } catch (e) {
      return '';
    }
  };
  
  const restyleModal = () => {
    const footer = dialogEl.querySelector('.pb-beta-modal__footer');
    applyBetaModalTheme(dialogEl, footer);
    
    // Update color scheme hint for native controls (scrollbars, form inputs)
    try {
      const scheme = (mm && mm.matches) ? 'dark' : 'light';
      dialogEl.style.colorScheme = scheme;
      
      // Also apply to scrollable viewport to ensure scrollbar theming
      const viewport = dialogEl.querySelector('.pb-tv-viewport');
      if (viewport) viewport.style.colorScheme = scheme;
      
      const prettyEl = dialogEl.querySelector('#pb-tv-pretty-modal');
      if (prettyEl) prettyEl.style.colorScheme = scheme;
      
      // Update global phrase blue color on theme change
      if (window.PB_PhraseBlueManager?.updatePhraseBlue) {
        window.PB_PhraseBlueManager.updatePhraseBlue();
      }
    } catch (e) {}
  };
  
  const scheduleRestyle = () => {
    if (debounceTimer) clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
      const tokenStr = readToken();
      
      if (tokenStr !== lastTokenStr) {
        lastTokenStr = tokenStr;
        restyleModal();
      }
    }, 150);
  };
  
  // Watch documentElement for theme changes
  const observer = new MutationObserver(scheduleRestyle);
  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['class', 'style', 'data-theme', 'data-color-mode'],
  });
  
  // Also watch body element
  if (document.body) {
    observer.observe(document.body, {
      attributes: true,
      attributeFilter: ['class', 'style', 'data-theme', 'data-color-mode'],
    });
  }
  
  // Watch for system color scheme changes
  if (mm) {
    const mmHandler = () => scheduleRestyle();
    if (mm.addEventListener) {
      mm.addEventListener('change', mmHandler);
    } else if (mm.addListener) {
      mm.addListener(mmHandler);
    }
  }
  
  // Initialize token string
  lastTokenStr = readToken();
  
  // Apply initial theme
  restyleModal();
  
  return observer;
}

// Export public API
window.PB_TagViewerModalTheme = {
  parseColor,
  getLuminance,
  getSaturation,
  samplePhrasePrimaryColor,
  samplePhraseSurfaceTokens,
  applyBetaModalTheme,
  createThemeObserver,
};

console.log('[Phrase Buddy] Tag Viewer Modal Theme module loaded');

/**
 * Module: phrase-blue-manager
 * Responsibility: Manage global Phrase blue color as CSS variable.
 *                 Samples Phrase UI's primary blue on first use and exposes it globally
 *                 as --pb-phrase-blue CSS variable. Updates automatically on theme changes.
 *                 All UI elements reference this variable instead of sampling individually.
 * Dependencies: tag-viewer-modal-theme (uses samplePhrasePrimaryColor function)
 */

let isInitialized = false;

/**
 * Initialize phrase blue color as global CSS variable
 * Sets --pb-phrase-blue on document.documentElement (idempotent - safe to call multiple times)
 * Called on-demand when first needed by UI elements
 */
function initializePhraseBlue() {
  // Already initialized, skip
  if (isInitialized) return;
  
  const phraseBlue = window.PB_TagViewerModalTheme?.samplePhrasePrimaryColor?.() || '#2F6FED';
  document.documentElement.style.setProperty('--pb-phrase-blue', phraseBlue);
  isInitialized = true;
}

/**
 * Update phrase blue color in response to theme changes
 * Samples current Phrase blue and updates the global CSS variable
 * Called by theme observer when theme detection runs
 */
function updatePhraseBlue() {
  // Ensure initialization has happened first
  initializePhraseBlue();
  
  const phraseBlue = window.PB_TagViewerModalTheme?.samplePhrasePrimaryColor?.() || '#2F6FED';
  document.documentElement.style.setProperty('--pb-phrase-blue', phraseBlue);
}

/**
 * Get current phrase blue value from CSS variable
 * Returns the computed value or fallback
 * @returns {string} Hex color value
 */
function getPhraseBlue() {
  // Ensure initialization has happened first
  initializePhraseBlue();
  
  const computed = getComputedStyle(document.documentElement).getPropertyValue('--pb-phrase-blue').trim();
  return computed || '#2F6FED';
}

// Export public API
window.PB_PhraseBlueManager = {
  initializePhraseBlue,
  updatePhraseBlue,
  getPhraseBlue,
};

console.log('[Phrase Buddy] Phrase blue manager initialized');

/**
 * Module: tag-viewer-modal-dom
 * Responsibility: Factory functions for creating modal DOM elements.
 *                 Returns fully structured and styled dialog and overlay elements.
 *                 Does NOT insert into DOM or manage lifecycle.
 *                 Does NOT access or store state.
 * Dependencies: tag-viewer-modal-theme (for color sampling)
 */

/**
 * Create modal dialog element with inverted layout (footer, not header)
 * Returns fully populated and styled dialog element ready for insertion.
 * Does NOT insert into DOM.
 * @returns {HTMLElement} Modal dialog element
 */
function createModalDialog() {
  const dialog = document.createElement('div');
  dialog.className = 'pb-beta-modal';
  dialog.setAttribute('role', 'dialog');
  dialog.setAttribute('aria-modal', 'true');
  dialog.setAttribute('aria-label', 'Tag Viewer');
  
  // Core positioning and layout
  dialog.style.position = 'fixed';
  dialog.style.zIndex = '2147481001';  // Above overlay
  dialog.style.display = 'flex';
  dialog.style.flexDirection = 'column';
  dialog.style.pointerEvents = 'auto';
  
  // Visual styling matching Phrase
  dialog.style.borderRadius = '0.375rem';
  dialog.style.border = '1px solid rgba(128,128,128,0.2)';
  dialog.style.boxShadow = '0 0.125rem 0.625rem rgba(0,0,0,0.15)';
  dialog.style.overflow = 'hidden';
  
  // Performance optimizations
  dialog.style.willChange = 'auto';
  dialog.style.backfaceVisibility = 'hidden';
  dialog.style.webkitBackfaceVisibility = 'hidden';
  dialog.style.transform = 'none';
  dialog.style.filter = 'none';
  dialog.style.backdropFilter = 'none';
  
  // Typography rendering
  dialog.style.webkitFontSmoothing = 'subpixel-antialiased';
  dialog.style.mozOsxFontSmoothing = 'auto';
  dialog.style.fontFamily = 'inherit';
  
  // Cursor: default (drag cursor only on footer)
  dialog.style.cursor = 'default';
  
  // Size constraints (only max-width, height handled by resize controller)
  dialog.style.maxWidth = 'calc(100vw - 16px)';
  
  // Load saved geometry or use defaults (bottom-left corner)
  const savedPos = window.PB_TagViewerModalPersistence.getModalPosition();
  const savedSize = window.PB_TagViewerModalPersistence.getModalSize();
  
  const defaultSize = { w: 600, h: 300 };
  const size = savedSize || defaultSize;
  
  dialog.style.width = `${size.w}px`;
  dialog.style.height = `${size.h}px`;
  
  // Positioning will be set after DOM insertion
  
  // Content area (viewport container)
  const content = document.createElement('div');
  content.className = 'pb-beta-modal__content';
  content.style.flex = '1 1 auto';
  content.style.minHeight = '0';
  content.style.height = '100%';  // Ensure content fills dialog height
  content.style.display = 'flex';
  content.style.flexDirection = 'column';
  content.style.overflow = 'hidden';
  
  // Viewport container - uses flex to fill available space
  // This ensures viewport resizes with modal window changes
  const viewport = document.createElement('div');
  viewport.className = 'pb-tv-viewport';
  viewport.style.position = 'relative';
  viewport.style.display = 'flex';
  viewport.style.flexDirection = 'column';
  viewport.style.flex = '1 1 auto';
  viewport.style.minHeight = '0';
  viewport.style.maxHeight = '100%';
  viewport.style.overflow = 'auto';
  viewport.style.gap = '8px';  // Gap between children instead of padding
  viewport.style.paddingLeft = '8px';  // Side padding only
  viewport.style.paddingRight = '8px';
  viewport.style.paddingTop = '8px';
  viewport.style.paddingBottom = '0';
  viewport.style.boxSizing = 'border-box';
  
  // Detect Phrase's current theme by sampling background color luminance
  // Light theme: light backgrounds (luminance > 0.5), dark text
  // Dark theme: dark backgrounds (luminance <= 0.5), light text
  const { bg, fg } = window.PB_TagViewerModalTheme?.samplePhraseSurfaceTokens?.() || { bg: '#ffffff', fg: '#111111' };
  const bgRgb = window.PB_TagViewerModalTheme?.parseColor?.(bg) || { r: 255, g: 255, b: 255 };
  const bgLuminance = window.PB_TagViewerModalTheme?.getLuminance?.(bgRgb) || 0.5;
  const initialScheme = bgLuminance > 0.5 ? 'light' : 'dark';
  viewport.style.colorScheme = initialScheme;
  
  // Pretty display (formatted tags)
  const prettyEl = document.createElement('div');
  prettyEl.id = 'pb-tv-pretty-modal';
  prettyEl.className = 'pb-tv-pretty pb-paragraph';
  prettyEl.setAttribute('tabindex', '0');
  prettyEl.setAttribute('aria-label', 'Converted tag preview');
  prettyEl.style.position = 'relative';
  prettyEl.style.width = '100%';
  prettyEl.style.flex = '1 1 auto';  // Allow growth to fill available space
  prettyEl.style.minHeight = '0';     // Allow shrinking below content size
  prettyEl.style.whiteSpace = 'pre-wrap';
  prettyEl.style.wordBreak = 'break-word';
  prettyEl.style.fontSize = 'var(--pb-tv-font-size, 15px)';
  prettyEl.style.fontWeight = '400';
  prettyEl.style.lineHeight = 'var(--pb-tv-line-height, 25.5px)';
  prettyEl.style.padding = '6px';
  prettyEl.style.borderRadius = '2px';
  prettyEl.style.border = '1px solid rgba(0,0,0,0.08)';
  prettyEl.style.backgroundColor = 'rgba(128,128,128,0.05)';
  prettyEl.style.userSelect = 'text';
  prettyEl.style.pointerEvents = 'auto';
  prettyEl.style.colorScheme = initialScheme;
  
  viewport.appendChild(prettyEl);
  
  // Create quick copy button (identical to TAB version)
  // Note: Click handler added by orchestrator (tag-viewer-modal.js)
  const quickCopy = document.createElement('button');
  quickCopy.type = 'button';
  quickCopy.className = 'pb-tv-quickcopy syn_form-row__label';
  quickCopy.textContent = 'Quick copy';
  quickCopy.setAttribute('aria-label', 'Quick copy');
  quickCopy.style.marginLeft = '-5px';  // Move 5px to the left
  
  viewport.appendChild(quickCopy);
  
  // Hidden output textarea for copy operations
  const outTextarea = document.createElement('textarea');
  outTextarea.id = 'pb-tv-out-modal';
  outTextarea.style.position = 'absolute';
  outTextarea.style.left = '-9999px';
  outTextarea.style.opacity = '0';
  outTextarea.style.pointerEvents = 'none';
  outTextarea.setAttribute('aria-hidden', 'true');
  outTextarea.setAttribute('tabindex', '-1');
  
  viewport.appendChild(outTextarea);
  content.appendChild(viewport);
  dialog.appendChild(content);
  
  // Footer (drag handle with title and actions)
  const footer = document.createElement('div');
  footer.className = 'pb-beta-modal__footer';
  footer.setAttribute('aria-label', 'Drag tag viewer');
  footer.style.display = 'flex';
  footer.style.justifyContent = 'space-between';
  footer.style.alignItems = 'center';
  footer.style.height = '32px';
  footer.style.minHeight = '32px';
  footer.style.padding = '0 10px';
  footer.style.userSelect = 'none';
  footer.style.cursor = 'move';
  footer.style.flexShrink = '0';
  footer.style.borderTop = '0';  // Removed for seamless look
  footer.style.position = 'relative';  // Allow absolute positioning of buttons
  
  // Footer left: title
  const footerLeft = document.createElement('div');
  footerLeft.className = 'pb-beta-modal__title';
  footerLeft.style.display = 'flex';
  footerLeft.style.alignItems = 'center';
  footerLeft.style.gap = '8px';
  
  const titleText = document.createElement('div');
  titleText.className = 'pb-beta-modal__title-text syn_form-row__label';
  titleText.style.fontSize = '14px';
  titleText.style.fontWeight = '700';
  titleText.style.lineHeight = '21px';
  titleText.style.display = 'flex';
  titleText.style.alignItems = 'center';
  titleText.style.cursor = 'move';  // Show move cursor on title
  titleText.textContent = 'Tag Viewer';
  
  footerLeft.appendChild(titleText);
  footer.appendChild(footerLeft);
  
  // Footer right: button actions
  const titleActions = document.createElement('div');
  titleActions.className = 'pb-beta-modal__title-actions';
  titleActions.style.display = 'flex';
  titleActions.style.alignItems = 'center';
  titleActions.style.gap = '6px';
  
  // Hide button (visible in expanded mode)
  const hideBtn = document.createElement('button');
  hideBtn.className = 'syn_btn syn_btn--primary syn_btn--small pb-beta-modal__action-btn';
  hideBtn.textContent = 'Hide';
  hideBtn.style.minWidth = '50px';
  hideBtn.style.padding = '2px 6px';
  hideBtn.style.height = '26px';
  hideBtn.style.cursor = 'pointer';
  hideBtn.style.position = 'absolute';
  hideBtn.style.right = '10px';
  hideBtn.style.top = '50%';
  hideBtn.style.transform = 'translateY(-50%)';
  hideBtn.setAttribute('aria-label', 'Hide tag viewer window');
  
  // Show button (visible in collapsed/pill mode)
  const showBtn = document.createElement('button');
  showBtn.className = 'syn_btn syn_btn--primary syn_btn--small pb-beta-modal__action-btn';
  showBtn.textContent = 'Show';
  showBtn.style.minWidth = '50px';
  showBtn.style.padding = '2px 6px';
  showBtn.style.height = '26px';
  showBtn.style.cursor = 'pointer';
  showBtn.style.display = 'none';  // Hidden initially
  showBtn.style.position = 'absolute';
  showBtn.style.right = '10px';
  showBtn.style.top = '50%';
  showBtn.style.transform = 'translateY(-50%)';
  showBtn.setAttribute('aria-label', 'Show tag viewer window');
  
  titleActions.appendChild(hideBtn);
  titleActions.appendChild(showBtn);
  footer.appendChild(titleActions);
  footer.appendChild(hideBtn);
  footer.appendChild(showBtn);
  
  // Resize handle (top-right corner)
  const resizer = document.createElement('div');
  resizer.className = 'pb-beta-modal__resizer';
  resizer.style.position = 'absolute';
  resizer.style.top = '0';
  resizer.style.right = '0';
  resizer.style.width = '20px';
  resizer.style.height = '20px';
  resizer.style.cursor = 'nesw-resize';
  resizer.style.userSelect = 'none';
  resizer.style.zIndex = '10';
  resizer.style.opacity = '0.5';
  
  // Diagonal grip pattern
  const resizerSvg = `
    <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" style="display: block;">
      <path d="M10 4L20 4L20 14" stroke="rgba(128,128,128,0.55)" stroke-width="2"/>
      <path d="M12 7L17 7L17 12" stroke="rgba(128,128,128,0.55)" stroke-width="2"/>
    </svg>
  `;
  resizer.innerHTML = resizerSvg;
  resizer.style.backgroundImage = 'none';
  resizer.style.backgroundRepeat = 'no-repeat';
  resizer.style.backgroundSize = '100% 100%';
  
  resizer.addEventListener('mouseenter', () => {
    resizer.style.opacity = '0.8';
  });
  resizer.addEventListener('mouseleave', () => {
    resizer.style.opacity = '0.5';
  });
  
  dialog.appendChild(footer);
  dialog.appendChild(resizer);
  
  // Return the dialog and element references for caller to store in state
  dialog._prettyEl = prettyEl;
  dialog._outEl = outTextarea;
  dialog._hideBtn = hideBtn;
  dialog._showBtn = showBtn;
  dialog._content = content;
  dialog._resizer = resizer;
  
  return dialog;
}

/**
 * Create transparent overlay (prevents clicks on page below)
 * Returns fully styled overlay element ready for insertion.
 * Does NOT insert into DOM.
 * @returns {HTMLElement} Overlay element
 */
function createModalOverlay() {
  const overlay = document.createElement('div');
  overlay.className = 'pb-beta-modal-overlay';
  overlay.style.position = 'fixed';
  overlay.style.inset = '0';
  overlay.style.top = '0';
  overlay.style.left = '0';
  overlay.style.right = '0';
  overlay.style.bottom = '0';
  overlay.style.zIndex = '2147481000';  // Just below modal
  overlay.style.backgroundColor = 'transparent';
  overlay.style.pointerEvents = 'none';
  overlay.style.overflow = 'hidden';
  overlay.style.backdropFilter = 'none';
  return overlay;
}

// Export public API
window.PB_TagViewerModalDOM = {
  createModalDialog,
  createModalOverlay,
};

/**
 * Module: tag-viewer-modal-controllers
 * Responsibility: Factory functions for creating modal interaction controllers.
 *                 Returns resize and drag controller objects with .detach() methods.
 *                 Does NOT manage state - main module stores references.
 *                 Does NOT access global state directly.
 * Dependencies: tag-viewer-modal-persistence (for position/size clamping and saving)
 */

/**
 * Create resize controller for modal dialog
 * Resizes from top-right corner, keeping bottom-left anchored.
 * 
 * @param {HTMLElement} dialog - The modal dialog element
 * @param {Object} state - Modal state object { isCollapsed, dialog }
 * @returns {Object} Controller with .detach() method
 */
function createResizeController(dialog, state) {
  const resizer = dialog.querySelector('.pb-beta-modal__resizer');
  if (!resizer) {
    return { detach: () => {} };
  }
  
  resizer.style.touchAction = 'none';
  
  let active = false;
  let startX = 0;
  let startY = 0;
  let startRect = null;
  let anchorLeft = 0;
  let anchorBottom = 0;
  
  const minW = 320;
  const minH = 150;
  const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
  
  const onMove = (e) => {
    if (!active || !startRect) return;
    e.preventDefault();
    
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    
    // Resize from top-right corner, keeping bottom-left anchored
    let nextW = Math.max(minW, startRect.width + dx);
    let nextH = Math.max(minH, startRect.height - dy);
    
    // Calculate new top position to keep bottom edge fixed
    // bottom = top + height, so if we want to keep bottom constant:
    // new_top = bottom - new_height
    const bottom = anchorBottom;
    const nextTop = bottom - nextH;
    
    // Apply clamping to keep in viewport
    const clampedTop = window.PB_TagViewerModalPersistence.clampTop(nextTop, nextH);
    
    dialog.style.width = `${Math.round(nextW)}px`;
    dialog.style.height = `${Math.round(nextH)}px`;
    dialog.style.top = `${Math.round(clampedTop)}px`;
  };
  
  const onUp = () => {
    if (!active) return;
    active = false;
    
    document.removeEventListener('pointermove', onMove, true);
    document.removeEventListener('pointerup', onUp, true);
    document.removeEventListener('pointercancel', onUp, true);
    
    // Save new size and position (position changes during resize to keep bottom anchored)
    try {
      const rect = dialog.getBoundingClientRect();
      window.PB_TagViewerModalPersistence.saveModalSize({ w: Math.round(rect.width), h: Math.round(rect.height) });
      window.PB_TagViewerModalPersistence.saveModalPosition({ left: Math.round(rect.left), top: Math.round(rect.top) });
    } catch (error) {
      console.error('[Tag Viewer Modal] Error saving size/position:', error);
    }
  };
  
  const onDown = (e) => {
    if (e.button !== undefined && e.button !== 0) return;
    if (state.isCollapsed) return;  // Don't resize when collapsed
    
    e.preventDefault();
    e.stopPropagation();
    
    const rect = dialog.getBoundingClientRect();
    // Capture bottom-left anchor (bottom edge position from top of viewport)
    anchorLeft = Math.round(rect.left);
    anchorBottom = Math.round(rect.top + rect.height);  // Bottom edge Y coordinate
    
    startX = e.clientX;
    startY = e.clientY;
    startRect = rect;
    active = true;
    
    document.addEventListener('pointermove', onMove, true);
    document.addEventListener('pointerup', onUp, true);
    document.addEventListener('pointercancel', onUp, true);
    
    try { resizer.setPointerCapture(e.pointerId); } catch (err) {}
  };
  
  resizer.addEventListener('pointerdown', onDown, { capture: true });
  
  return {
    detach: () => {
      resizer.removeEventListener('pointerdown', onDown, { capture: true });
      document.removeEventListener('pointermove', onMove, true);
      document.removeEventListener('pointerup', onUp, true);
      document.removeEventListener('pointercancel', onUp, true);
    }
  };
}

/**
 * Create drag controller for modal dialog
 * Allows dragging the modal by its footer.
 * 
 * @param {HTMLElement} dialog - The modal dialog element
 * @param {Object} state - Modal state object { isCollapsed }
 * @returns {Object} Controller with .detach() method
 */
function createDragController(dialog, state) {
  const footer = dialog.querySelector('.pb-beta-modal__footer');
  if (!footer) {
    return { detach: () => {} };
  }
  
  footer.style.touchAction = 'none';
  
  let active = false;
  let startX = 0;
  let startY = 0;
  let startLeft = 0;
  let startTop = 0;
  let w = 0;
  let h = 0;
  
  const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
  
  const isInteractive = (target) => {
    if (!(target instanceof Element)) return false;
    // Only allow dragging from footer and its children
    if (!target.closest('.pb-beta-modal__footer')) return true;
    // But not from buttons, resizer, or interactive elements within footer
    if (target.closest('.pb-beta-modal__action-btn')) return true;
    if (target.closest('.pb-beta-modal__resizer')) return true;
    if (target.closest('button, input, textarea, select')) return true;
    return false;
  };
  
  const onMove = (e) => {
    if (!active) return;
    e.preventDefault();
    
    const vw = window.innerWidth || 0;
    const vh = window.innerHeight || 0;
    
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    
    let nextLeft = startLeft + dx;
    let nextTop = startTop + dy;
    
    // Keep window fully within viewport - no bleeding at edges
    if (vw) nextLeft = clamp(nextLeft, 0, vw - w);
    // Use clampTop to account for status bar
    nextTop = window.PB_TagViewerModalPersistence.clampTop(nextTop, h);
    
    dialog.style.left = `${Math.round(nextLeft)}px`;
    dialog.style.top = `${Math.round(nextTop)}px`;
  };
  
  const onUp = () => {
    if (!active) return;
    active = false;
    
    document.removeEventListener('pointermove', onMove, true);
    document.removeEventListener('pointerup', onUp, true);
    document.removeEventListener('pointercancel', onUp, true);
    
    // Save new position to appropriate storage based on collapsed state
    try {
      const rect = dialog.getBoundingClientRect();
      const pos = { left: Math.round(rect.left), top: Math.round(rect.top) };
      
      if (state.isCollapsed) {
        window.PB_TagViewerModalPersistence.savePillPosition(pos);
      } else {
        window.PB_TagViewerModalPersistence.saveModalPosition(pos);
      }
    } catch (error) {
      console.error('[Tag Viewer Modal] Error saving position:', error);
    }
  };
  
  const onDown = (e) => {
    if (e.button !== undefined && e.button !== 0) return;
    if (isInteractive(e.target)) return;
    
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    
    const rect = dialog.getBoundingClientRect();
    w = rect.width;
    h = rect.height;
    
    startX = e.clientX;
    startY = e.clientY;
    startLeft = rect.left;
    startTop = rect.top;
    
    active = true;
    
    document.addEventListener('pointermove', onMove, true);
    document.addEventListener('pointerup', onUp, true);
    document.addEventListener('pointercancel', onUp, true);
    
    try { footer.setPointerCapture(e.pointerId); } catch (err) {}
  };
  
  footer.addEventListener('pointerdown', onDown, { capture: true });
  
  return {
    detach: () => {
      footer.removeEventListener('pointerdown', onDown, { capture: true });
      document.removeEventListener('pointermove', onMove, true);
      document.removeEventListener('pointerup', onUp, true);
      document.removeEventListener('pointercancel', onUp, true);
    }
  };
}

// Export public API
window.PB_TagViewerModalControllers = {
  createResizeController,
  createDragController,
};

/**
 * Module: tag-viewer-modal
 * Responsibility: Orchestrate floating modal window for Tag Viewer.
 *                 Implements drag and resize controllers, hide/show pill mode.
 *                 Manages modal lifecycle, state, and event coordination.
 * Dependencies: tag-viewer-modal-loader, tag-viewer-modal-persistence,
 *               tag-viewer-modal-theme, tag-viewer-modal-dom, tag-viewer-modal-controllers,
 *               tag-viewer-logic, ui-theme, tool-state-manager
 */

// Modal runtime state
const PB_TV_MODAL_STATE = {
  dialog: null,
  overlay: null,
  resizeController: null,
  dragController: null,
  isCollapsed: false,
  prettyEl: null,
  outEl: null,
  intervalId: null,
  wasOpenBeforeDisable: false,  // Track if modal was open when tool disabled
  lastDisableTime: 0,  // Timestamp of last disable to ignore immediate re-enables
  hasWaitedForInitialPhrase: false,  // Track if we've already waited for phrase loaders on init
};

// Attach tool enable/disable listeners IMMEDIATELY (before any functions)
// This ensures they're registered early enough to catch the first disable event
document.addEventListener('tool:deactivated', (e) => {
  if (e.detail?.toolId === 'phrase-tag-viewer') {
    // Save state before closing: was the modal open?
    PB_TV_MODAL_STATE.wasOpenBeforeDisable = PB_TV_MODAL_STATE.dialog && PB_TV_MODAL_STATE.dialog.isConnected;
    // Mark timestamp to ignore immediate automatic re-enables
    PB_TV_MODAL_STATE.lastDisableTime = Date.now();
    // Close modal when tag viewer tool is disabled
    closeModal();
  }
});

document.addEventListener('tool:activated', (e) => {
  if (e.detail?.toolId === 'phrase-tag-viewer') {
    const timeSinceDisable = Date.now() - PB_TV_MODAL_STATE.lastDisableTime;
    
    // Reset the first-load flag so next time we open it waits for Phrase again
    PB_TV_MODAL_STATE.hasWaitedForInitialPhrase = false;
    
    // If this is an immediate automatic re-enable (within 100ms), ignore it
    if (timeSinceDisable < 100) {
      return;
    }
    
    // If modal was open before disabling, reopen it now
    if (PB_TV_MODAL_STATE.wasOpenBeforeDisable) {
      PB_TV_MODAL_STATE.wasOpenBeforeDisable = false;  // Reset flag
      openModal();
    }
  }
});

/**
 * Attach resize controller to modal dialog
 * Resizes from top-right corner
 */
/**
 * Attach resize controller to modal dialog
 * Uses factory from tag-viewer-modal-controllers
 */
function attachResizeController() {
  if (PB_TV_MODAL_STATE.resizeController) return;
  
  const dialog = PB_TV_MODAL_STATE.dialog;
  if (!dialog || !dialog.isConnected) return;
  
  const controller = window.PB_TagViewerModalControllers.createResizeController(
    dialog,
    PB_TV_MODAL_STATE
  );
  
  PB_TV_MODAL_STATE.resizeController = controller;
}

/**
 * Attach drag controller to modal footer
 * Uses factory from tag-viewer-modal-controllers
 */
function attachDragController() {
  if (PB_TV_MODAL_STATE.dragController) return;
  
  const dialog = PB_TV_MODAL_STATE.dialog;
  if (!dialog || !dialog.isConnected) return;
  
  const controller = window.PB_TagViewerModalControllers.createDragController(
    dialog,
    PB_TV_MODAL_STATE
  );
  
  PB_TV_MODAL_STATE.dragController = controller;
}

/**
 * Toggle between expanded and collapsed (pill) mode
 */

function toggleCollapsed() {
  const dialog = PB_TV_MODAL_STATE.dialog;
  if (!dialog) return;
  
  const content = dialog.querySelector('.pb-beta-modal__content');
  const resizer = dialog.querySelector('.pb-beta-modal__resizer');
  const hideBtn = dialog.querySelector('.pb-beta-modal__action-btn[aria-label="Hide tag viewer window"]');
  const showBtn = dialog.querySelector('.pb-beta-modal__action-btn[aria-label="Show tag viewer window"]');
  
  if (!content || !resizer) return;
  
  PB_TV_MODAL_STATE.isCollapsed = !PB_TV_MODAL_STATE.isCollapsed;
  
  // Save collapsed state to storage
  window.PB_TagViewerModalPersistence.saveModalCollapsedState(PB_TV_MODAL_STATE.isCollapsed);
  
  if (PB_TV_MODAL_STATE.isCollapsed) {
    // Capture current bottom-left position before collapsing
    const rect = dialog.getBoundingClientRect();
    const currentBottom = rect.top + rect.height;
    const currentLeft = rect.left;
    
    // Add collapsed class for pill mode
    dialog.classList.add('pb-beta-modal--collapsed');
    
    // Hide content and resizer
    content.style.display = 'none';
    resizer.style.display = 'none';
    
    // Swap buttons
    if (hideBtn) hideBtn.style.display = 'none';
    if (showBtn) showBtn.style.display = 'block';
    
    // Shrink footer for pill mode
    const footer = dialog.querySelector('.pb-beta-modal__footer');
    if (footer) {
      footer.style.height = '30px';
      footer.style.minHeight = '30px';
      footer.style.padding = '0 10px';
    }
    
    // Pill styling - collapse to footer size only
    dialog.style.height = '30px';
    dialog.style.width = 'auto';
    dialog.style.minWidth = '170px';
    dialog.style.maxWidth = 'fit-content';
    dialog.style.borderRadius = '999px';
    dialog.style.overflow = 'visible';
    
    // Detach resize controller (not needed for pill)
    if (PB_TV_MODAL_STATE.resizeController) {
      PB_TV_MODAL_STATE.resizeController.detach();
      PB_TV_MODAL_STATE.resizeController = null;
    }
    
    // Adjust position to keep bottom-left corner at same place
    requestAnimationFrame(() => {
      if (!dialog.isConnected) return;
      const pillRect = dialog.getBoundingClientRect();
      const pillHeight = pillRect.height || 30;
      
      // Calculate new top to maintain same bottom position
      const newTop = currentBottom - pillHeight;
      const clampedTop = window.PB_TagViewerModalPersistence.clampTop(newTop, pillHeight);
      
      dialog.style.left = `${Math.round(currentLeft)}px`;
      dialog.style.top = `${Math.round(clampedTop)}px`;
      
      // Save pill position
      const pillPos = { left: Math.round(currentLeft), top: Math.round(clampedTop) };
      window.PB_TagViewerModalPersistence.savePillPosition(pillPos);
      dialog.style.top = `${Math.round(clampedTop)}px`;
    });
  } else {
    // Capture current bottom-left position of pill before expanding
    const rect = dialog.getBoundingClientRect();
    const currentBottom = rect.top + rect.height;
    const currentLeft = rect.left;
    
    // Remove collapsed class
    dialog.classList.remove('pb-beta-modal--collapsed');
    
    // Show content and resizer
    content.style.display = 'flex';
    resizer.style.display = 'block';
    
    // Swap buttons
    if (hideBtn) hideBtn.style.display = 'block';
    if (showBtn) showBtn.style.display = 'none';
    
    // Restore footer size
    const footer = dialog.querySelector('.pb-beta-modal__footer');
    if (footer) {
      footer.style.height = '32px';
      footer.style.minHeight = '32px';
      footer.style.padding = '0 10px';
    }
    
    // Restore expanded styling
    dialog.style.borderRadius = '0.375rem';
    dialog.style.overflow = 'hidden';
    dialog.style.minWidth = '';
    dialog.style.maxWidth = '';  // Clear pill mode constraints
    
    // Restore saved size
    const savedSize = window.PB_TagViewerModalPersistence.getModalSize();
    const expandedHeight = savedSize ? savedSize.h : 300;
    const expandedWidth = savedSize ? savedSize.w : 600;
    
    dialog.style.width = `${expandedWidth}px`;
    dialog.style.height = `${expandedHeight}px`;
    
    // Calculate new top to maintain same bottom position (expand upward from bottom-left)
    const newTop = currentBottom - expandedHeight;
    const clampedTop = window.PB_TagViewerModalPersistence.clampTop(newTop, expandedHeight);
    
    dialog.style.left = `${Math.round(currentLeft)}px`;
    dialog.style.top = `${Math.round(clampedTop)}px`;
    
    // Save the expanded position
    const expandedPos = { left: Math.round(currentLeft), top: Math.round(clampedTop) };
    window.PB_TagViewerModalPersistence.saveModalPosition(expandedPos);
    
    // Re-attach resize controller with fresh state when expanding
    if (PB_TV_MODAL_STATE.resizeController) {
      PB_TV_MODAL_STATE.resizeController.detach();
      PB_TV_MODAL_STATE.resizeController = null;
    }
    attachResizeController();
    
    // Update viewport content
    updateModalViewport();
  }
}

/**
 * Update modal viewport with current tag content
 * Now uses centralized renderAllViewports instead of individual updates
 */
function updateModalViewport() {
  // Centralized renderer handles all viewports
  if (window.PB_TagViewerUI?.renderAllViewports) {
    window.PB_TagViewerUI.renderAllViewports();
  }
}

/**
 * Open modal window
 */
function openModal() {
  if (PB_TV_MODAL_STATE.dialog && PB_TV_MODAL_STATE.dialog.isConnected) {
    return;  // Already open
  }
  
  // Function to create and display modal
  const createAndShowModal = () => {
    const overlay = window.PB_TagViewerModalDOM.createModalOverlay();
    const dialog = window.PB_TagViewerModalDOM.createModalDialog();
    
    document.body.appendChild(overlay);
    document.body.appendChild(dialog);
    
    PB_TV_MODAL_STATE.overlay = overlay;
    PB_TV_MODAL_STATE.dialog = dialog;
    PB_TV_MODAL_STATE.isCollapsed = false;
    
    // Extract element references from dialog properties
    PB_TV_MODAL_STATE.prettyEl = dialog._prettyEl;
    PB_TV_MODAL_STATE.outEl = dialog._outEl;
    
    // Set up quick copy button with tooltip feedback
    const quickCopy = dialog.querySelector('.pb-tv-quickcopy');
    if (quickCopy && PB_TV_MODAL_STATE.outEl && PB_TV_MODAL_STATE.prettyEl) {
      quickCopy.addEventListener('click', async (e) => {
        e.preventDefault();
        const src = PB_TV_MODAL_STATE.outEl?.value ?? PB_TV_MODAL_STATE.prettyEl?.textContent ?? '';
        const text = String(src || '');
        if (!text) return;

        try {
          await navigator.clipboard.writeText(text);
          if (window.PB_TagViewerUI?.showTagViewerTooltip) {
            window.PB_TagViewerUI.showTagViewerTooltip(quickCopy, 'Viewer text copied');
          }
        } catch (err) {
          console.warn('[Tag Viewer Modal] Copy failed:', err);
        }
      });
    }
    
    // Set up hide/show button click handlers
    const hideBtn = dialog.querySelector('.pb-beta-modal__action-btn[aria-label="Hide tag viewer window"]');
    const showBtn = dialog.querySelector('.pb-beta-modal__action-btn[aria-label="Show tag viewer window"]');
    if (hideBtn) {
      hideBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        toggleCollapsed();
      });
    }
    if (showBtn) {
      showBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        toggleCollapsed();
      });
    }
    
    // Apply positioning after DOM insertion (requestAnimationFrame ensures layout is calculated)
    requestAnimationFrame(() => {
      // Calculate bottom-left positioning
      const savedPos = window.PB_TagViewerModalPersistence.getModalPosition();
      const savedSize = window.PB_TagViewerModalPersistence.getModalSize();
      const savedCollapsedState = window.PB_TagViewerModalPersistence.getModalCollapsedState();
      const savedPillPos = window.PB_TagViewerModalPersistence.getPillPosition();
      
      const margin = 8;
      const vw = window.innerWidth || 0;
      const vh = window.innerHeight || 0;
      const rect = dialog.getBoundingClientRect();
      
      // Use saved size for accurate positioning calculations
      const expandedHeight = savedSize ? savedSize.h : (rect.height || 300);
      const expandedWidth = savedSize ? savedSize.w : (rect.width || 600);
      
      // Calculate initial position - use pill position if should be collapsed
      let left, top;
      
      if (savedCollapsedState === true && savedPillPos && Number.isFinite(savedPillPos.left) && Number.isFinite(savedPillPos.top)) {
        // Restore pill position
        left = savedPillPos.left;
        top = savedPillPos.top;
      } else if (savedPos && Number.isFinite(savedPos.left) && Number.isFinite(savedPos.top)) {
        // Restore saved expanded position
        left = savedPos.left;
        top = savedPos.top;
      } else {
        // Default to bottom-left corner
        left = margin;
        const bottomLimit = window.PB_TagViewerModalPersistence.getBottomLimit();
        top = Math.max(margin, bottomLimit - expandedHeight);
      }
      
      // Clamp to viewport - use correct height based on state
      const clampHeight = savedCollapsedState === true ? 30 : expandedHeight;
      const maxLeft = Math.max(margin, vw - expandedWidth - margin);
      left = Math.max(margin, Math.min(left, maxLeft));
      top = window.PB_TagViewerModalPersistence.clampTop(top, clampHeight);
      
      dialog.style.left = `${Math.round(left)}px`;
      dialog.style.top = `${Math.round(top)}px`;
      
      // Apply theme
      const footer = dialog.querySelector('.pb-beta-modal__footer');
      window.PB_TagViewerModalTheme.applyBetaModalTheme(dialog, footer);
      
      // Setup theme observer
      PB_TV_MODAL_STATE.themeObserver = window.PB_TagViewerModalTheme.createThemeObserver(dialog);
      
      // Register this viewport with the centralized renderer
      const prettyEl = PB_TV_MODAL_STATE.prettyEl;
      const outEl = PB_TV_MODAL_STATE.outEl;
      if (prettyEl && outEl && window.PB_TagViewerUI?.registerViewport) {
        window.PB_TagViewerUI.registerViewport('modal', prettyEl, outEl);
      }
      
      // Apply collapsed state styling if needed (without toggling, which causes jump)
      if (savedCollapsedState === true) {
        const content = dialog.querySelector('.pb-beta-modal__content');
        const resizer = dialog.querySelector('.pb-beta-modal__resizer');
        const hideBtn = dialog.querySelector('.pb-beta-modal__action-btn[aria-label="Hide tag viewer window"]');
        const showBtn = dialog.querySelector('.pb-beta-modal__action-btn[aria-label="Show tag viewer window"]');
        
        PB_TV_MODAL_STATE.isCollapsed = true;
        dialog.classList.add('pb-beta-modal--collapsed');
        
        if (content) content.style.display = 'none';
        if (resizer) resizer.style.display = 'none';
        if (hideBtn) hideBtn.style.display = 'none';
        if (showBtn) showBtn.style.display = 'block';
        
        const footer = dialog.querySelector('.pb-beta-modal__footer');
        if (footer) {
          footer.style.height = '30px';
          footer.style.minHeight = '30px';
          footer.style.padding = '0 10px';
        }
        
        dialog.style.height = '30px';
        dialog.style.width = 'auto';
        dialog.style.minWidth = '170px';
        dialog.style.maxWidth = 'fit-content';
        dialog.style.borderRadius = '999px';
        dialog.style.overflow = 'visible';
        
        // Attach drag controller for pill (but not resize)
        attachDragController();
      } else {
        // Expanded state - attach both controllers
        attachResizeController();
        attachDragController();
        updateModalViewport();
      }
      
      // Set up interval for live updates using centralized renderer
      if (!PB_TV_MODAL_STATE.intervalId) {
        PB_TV_MODAL_STATE.intervalId = setInterval(() => {
          if (!PB_TV_MODAL_STATE.isCollapsed && window.PB_TagViewerUI?.renderAllViewports) {
            window.PB_TagViewerUI.renderAllViewports();
          }
        }, 350);
      }
    });
  };
  
  // Only wait for Phrase loaders on first load, not on re-enabling via checkbox
  if (!PB_TV_MODAL_STATE.hasWaitedForInitialPhrase) {
    window.PB_TagViewerModalLoader.waitForPhraseLoaders(() => {
      PB_TV_MODAL_STATE.hasWaitedForInitialPhrase = true;
      createAndShowModal();
    });
  } else {
    // Already waited before, show immediately
    createAndShowModal();
  }
}

/**
 * Close modal window
 */
function closeModal() {
  // Unregister this viewport from the centralized renderer
  if (window.PB_TagViewerUI?.unregisterViewport) {
    window.PB_TagViewerUI.unregisterViewport('modal');
  }
  
  // Disconnect theme observer
  if (PB_TV_MODAL_STATE.themeObserver) {
    PB_TV_MODAL_STATE.themeObserver.disconnect();
    PB_TV_MODAL_STATE.themeObserver = null;
  }
  
  // Detach controllers
  if (PB_TV_MODAL_STATE.resizeController) {
    PB_TV_MODAL_STATE.resizeController.detach();
    PB_TV_MODAL_STATE.resizeController = null;
  }
  
  if (PB_TV_MODAL_STATE.dragController) {
    PB_TV_MODAL_STATE.dragController.detach();
    PB_TV_MODAL_STATE.dragController = null;
  }
  
  // Clear interval
  if (PB_TV_MODAL_STATE.intervalId) {
    clearInterval(PB_TV_MODAL_STATE.intervalId);
    PB_TV_MODAL_STATE.intervalId = null;
  }
  
  // Remove from DOM
  if (PB_TV_MODAL_STATE.dialog && PB_TV_MODAL_STATE.dialog.parentNode) {
    PB_TV_MODAL_STATE.dialog.parentNode.removeChild(PB_TV_MODAL_STATE.dialog);
  }
  
  if (PB_TV_MODAL_STATE.overlay && PB_TV_MODAL_STATE.overlay.parentNode) {
    PB_TV_MODAL_STATE.overlay.parentNode.removeChild(PB_TV_MODAL_STATE.overlay);
  }
  
  PB_TV_MODAL_STATE.dialog = null;
  PB_TV_MODAL_STATE.overlay = null;
  PB_TV_MODAL_STATE.prettyEl = null;
  PB_TV_MODAL_STATE.outEl = null;
  PB_TV_MODAL_STATE.isCollapsed = false;
}

/**
 * Toggle modal window visibility
 */
function toggleModal() {
  if (PB_TV_MODAL_STATE.dialog && PB_TV_MODAL_STATE.dialog.isConnected) {
    closeModal();
  } else {
    openModal();
  }
}

// Export public API
window.PB_TagViewerModal = {
  openModal,
  closeModal,
  toggleModal,
  updateViewport: updateModalViewport,
};

/**
 * Module: tag-click-handler
 * Responsibility: Handle tag clicking functionality - detect tag clicks in editor,
 *                 switch to Tag Viewer tab, display clicked tag content.
 *                 Detect expanded tag mode and disable tag clicking when active.
 *                 Manage UI state (greyed out checkbox, tooltip, cursor).
 * Dependencies: tag-viewer-logic, tag-viewer-ui, tool-state-manager
 */

// Tag click runtime state
const PB_TAGCLICK_STATE = {
  forcedOff: false, // True when tags are expanded (Ctrl+Shift+E)
  checkboxLabelEl: null,
  expandedTagGuardWired: false,
  tooltipHandlers: null,
  clickHandlersWired: false,
};

/**
 * Check if tag clicking is currently forced off due to expanded tags.
 * @returns {boolean} True if tags are expanded and clicking should be disabled
 */
function isTagClickForcedOff() {
  return PB_TAGCLICK_STATE.forcedOff;
}

/**
 * Check if tag clicking is effectively enabled (user enabled + not forced off).
 * @returns {boolean} True if tag clicking should work
 */
function isTagClickEffectivelyEnabled() {
  // Check if Tag Viewer tool is enabled and tag clicking checkbox is checked
  const toolEnabled = window.PB_ToolStateManager?.getToolState?.('phrase-tag-viewer');
  const clickEnabled = window.PB_ToolStateManager?.getToolState?.('pb.tags.clickToViewer.v1');
  return !!toolEnabled && !!clickEnabled && !isTagClickForcedOff();
}

/**
 * Apply cursor styling based on tag click state.
 * Adds data attribute to enable CSS cursor:pointer on tags.
 */
function applyTagClickCursorUi() {
  const enabled = isTagClickEffectivelyEnabled();
  if (enabled) {
    document.documentElement.dataset.pbTagClicking = '1';
  } else {
    delete document.documentElement.dataset.pbTagClicking;
  }
}

/**
 * Detect if document has expanded tags (Ctrl+Shift+E mode).
 * @param {Document} doc - Document to check
 * @returns {boolean} True if any tags are expanded
 */
function isExpandedTagModeInDoc(doc) {
  try {
    if (!doc || !doc.querySelector) return false;
    return !!doc.querySelector('.tag_content.tag_expanded');
  } catch (e) {
    return false;
  }
}

/**
 * Refresh the tag clicking checkbox UI state.
 * Greys out and disables when tags are expanded.
 * Shows tooltip explaining why it's disabled.
 */
function refreshTagClickCheckboxUi() {
  // Update cursor affordance
  applyTagClickCursorUi();

  // Find the checkbox label element
  const labelEl = PB_TAGCLICK_STATE.checkboxLabelEl;
  if (!labelEl || !labelEl.isConnected) return;

  const input = labelEl.querySelector('input.syn_checkbox-input');
  const forcedOff = isTagClickForcedOff();

  // Tooltip message for when forced off
  const tooltipMsg = 'Tag clicking unavailable when tags are expanded. Collapse tags to restore.';
  const pickAnchor = () => labelEl.querySelector('.syn_checkbox__label') || labelEl;

  // Wire tooltip handlers if element changed
  try {
    if (PB_TAGCLICK_STATE.tooltipHandlers?.element !== labelEl) {
      // Remove old handlers
      if (PB_TAGCLICK_STATE.tooltipHandlers) {
        const old = PB_TAGCLICK_STATE.tooltipHandlers;
        old.element?.removeEventListener('pointerenter', old.onEnter, true);
        old.element?.removeEventListener('pointerleave', old.onLeave, true);
        old.element?.removeEventListener('focusin', old.onFocus, true);
        old.element?.removeEventListener('focusout', old.onBlur, true);
      }

      // Create new handlers
      const onEnter = () => {
        if (!isTagClickForcedOff()) return;
        const anchor = pickAnchor();
        if (window.PB_TooltipManager?.show) {
          window.PB_TooltipManager.show(anchor, tooltipMsg);
        }
      };

      const onLeave = () => {
        window.PB_TooltipManager?.remove?.();
      };

      const onFocus = () => {
        if (!isTagClickForcedOff()) return;
        const anchor = pickAnchor();
        if (window.PB_TooltipManager?.show) {
          window.PB_TooltipManager.show(anchor, tooltipMsg);
        }
      };

      const onBlur = () => {
        window.PB_TooltipManager?.remove?.();
      };

      labelEl.addEventListener('pointerenter', onEnter, true);
      labelEl.addEventListener('pointerleave', onLeave, true);
      labelEl.addEventListener('focusin', onFocus, true);
      labelEl.addEventListener('focusout', onBlur, true);

      PB_TAGCLICK_STATE.tooltipHandlers = {
        element: labelEl,
        onEnter,
        onLeave,
        onFocus,
        onBlur,
      };
    }
  } catch (e) {
    console.error('[Tag Click] Error wiring tooltip handlers:', e);
  }

  // Disable input and apply visual effects when forced off
  if (input) input.disabled = forcedOff;
  
  // Preserve visual checked state even when disabled
  const savedState = window.PB_ToolStateManager?.getToolState?.('pb.tags.clickToViewer.v1');
  if (labelEl.classList.contains('syn_checkbox')) {
    if (savedState) {
      labelEl.classList.add('syn_checkbox--checked');
    } else {
      labelEl.classList.remove('syn_checkbox--checked');
    }
  }

  // Apply greyed-out styling when forced off
  labelEl.style.opacity = forcedOff ? '0.55' : '';
  labelEl.style.filter = forcedOff ? 'grayscale(0.25)' : '';
  labelEl.style.cursor = forcedOff ? 'not-allowed' : '';
}

/**
 * Debounce helper function.
 * @param {Function} func - Function to debounce
 * @param {number} wait - Wait time in ms
 * @returns {Function} Debounced function
 */
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/**
 * Recompute if tag clicking should be forced off based on expanded tag state.
 */
function recomputeTagClickForcedOff() {
  // Check main document for expanded tags
  const expanded = isExpandedTagModeInDoc(document);
  const nextForced = !!expanded;

  if (PB_TAGCLICK_STATE.forcedOff === nextForced) {
    // No change
    return;
  }

  PB_TAGCLICK_STATE.forcedOff = nextForced;
  refreshTagClickCheckboxUi();
}

/**
 * Wire mutation observer to detect expanded tag mode changes.
 * Watches for class="tag_expanded" appearing/disappearing.
 */
function wireExpandedTagModeGuard() {
  if (PB_TAGCLICK_STATE.expandedTagGuardWired) return;
  PB_TAGCLICK_STATE.expandedTagGuardWired = true;

  const recompute = debounce(() => recomputeTagClickForcedOff(), 60);

  // Watch for class changes (Phrase toggles tag_expanded)
  const observer = new MutationObserver(() => recompute());
  observer.observe(document.body || document.documentElement, {
    subtree: true,
    childList: true,
    attributes: true,
    attributeFilter: ['class'],
  });

  // Also trigger on common interaction points
  document.addEventListener('pointerup', recompute, true);
  document.addEventListener('click', recompute, true);
  document.addEventListener('keydown', recompute, true);

  // Initial state check
  recompute();
}

/**
 * Normalize tag element from click target.
 * @param {Element} el - Element to normalize
 * @returns {Element|null} Normalized tag element
 */
function normalizeTagEl(el) {
  const tagWrapperSel = '.te_tag,[data-testid="tag"],[data-tag],[data-tag-type]';
  
  if (!el || el.nodeType !== 1) return null;
  if (el.matches?.('.tag_content')) return el.closest?.(tagWrapperSel) || el;
  if (el.matches?.(tagWrapperSel)) return el;
  return el.closest?.(tagWrapperSel) || null;
}

/**
 * Find tag element from click event.
 * Uses multiple strategies including composedPath and elementFromPoint.
 * @param {Document} doc - Document context
 * @param {Event} e - Click event
 * @returns {Element|null} Tag element if found
 */
function findTagElFromEvent(doc, e) {
  const tagWrapperSel = '.te_tag,[data-testid="tag"],[data-tag],[data-tag-type]';
  const tagHitSel = `${tagWrapperSel},.tag_content`;

  // Try event target first
  const target = e?.target;
  if (target && target.closest) {
    const closest = target.closest(tagHitSel);
    const normalized = normalizeTagEl(closest);
    if (normalized) return normalized;
  }

  // Try composed path
  try {
    const path = (typeof e.composedPath === 'function') ? e.composedPath() : [];
    for (const node of path) {
      if (node && node.nodeType === 1 && node.matches?.(tagHitSel)) {
        const normalized = normalizeTagEl(node);
        if (normalized) return normalized;
      }
    }
  } catch (err) {
    // Ignore
  }

  // Try elementFromPoint with offset grid
  const cx = Number(e?.clientX);
  const cy = Number(e?.clientY);
  if (!Number.isFinite(cx) || !Number.isFinite(cy)) return null;

  const offsets = [
    [0, 0],
    [-2, 0], [2, 0], [0, -2], [0, 2],
    [-4, 0], [4, 0], [0, -4], [0, 4],
    [-6, 0], [6, 0], [0, -6], [0, 6],
    [-7, -1], [7, -1], [-7, 1], [7, 1],
  ];

  const elementFromPoint = (doc && doc.elementFromPoint) 
    ? doc.elementFromPoint.bind(doc) 
    : document.elementFromPoint.bind(document);

  for (const [dx, dy] of offsets) {
    const el = elementFromPoint(cx + dx, cy + dy);
    const closest = el && el.closest ? el.closest(tagHitSel) : null;
    const normalized = normalizeTagEl(closest);
    if (normalized) return normalized;
  }

  return null;
}

/**
 * Handle tag click event.
 * Switches to Buddy tab, Tag Viewer tab, and displays tag content.
 * @param {Document} doc - Document context
 * @param {Event} e - Click event
 */
function handleTagClick(doc, e) {
  if (!isTagClickEffectivelyEnabled()) {
    return;
  }

  // Defensive: check if current doc has expanded tags
  try {
    if (isExpandedTagModeInDoc(doc)) {
      return;
    }
  } catch (err) {
    // Ignore
  }

  const tagEl = findTagElFromEvent(doc, e);
  
  // Find segment row - can be from tag or from target/source click
  const segSel = '.twe_segment,[data-testid="segment"]';
  const row = tagEl?.closest?.(segSel) || e?.target?.closest?.(segSel) || null;
  if (!row) {
    return;
  }

  // Determine if click was in source or target
  const sourceSel = '.twe_source,[data-testid="source"]';
  const targetSel = '.twe_target,[data-testid="target"]';
  
  const srcFromTarget = e?.target?.closest?.(sourceSel) || null;
  const tgtFromTarget = e?.target?.closest?.(targetSel) || null;
  const srcFromTag = tagEl?.closest?.(sourceSel) || null;
  const tgtFromTag = tagEl?.closest?.(targetSel) || null;

  const inSource = !!(srcFromTarget || srcFromTag) && !(tgtFromTarget || tgtFromTag);
  const inTarget = !!(tgtFromTarget || tgtFromTag) && !(srcFromTarget || srcFromTag);

  // Set side override if in source with a tag
  if (inSource && tagEl && window.PB_TagViewerLogic?.setSideOverride) {
    window.PB_TagViewerLogic.setSideOverride('source', row);
  } else if (inTarget && window.PB_TagViewerLogic?.clearSideOverride) {
    // Clear override when user clicks target side (even without a tag)
    window.PB_TagViewerLogic.clearSideOverride();
  } else if (inSource && !tagEl && window.PB_TagViewerLogic?.clearSideOverride) {
    // Clear override if clicked source but no tag found
    window.PB_TagViewerLogic.clearSideOverride();
  }

  // Only proceed with tab switching if we actually found a tag
  if (!tagEl) return;

  // Defer actual tab switching to next tick
  window.setTimeout(() => {
    try {
      // Activate segment if not already active
      const activeSel = '.twe_segment.twe_active, .twe_segment.twe_active_background, [data-testid="segment"][data-selected="true"]';
      const active = document.querySelector(activeSel);
      if (!active || active !== row) {
        row.scrollIntoView?.({ block: 'nearest' });
        row.click?.();
      }
    } catch (err) {
      console.error('[Tag Click] Error in segment activation:', err);
    }

    // Find Buddy tab and pane
    const buddyTab = document.getElementById('phrase-buddy-tab');
    const buddyPane = document.getElementById('phrase-buddy-pane');
    if (!buddyTab || !buddyPane) {
      return;
    }

    // Open Buddy pane directly using the API instead of clicking
    try {
      // Find the required containers for openBuddy API
      const tabsContainer = document.querySelector('#right-panel-navigation-tabs') || buddyTab.parentElement;
      const panesContainer = document.querySelector('#right-panel-navigation .tab-content') || buddyPane.parentElement;
      
      // Call openBuddy directly - it has internal guards against double-opening
      if (window.PB_UiState?.openBuddy && tabsContainer && panesContainer) {
        window.PB_UiState.openBuddy(buddyTab, buddyPane, panesContainer, tabsContainer);
      }

      // After opening Buddy, activate Tag Viewer module within it
      window.setTimeout(() => {
        // Find the subpanels container - it's a direct child of Buddy pane or use the ID directly
        const subpanelsById = document.getElementById('pb-buddy-subpanels');
        const panesContainer = subpanelsById || buddyPane.querySelector('[id^="pb-buddy-"]') || buddyPane.parentElement;
        
        if (panesContainer && window.PB_PaneModules?.setActiveModule) {
          // Use the pane modules API to activate TAG_VIEWER
          window.PB_PaneModules.setActiveModule('phrase-tag-viewer', panesContainer);
        }

        // Trigger viewport update
        const prettyEl = document.querySelector('#pb-tv-pretty-inline');
        const outEl = document.querySelector('#pb-tv-out-inline');
        if (prettyEl && outEl && window.PB_TagViewerUI?.updateTagViewerViewport) {
          window.PB_TagViewerUI.updateTagViewerViewport(prettyEl, outEl);
        }
      }, 100);
    } catch (err) {
      console.error('[Tag Click] Error switching to Tag Viewer:', err);
    }
  }, 0);
}

/**
 * Wire tag click handlers to document.
 * Listens for pointerdown and click events on tags.
 */
function wireTagClickHandlers() {
  if (PB_TAGCLICK_STATE.clickHandlersWired) return;
  PB_TAGCLICK_STATE.clickHandlersWired = true;

  const handler = (e) => handleTagClick(document, e);

  document.addEventListener('pointerdown', handler, true);
  document.addEventListener('click', handler, true);

}

/**
 * Initialize tag clicking functionality.
 * Wires event handlers and sets up expanded tag mode guard.
 * @param {Element} checkboxLabelEl - Checkbox label element for UI updates
 */
function initializeTagClick(checkboxLabelEl) {
  PB_TAGCLICK_STATE.checkboxLabelEl = checkboxLabelEl;

  wireExpandedTagModeGuard();
  wireTagClickHandlers();
  refreshTagClickCheckboxUi();

}

/**
 * Disable tag clicking completely (called when Tag Viewer tool is disabled).
 * Forces off state to prevent any tag clicking functionality.
 * @returns {void}
 */
function disableTagClicking() {
  console.log('[Tag Click] Disabling tag clicking - Tag Viewer tool is disabled');
  
  // Force off state to prevent clicking
  PB_TAGCLICK_STATE.forcedOff = true;
  
  // Update UI to reflect disabled state
  refreshTagClickCheckboxUi();
}

// Export public API
window.PB_TagClickHandler = {
  initialize: initializeTagClick,
  refreshUi: refreshTagClickCheckboxUi,
  isEffectivelyEnabled: isTagClickEffectivelyEnabled,
  applyTagClickCursorUi,
  disableTagClicking,
};

console.log('[Phrase Buddy] Tag Click Handler module loaded');

/**
 * Module: tag-viewer-ui
 * Responsibility: Render Tag Viewer panel UI and viewport.
 *                 Displays prettified tags with scrolling, indentation, and visual formatting.
 *                 Handles "no tags" state, updates on segment changes, and user interactions.
 *                 Manages multiple viewports (inline tab and modal) with centralized rendering.
 *                 Manages live updates with event listeners and interval polling.
 * Dependencies: tag-viewer-logic (tag parsing and tree building),
 *               tool-state-manager
 */

// Tag Viewer runtime state
const PB_TV_STATE = {
  running: false,
  intervalId: null,
  debounceTimer: null,
  prettyEl: null,
  outEl: null,
  quickCopyBtn: null,
  lastActiveSegment: null, // Track active segment to detect changes
  lastContentHash: null, // Hash of content to prevent unnecessary updates
  // Active viewports registry - tracks which viewports are active
  activeViewports: new Set(), // Set of viewport keys: 'inline', 'modal'
  // Per-viewport state tracking
  viewportStates: new Map(), // Map<key, {lastContentHash, prettyEl, outEl}>
};

/**
 * Register a viewport for Tag Viewer updates
 * @param {string} key - Viewport identifier ('inline', 'modal')
 * @param {HTMLElement} prettyEl - The pretty display element
 * @param {HTMLElement} outEl - The output textarea element
 */
function registerViewport(key, prettyEl, outEl) {
  PB_TV_STATE.activeViewports.add(key);
  PB_TV_STATE.viewportStates.set(key, {
    lastContentHash: null,
    prettyEl,
    outEl,
  });
}

/**
 * Unregister a viewport from Tag Viewer updates
 * @param {string} key - Viewport identifier
 */
function unregisterViewport(key) {
  PB_TV_STATE.activeViewports.delete(key);
  PB_TV_STATE.viewportStates.delete(key);
}

/**
 * Update all registered Tag Viewer viewports
 * Centralizes rendering logic for both inline and modal viewports
 */
function renderAllViewports() {
  if (!window.PB_TagViewerLogic) return;
  
  // Check if tag viewer is enabled
  const toolEnabled = window.PB_ToolStateManager?.getToolState?.('phrase-tag-viewer');
  if (!toolEnabled) return;
  
  const logic = window.PB_TagViewerLogic;
  
  // Log current state for debugging
  const sideOverride = logic.getSideOverride?.() || {};
  const activeSegmentEl = document.querySelector(
    '.twe_segment.twe_active, .twe_segment.twe_active_background, [data-testid="segment"][data-selected="true"]'
  );
  
  // Get current segment's target HTML and plain text (shared by all viewports)
  const { html, plain } = logic.getEditorTargetText();
  
  // Create content hash (shared by all viewports)
  const newHash = `${html}|${plain}`;
  
  // Update each registered viewport
  for (const [key, state] of PB_TV_STATE.viewportStates) {
    const { prettyEl, outEl, lastContentHash } = state;
    
    if (!prettyEl) continue;
    
    // Skip if content hasn't changed for this viewport
    if (lastContentHash === newHash) continue;
    
    // Update hash
    state.lastContentHash = newHash;
    
    // Show placeholder if no content
    if (!html || !plain || (typeof plain === 'string' && plain.trim().length === 0)) {
      const placeholderHtml = '<span class="pb-tv-placeholder">No segments selected. Click an active segment or a tag to start displaying tag contents.</span>';
      prettyEl.innerHTML = placeholderHtml;
      if (outEl) outEl.value = '';
      continue;
    }
    
    // Render the rich HTML directly (already includes tag styling and values)
    prettyEl.innerHTML = html;
    
    // Update clipboard textarea with plaintext version (tag values included)
    if (outEl) outEl.value = plain;
  }
}

/**
 * Render the Tag Viewer panel content within module-two (viewport).
 * This is called when the tag viewer tool is enabled.
 * Structure: Module 2 > Viewport > Pretty div + Quick copy + Textarea
 * 
 * @param {HTMLElement} moduleEl - The module-two container element
 * @returns {void}
 */
function renderTagViewerPanel(moduleEl) {
  if (!moduleEl) {
    console.error('[Tag Viewer] Module element not provided');
    return;
  }

  // Create viewport container
  const viewport = document.createElement('div');
  viewport.className = 'pb-tv-viewport';

  // Create pretty div (scrollable content area, inherits pb-paragraph styling)
  const pretty = document.createElement('div');
  pretty.id = 'pb-tv-pretty-inline';
  pretty.className = 'pb-tv-pretty pb-paragraph';
  pretty.setAttribute('tabindex', '0');
  pretty.setAttribute('aria-label', 'Converted tag preview');
  pretty.textContent = '';

  // Create quick copy button
  const quickCopy = document.createElement('button');
  quickCopy.type = 'button';
  quickCopy.className = 'pb-tv-quickcopy syn_form-row__label';
  quickCopy.textContent = 'Quick copy';
  quickCopy.setAttribute('aria-label', 'Quick copy');

  // Create hidden textarea for clipboard content
  const out = document.createElement('textarea');
  out.id = 'pb-tv-out-inline';
  out.className = 'pb-tv-hidden';
  out.setAttribute('aria-hidden', 'true');

  // Set up quick copy functionality with tooltip feedback
  quickCopy.addEventListener('click', async (e) => {
    e.preventDefault();
    const src = out?.value ?? pretty?.textContent ?? '';
    const text = String(src || '');
    if (!text) return;

    try {
      await navigator.clipboard.writeText(text);
      showTagViewerTooltip(quickCopy, 'Viewer text copied');
    } catch (err) {
      console.warn('[Tag Viewer] Copy failed:', err);
    }
  });

  // Assemble viewport: pretty + quickcopy + textarea
  viewport.appendChild(pretty);
  viewport.appendChild(quickCopy);
  viewport.appendChild(out);

  // Add viewport to module
  moduleEl.appendChild(viewport);

  // Store references for lifecycle management
  PB_TV_STATE.prettyEl = pretty;
  PB_TV_STATE.outEl = out;
  PB_TV_STATE.quickCopyBtn = quickCopy;

  // Register the inline viewport
  registerViewport('inline', pretty, out);

  // Initialize phrase blue color for tag highlighting
  if (typeof window.PB_UITheme?.refreshPhraseBlueVar === 'function') {
    try {
      window.PB_UITheme.refreshPhraseBlueVar();
    } catch (e) {
      console.error('[Tag Viewer UI] Error refreshing phrase blue:', e);
    }
  }

  // Render initial content and start monitoring
  updateTagViewerViewport(pretty, out);
  startTagViewerMonitoring(pretty, out);
}

/**
 * Render Tag Viewer settings submodule (Module 3).
 * Contains checkboxes and sliders for Tag Viewer configuration.
 * 
 * @param {HTMLElement} moduleEl - The module-three container element
 * @returns {void}
 */
function renderTagViewerSettings(moduleEl) {
  if (!moduleEl) {
    console.error('[Tag Viewer] Settings module element not provided');
    return;
  }

  // Settings header using proper header structure
  const settingsHeaderWrap = document.createElement('div');
  settingsHeaderWrap.className = 'pb-header';
  const settingsHeaderSpan = document.createElement('span');
  settingsHeaderSpan.className = 'syn_form-row__label';
  settingsHeaderSpan.textContent = 'Settings';
  settingsHeaderWrap.appendChild(settingsHeaderSpan);
  moduleEl.appendChild(settingsHeaderWrap);

  // Get saved tag clicking state
  const savedTagClickState = window.PB_ToolStateManager?.getToolState?.('pb.tags.clickToViewer.v1') || false;

  // Enable tag clicking checkbox using checkbox factory
  const tagClickCheckboxEl = window.PB_CheckboxFactory?.createCheckbox?.({
    label: 'Enable tag clicking',
    dataAttribute: 'data-pb-tv-enable-tag-click',
    dataValue: '1',
    size: 'md',
    checked: savedTagClickState,
    onToggle: (val, isChecked) => {
      // Save state
      window.PB_ToolStateManager?.setToolState?.('pb.tags.clickToViewer.v1', isChecked);
      
      // Update cursor affordance
      window.PB_TagClickHandler?.applyTagClickCursorUi?.();
    },
  });

  if (tagClickCheckboxEl) {
    const tagClickRow = document.createElement('div');
    tagClickRow.className = 'pb-buddy-settings-checkbox-row';
    tagClickRow.appendChild(tagClickCheckboxEl.element);
    moduleEl.appendChild(tagClickRow);

    // Initialize tag click handler with checkbox reference
    if (window.PB_TagClickHandler?.initialize) {
      window.PB_TagClickHandler.initialize(tagClickCheckboxEl.element);
    }
  }

  // Get saved modal window state
  const savedModalState = window.PB_ToolStateManager?.getToolState?.('pb.tags.modalWindow.v1') || false;

  // Enable tag viewer window checkbox using checkbox factory
  const modalCheckboxEl = window.PB_CheckboxFactory?.createCheckbox?.({
    label: 'Enable tag viewer window',
    dataAttribute: 'data-pb-tv-enable-window',
    dataValue: '1',
    size: 'md',
    checked: savedModalState,
    onToggle: (val, isChecked) => {
      // Save state
      window.PB_ToolStateManager?.setToolState?.('pb.tags.modalWindow.v1', isChecked);
      
      // Open or close modal window
      if (isChecked) {
        window.PB_TagViewerModal?.openModal?.();
      } else {
        window.PB_TagViewerModal?.closeModal?.();
      }
    },
  });

  if (modalCheckboxEl) {
    const modalRow = document.createElement('div');
    modalRow.className = 'pb-buddy-settings-checkbox-row';
    modalRow.appendChild(modalCheckboxEl.element);
    moduleEl.appendChild(modalRow);
  }

  // Open modal if it was previously enabled
  if (savedModalState && window.PB_TagViewerModal?.openModal) {
    window.PB_TagViewerModal.openModal();
  }

  // Tab font size slider
  const tabSizeWrap = document.createElement('div');
  tabSizeWrap.style.display = 'flex';
  tabSizeWrap.style.flexDirection = 'column';
  tabSizeWrap.style.gap = '4px';
  tabSizeWrap.style.marginTop = '12px';
  
  const tabSizeLabel = document.createElement('div');
  tabSizeLabel.className = 'syn_form-row__label';
  tabSizeLabel.textContent = 'Tab font size';
  
  const tabSizeRow = document.createElement('div');
  tabSizeRow.style.display = 'flex';
  tabSizeRow.style.alignItems = 'center';
  tabSizeRow.style.gap = '8px';
  
  const tabSizeRange = document.createElement('input');
  tabSizeRange.type = 'range';
  tabSizeRange.min = '8';
  tabSizeRange.max = '42';
  tabSizeRange.step = '0.5';
  
  // Load saved tab font size or use default
  const savedTabSize = window.PB_ToolStateManager?.getTabFontSize?.();
  const tabInitialSize = savedTabSize !== null ? savedTabSize : 15;
  tabSizeRange.value = String(tabInitialSize);
  
  tabSizeRange.classList.add('pb-range');
  tabSizeRange.style.flex = '1 1 auto';
  
  const tabSizeVal = document.createElement('span');
  tabSizeVal.className = 'syn_form-row__label';
  tabSizeVal.textContent = `${tabInitialSize.toFixed(1)}px`;
  tabSizeVal.style.minWidth = '45px';
  
  tabSizeRow.appendChild(tabSizeRange);
  tabSizeRow.appendChild(tabSizeVal);
  tabSizeWrap.appendChild(tabSizeLabel);
  tabSizeWrap.appendChild(tabSizeRow);
  moduleEl.appendChild(tabSizeWrap);

  // Update tab size value display and apply font size
  tabSizeRange.addEventListener('input', () => {
    const val = Number(tabSizeRange.value);
    const min = Number(tabSizeRange.min);
    const max = Number(tabSizeRange.max);
    const pct = ((val - min) / (max - min)) * 100;
    
    tabSizeVal.textContent = `${val.toFixed(1)}px`;
    tabSizeRange.style.setProperty('--pb-range-pct', `${pct}%`);
    
    const pretty = document.querySelector('#pb-tv-pretty-inline');
    if (pretty) {
      pretty.style.setProperty('--pb-tv-font-size', `${val}px`);
      pretty.style.fontSize = `${val}px`;
    }
    
    // Persist the change
    window.PB_ToolStateManager?.saveTabFontSize?.(val);
  });
  
  // Initialize tab slider fill on load
  const tabMin = Number(tabSizeRange.min);
  const tabMax = Number(tabSizeRange.max);
  const tabVal = Number(tabSizeRange.value);
  const tabPct = ((tabVal - tabMin) / (tabMax - tabMin)) * 100;
  tabSizeRange.style.setProperty('--pb-range-pct', `${tabPct}%`);
  
  // Apply initial saved font size to inline viewport
  const prettyInline = document.querySelector('#pb-tv-pretty-inline');
  if (prettyInline) {
    prettyInline.style.setProperty('--pb-tv-font-size', `${tabInitialSize}px`);
    prettyInline.style.fontSize = `${tabInitialSize}px`;
  }

  // Window font size slider
  const winSizeWrap = document.createElement('div');
  winSizeWrap.style.display = 'flex';
  winSizeWrap.style.flexDirection = 'column';
  winSizeWrap.style.gap = '4px';
  winSizeWrap.style.marginTop = '12px';
  
  const winSizeLabel = document.createElement('div');
  winSizeLabel.className = 'syn_form-row__label';
  winSizeLabel.textContent = 'Window font size';
  
  const winSizeRow = document.createElement('div');
  winSizeRow.style.display = 'flex';
  winSizeRow.style.alignItems = 'center';
  winSizeRow.style.gap = '8px';
  
  const winSizeRange = document.createElement('input');
  winSizeRange.type = 'range';
  winSizeRange.min = '8';
  winSizeRange.max = '42';
  winSizeRange.step = '0.5';
  
  // Load saved window font size or use default
  const savedWinSize = window.PB_ToolStateManager?.getWindowFontSize?.();
  const winInitialSize = savedWinSize !== null ? savedWinSize : 15;
  winSizeRange.value = String(winInitialSize);
  
  winSizeRange.classList.add('pb-range');
  winSizeRange.style.flex = '1 1 auto';
  
  const winSizeVal = document.createElement('span');
  winSizeVal.className = 'syn_form-row__label';
  winSizeVal.textContent = `${winInitialSize.toFixed(1)}px`;
  winSizeVal.style.minWidth = '45px';
  
  winSizeRow.appendChild(winSizeRange);
  winSizeRow.appendChild(winSizeVal);
  winSizeWrap.appendChild(winSizeLabel);
  winSizeWrap.appendChild(winSizeRow);
  moduleEl.appendChild(winSizeWrap);

  // Update window size value display and apply font size to modal
  winSizeRange.addEventListener('input', () => {
    const val = Number(winSizeRange.value);
    const min = Number(winSizeRange.min);
    const max = Number(winSizeRange.max);
    const pct = ((val - min) / (max - min)) * 100;
    
    winSizeVal.textContent = `${val.toFixed(1)}px`;
    winSizeRange.style.setProperty('--pb-range-pct', `${pct}%`);
    
    // Apply font size to modal window content display element
    const prettyEl = document.querySelector('#pb-tv-pretty-modal');
    if (prettyEl) {
      prettyEl.style.fontSize = `${val}px`;
      prettyEl.style.setProperty('--pb-tv-font-size', `${val}px`);
      // Calculate line height proportionally
      const lineHeight = val * 1.9;
      prettyEl.style.lineHeight = `${lineHeight}px`;
    }
    
    // Persist the change
    window.PB_ToolStateManager?.saveWindowFontSize?.(val);
  });
  
  // Initialize window slider fill on load
  const winMin = Number(winSizeRange.min);
  const winMax = Number(winSizeRange.max);
  const winVal = Number(winSizeRange.value);
  const winPct = ((winVal - winMin) / (winMax - winMin)) * 100;
  winSizeRange.style.setProperty('--pb-range-pct', `${winPct}%`);
  
  // Apply initial saved font size to modal viewport
  const prettyModal = document.querySelector('#pb-tv-pretty-modal');
  if (prettyModal) {
    prettyModal.style.fontSize = `${winInitialSize}px`;
    prettyModal.style.setProperty('--pb-tv-font-size', `${winInitialSize}px`);
    const initialLineHeight = winInitialSize * 1.9;
    prettyModal.style.lineHeight = `${initialLineHeight}px`;
  }
}

/**
 * Update the tag viewport with current segment's tags.
 * Fetches target text from active segment, renders rich HTML with tag values.
 * Updates both the pretty div (for display) and textarea (for clipboard).
 * Returns early if Tag Viewer tool is not enabled (prevents unnecessary lookups).
 * 
 * @param {HTMLElement} prettyEl - The pretty div element (display)
 * @param {HTMLElement} outEl - The textarea element (clipboard source)
 * @returns {void}
 */
function updateTagViewerViewport(prettyEl, outEl) {
  // Guard: Don't update viewport if tool is disabled - prevents wasted DOM lookups and fetches
  const toolEnabled = window.PB_ToolStateManager?.getToolState?.('phrase-tag-viewer');
  if (!toolEnabled) {
    return;
  }

  if (!prettyEl || !window.PB_TagViewerLogic) {
    return;
  }

  const logic = window.PB_TagViewerLogic;

  // Get current segment's target HTML and plain text
  const { html, plain } = logic.getEditorTargetText();

  // Create content hash to detect actual changes (prevents constant DOM updates)
  const newHash = `${html}|${plain}`;
  if (PB_TV_STATE.lastContentHash === newHash) {
    return;  // Content hasn't changed, skip update
  }
  PB_TV_STATE.lastContentHash = newHash;

  // Show placeholder if no content
  if (!html || !plain || (typeof plain === 'string' && plain.trim().length === 0)) {
    const placeholderHtml = '<span class="pb-tv-placeholder">No segments selected. Click an active segment or a tag to start displaying tag contents.</span>';
    prettyEl.innerHTML = placeholderHtml;
    if (outEl) outEl.value = '';
    return;
  }

  // Render the rich HTML directly (already includes tag styling and values)
  prettyEl.innerHTML = html;

  // Update clipboard textarea with plaintext version (tag values included)
  if (outEl) {
    outEl.value = plain;
  }
}

/**
 * Start live monitoring of segment changes.
 * Sets up event listeners and interval polling like the old code.
 * Updates viewport immediately on events and periodically checks for changes.
 * Matches the old code's pbTagViewerStart behavior.
 * 
 * @param {HTMLElement} prettyEl - The pretty div element to update
 * @param {HTMLElement} outEl - The textarea element to update
 * @returns {void}
 */
function startTagViewerMonitoring(prettyEl, outEl) {
  if (PB_TV_STATE.running) {
    // Already running - just force an update to ensure content is current
    updateTagViewerViewport(prettyEl, outEl);
    return;
  }
  
  PB_TV_STATE.running = true;
  
  // CRITICAL: Clear hash so first update will render even if content was previously empty
  PB_TV_STATE.lastContentHash = null;

  // Handler for rendering updates (debounced)
  const onSignal = () => {
    clearTimeout(PB_TV_STATE.debounceTimer);
    PB_TV_STATE.debounceTimer = setTimeout(() => {
      // Check if active segment changed
      const activeSegment = document.querySelector(
        '.twe_segment.twe_active, .twe_segment.twe_active_background, [data-testid="segment"][data-selected="true"]'
      );
      
      // Get the override state to check which segment we're viewing source for
      const sideOverride = window.PB_TagViewerLogic?.getSideOverride?.() || {};
      const overrideSegment = sideOverride.segment;
      
      // Only clear override if a NEW segment became active (different from override segment)
      if (activeSegment && overrideSegment && activeSegment !== overrideSegment) {
        if (window.PB_TagViewerLogic?.clearSideOverride) {
          window.PB_TagViewerLogic.clearSideOverride();
        }
      }
      
      // Update tracking for next check
      if (activeSegment !== PB_TV_STATE.lastActiveSegment) {
        PB_TV_STATE.lastActiveSegment = activeSegment;
      }
      
      renderAllViewports();
    }, 50);  // 50ms debounce
  };

  // Listen for events that might change the active segment
  // Matches old code: input, keyup, selectionchange, pointerup, focusin
  const events = ['input', 'keyup', 'selectionchange', 'pointerup', 'focusin'];
  events.forEach((ev) => {
    document.addEventListener(ev, onSignal, true);
  });

  // Store event handler for cleanup
  PB_TV_STATE.onSignal = onSignal;
  PB_TV_STATE.eventListeners = events;

  // Initialize lastActiveSegment
  PB_TV_STATE.lastActiveSegment = document.querySelector(
    '.twe_segment.twe_active, .twe_segment.twe_active_background, [data-testid="segment"][data-selected="true"]'
  );

  // Set up interval polling (350ms like old code)
  // Uses centralized renderer to update all registered viewports (inline + modal)
  PB_TV_STATE.intervalId = window.setInterval(() => {
    renderAllViewports();
  }, 350);

  // Render immediately on startup
  renderAllViewports();
}

/**
 * Stop monitoring segment changes and clean up listeners.
 * Matches the old code's pbTagViewerStop behavior.
 * Ensures zero CPU usage and event listener overhead when disabled.
 * 
 * @returns {void}
 */
function stopTagViewerMonitoring() {
  // Clear interval (350ms polling)
  if (PB_TV_STATE.intervalId) {
    clearInterval(PB_TV_STATE.intervalId);
    PB_TV_STATE.intervalId = null;
  }

  // Clear debounce timer (50ms debounce for rapid changes)
  if (PB_TV_STATE.debounceTimer) {
    clearTimeout(PB_TV_STATE.debounceTimer);
    PB_TV_STATE.debounceTimer = null;
  }

  // Remove all event listeners (input, keyup, selectionchange, pointerup, focusin)
  if (PB_TV_STATE.onSignal && PB_TV_STATE.eventListeners) {
    PB_TV_STATE.eventListeners.forEach((ev) => {
      document.removeEventListener(ev, PB_TV_STATE.onSignal, true);
    });
  }

  PB_TV_STATE.onSignal = null;
  PB_TV_STATE.eventListeners = null;
  PB_TV_STATE.running = false;
}

/**
 * Set up click handlers for tag selection.
 * Allows users to click tags to select them in the editor (future feature).
 * 
 * @param {HTMLElement} prettyEl - The pretty div container with rendered tags
 * @returns {void}
 */
function setupTagClickHandlers(prettyEl) {
  const tagElements = prettyEl.querySelectorAll('.pb-tagviewer-tag-name');

  tagElements.forEach((tagEl) => {
    tagEl.addEventListener('click', (e) => {
      e.stopPropagation();
      
      // Highlight tag (visual feedback)
      prettyEl.querySelectorAll('.pb-tagviewer-tag-name').forEach(el => {
        el.classList.remove('pb-tagviewer-tag-selected');
      });
      tagEl.classList.add('pb-tagviewer-tag-selected');
      
      // Future: implement tag selection in editor
      console.log('[Tag Viewer] Tag clicked:', tagEl.textContent);
    });
  });
}

/**
 * Show tooltip feedback on the quick copy button using global tooltip manager.
 * Displays "Viewer text copied" message briefly with Phrase-native styling.
 * 
 * @param {HTMLElement} btn - The button element to anchor the tooltip to
 * @param {string} text - The tooltip text to display
 * @returns {void}
 */
function showTagViewerTooltip(btn, text) {
  if (!btn || !btn.isConnected) return;

  // Use global tooltip manager for consistent Phrase-native styling
  if (typeof window.PB_TooltipManager?.show === 'function') {
    window.PB_TooltipManager.show(btn, text);
    
    // Auto-remove tooltip after 1400ms (feedback duration)
    setTimeout(() => {
      window.PB_TooltipManager?.remove?.();
    }, 1400);
  }
}

/**
 * Initialize Tag Viewer when tool is activated.
 * Starts live monitoring and updates viewport.
 * Called from main.js when tool:activated event fires.
 * 
 * @returns {void}
 */
function initializeTagViewer() {
  const prettyEl = PB_TV_STATE.prettyEl || document.querySelector('#pb-tv-pretty-inline');
  const outEl = PB_TV_STATE.outEl || document.querySelector('#pb-tv-out-inline');
  
  if (prettyEl && outEl) {
    startTagViewerMonitoring(prettyEl, outEl);
  }
}

/**
 * Clean up Tag Viewer when tool is deactivated.
 * Stops monitoring and clears viewport content.
 * Called from main.js when tool:deactivated event fires.
 * Ensures zero CPU usage when disabled - no intervals, no event listeners.
 * 
 * @returns {void}
 */
function cleanupTagViewer() {
  // Stop all monitoring - removes interval and event listeners
  stopTagViewerMonitoring();
  
  // Clear viewport content
  const prettyEl = document.querySelector('#pb-tv-pretty-inline');
  const outEl = document.querySelector('#pb-tv-out-inline');
  
  if (prettyEl) {
    prettyEl.innerHTML = '';
  }
  if (outEl) {
    outEl.value = '';
  }
  
  // Reset tracking state
  PB_TV_STATE.lastActiveSegment = null;
  PB_TV_STATE.lastContentHash = null;
  
  // CRITICAL: Reset content hashes for all registered viewports
  // This ensures next re-enable will render even if content is the same
  for (const [key, state] of PB_TV_STATE.viewportStates) {
    state.lastContentHash = null;
  }
}

// Export public API
window.PB_TagViewerUI = {
  renderTagViewerPanel,
  renderTagViewerSettings,
  updateTagViewerViewport,
  registerViewport,
  unregisterViewport,
  renderAllViewports,
  initializeTagViewer,
  cleanupTagViewer,
};

/**
 * Module: pane-modules
 * Responsibility: Manages the internal tab structure within the Buddy pane.
 *                 Creates and renders sub-tabs for Tag Viewer, Character Detector, and Settings.
 *                 Handles tab switching, active states, and panel content rendering.
 *                 Implements stacked module architecture with enable/disable toggles and conditional visibility.
 * Dependencies: checkbox-factory (createCheckbox, createSeparator),
 *               tool-defaults, tool-state-manager, tool-runtime-manager
 */

// Module IDs for the internal tabs
const MODULE_IDS = {
  TAG_VIEWER: 'phrase-tag-viewer',
  CHAR_DETECTOR: 'character-detector',
  SETTINGS: 'global-settings',
};

// Module definitions with labels and content
const MODULES = [
  {
    id: MODULE_IDS.TAG_VIEWER,
    label: 'Tag Viewer',
    enabled: false,  // Default disabled
    modules: null,  // Rendered by tag-viewer-ui.js
    disabledMessage: 'Enable Tag Viewer to see and interact with tags in your content.',
  },
  {
    id: MODULE_IDS.CHAR_DETECTOR,
    label: 'Character Detector',
    enabled: false,  // Default disabled
    modules: [
      {
        id: 'char-detection',
        title: 'Character Detection',
        content: '<p>Identifies problematic characters and Unicode issues</p>',
      },
      {
        id: 'char-reporting',
        title: 'Character Reports',
        content: '<p>Generates detailed reports on character types</p>',
      },
    ],
    disabledMessage: 'Enable Character Detector to start analyzing character issues.',
  },
  {
    id: MODULE_IDS.SETTINGS,
    label: '',  // Empty for icon-only tab
    isIconOnly: true,
    content: '<p>Settings - configure Buddy options and preferences</p>',
  },
];

// CSS classes for styling
const CSS_CLASSES = {
  HOST: 'pb-buddy-module-host',
  SUBTABS: 'pb-buddy-subtabs',
  SUBTAB_BTN: 'pb-buddy-subtab-btn',
  SUBTAB_BTN_ACTIVE: 'pb-buddy-subtab-btn--active',
  SUBPANELS: 'pb-buddy-subpanels',
  SUBPANEL: 'pb-buddy-subpanel',
  SUBPANEL_ENABLE: 'pb-buddy-subpanel-enable',
  SUBPANEL_CONTENT: 'pb-buddy-subpanel-content',
  SUBPANEL_HIDDEN: 'pb-hidden',
  SUBPANEL_DISABLED_MESSAGE: 'pb-buddy-disabled-message',
  SEPARATOR: 'pb-buddy-separator',
};

// Track active module state
let activeModuleId = MODULE_IDS.TAG_VIEWER;

/**
 * Builds the internal tab structure within the Buddy pane.
 * Creates tabs for Tag Viewer, Character Detector, and Settings.
 * @param {HTMLElement} buddyPaneEl - The Buddy pane container.
 * @returns {void}
 */
function renderBuddyModuleHost(buddyPaneEl) {
  if (!buddyPaneEl) return;

  // Initialize tool states: load saved states and apply defaults if needed
  const defaults = {};
  MODULES.forEach((module) => {
    if (module.modules) {  // Only for tool modules (not Settings)
      // Use TOOL_DEFAULTS for factory defaults, not hardcoded module.enabled
      defaults[module.id] = window.PB_ToolDefaults?.getDefaultState?.(module.id) ?? module.enabled;
    }
  });
  
  // Initialize states on first run (applies defaults if not previously saved)
  if (window.PB_ToolStateManager?.initializeToolStates) {
    window.PB_ToolStateManager.initializeToolStates(defaults);
  }
  
  // Load saved states and apply to module config
  const toolRuntimeStates = {};
  MODULES.forEach((module) => {
    if (module.modules) {  // Only for tool modules
      const saved = window.PB_ToolStateManager?.getToolState?.(module.id);
      if (saved !== null && saved !== undefined) {
        module.enabled = saved;
        toolRuntimeStates[module.id] = saved;
      }
    }
  });
  
  // Initialize tool runtime state
  window.PB_ToolRuntimeManager?.initializeToolRuntime?.(toolRuntimeStates);

  // CRITICAL: Find the body wrapper that is NOT part of Phrase's Vue template
  // The buddyPaneEl contains Vue-managed header and body wrapper
  // We need to append to the body wrapper, not the pane root
  
  const header = buddyPaneEl.querySelector('.side-panel-header');
  let bodyWrapper = header ? header.nextElementSibling : null;
  if (!bodyWrapper) {
    bodyWrapper =
      buddyPaneEl.querySelector('.tab-pane-content') ||
      buddyPaneEl.querySelector('.side-panel-content') ||
      buddyPaneEl.querySelector('[class*="side-panel-content"]') ||
      buddyPaneEl;
  }

  // Check if we already have a host container from a previous render
  let host = bodyWrapper.querySelector(`.${CSS_CLASSES.HOST}`);
  
  if (host) {
    // Already initialized, just update visibility if needed
    return;
  }
  
  // Clear the body wrapper to remove any existing content (like empty state messages)
  bodyWrapper.innerHTML = '';
  
  // Create the host container for the first time
  host = document.createElement('div');
  host.className = CSS_CLASSES.HOST;
  bodyWrapper.appendChild(host);

  // Create tabs container
  const tabsContainer = document.createElement('div');
  tabsContainer.className = `syn_tabs ${CSS_CLASSES.SUBTABS}`.trim();
  tabsContainer.setAttribute('data-testid', 'syn-tabs');
  tabsContainer.setAttribute('role', 'tablist');
  host.appendChild(tabsContainer);

  // Create panels container
  const panelsContainer = document.createElement('div');
  panelsContainer.className = CSS_CLASSES.SUBPANELS;
  panelsContainer.id = 'pb-buddy-subpanels';  // Add ID for easy lookup
  host.appendChild(panelsContainer);

  // Create tab buttons and panels
  MODULES.forEach((module) => {
    // Create tab button - relies on Phrase's syn_tab class for all styling
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'syn_tab';  // Only use Phrase's native class
    btn.dataset.pbModuleId = module.id;
    btn.setAttribute('role', 'tab');
    btn.setAttribute('aria-controls', `pb-panel-${module.id}`);
    btn.setAttribute('aria-selected', module.id === activeModuleId ? 'true' : 'false');
    btn.tabIndex = module.id === activeModuleId ? 0 : -1;

    // Add label if not icon-only
    if (!module.isIconOnly) {
      const label = document.createElement('span');
      label.className = 'syn_tab__label syn_tab__content';
      label.textContent = module.label;
      btn.appendChild(label);
    } else {
      // For Settings, add a cogwheel icon (cloned from native Phrase icon for inherited styling)
      const iconWrapper = createSettingsIcon();
      btn.appendChild(iconWrapper);
    }

    // Mark as active if it's the active module (use Phrase's native active class)
    if (module.id === activeModuleId) {
      btn.classList.add('syn_tab--active');
    }

    // Add click handler
    btn.addEventListener('click', (e) => {
      e.preventDefault();
      setActiveModule(module.id, panelsContainer);
      updateTabVisuals(tabsContainer, module.id);
    });

    tabsContainer.appendChild(btn);

    // Create panel
    const panel = document.createElement('div');
    panel.className = CSS_CLASSES.SUBPANEL;
    panel.id = `pb-panel-${module.id}`;
    panel.dataset.pbModuleId = module.id;
    panel.setAttribute('role', 'tabpanel');
    panel.setAttribute('aria-hidden', module.id === activeModuleId ? 'false' : 'true');
    
    // Show active panel, hide others
    panel.style.display = module.id === activeModuleId ? 'block' : 'none';

    // For tools with stacked modules (Tag Viewer, Character Detector)
    if ((module.modules && Array.isArray(module.modules)) || module.id === MODULE_IDS.TAG_VIEWER || module.id === MODULE_IDS.CHAR_DETECTOR) {
      // ============ MODULE 1: Enable/Disable ============
      const moduleOneSection = document.createElement('div');
      moduleOneSection.className = CSS_CLASSES.SUBPANEL;
      moduleOneSection.classList.add('pb-buddy-module-one');  // Compact styling
      moduleOneSection.style.marginBottom = '0';
      
      // ============ Declare these upfront for toggle handler access ============
      const moduleDeactivated = document.createElement('div');
      const moduleTwo = document.createElement('div');
      const moduleThree = document.createElement('div');
      
      // Get the actual enabled state (saved state takes priority)
      const actualEnabledState = window.PB_ToolStateManager?.getToolState?.(module.id) ?? module.enabled;
      
      const enableCheckbox = window.PB_CheckboxFactory?.createCheckbox?.({
        label: 'Enable',
        dataAttribute: 'data-pb-tool-enable',
        dataValue: module.id,
        checked: actualEnabledState,
        size: 'md',
        onToggle: (toolId, isChecked) => {
          // Persist state to GM storage
          window.PB_ToolStateManager?.setToolState?.(toolId, isChecked);
          
          // Activate or deactivate tool at runtime
          window.PB_ToolRuntimeManager?.setToolActive?.(toolId, isChecked);
          
          // Toggle visibility of content and disabled message
          moduleDeactivated.style.display = isChecked ? 'none' : 'block';
          moduleTwo.style.display = isChecked ? 'block' : 'none';
          moduleThree.style.display = isChecked ? 'block' : 'none';
        },
      });
      
      if (!enableCheckbox) {
        return;
      }
      
      const enableSectionWrapper = document.createElement('div');
      enableSectionWrapper.className = CSS_CLASSES.SUBPANEL_ENABLE;
      enableSectionWrapper.appendChild(enableCheckbox.element);
      moduleOneSection.appendChild(enableSectionWrapper);
      panel.appendChild(moduleOneSection);
      
      // Create separator container with NO padding (separator lives here)
      // This goes INSIDE the panel between Module 1 and Module 2
      const separatorContainer = document.createElement('div');
      separatorContainer.className = 'pb-buddy-separator-container';
      
      const moduleSeparator = document.createElement('span');
      moduleSeparator.className = 'syn_divider--horizontal syn_divider--no-side-margin divider';
      
      separatorContainer.appendChild(moduleSeparator);
      panel.appendChild(separatorContainer);
      
      // ============ MODULE DEACTIVATED: Disabled Message ============
      moduleDeactivated.className = CSS_CLASSES.SUBPANEL;
      moduleDeactivated.classList.add('pb-buddy-tag-viewer-deactivated');
      moduleDeactivated.style.display = actualEnabledState ? 'none' : 'block';
      
      const disabledMessageWrapper = document.createElement('div');
      disabledMessageWrapper.className = 'pb-tv-disabled-message';
      disabledMessageWrapper.innerHTML = `<span class="pb-tv-placeholder">${module.disabledMessage}</span>`;
      moduleDeactivated.appendChild(disabledMessageWrapper);
      panel.appendChild(moduleDeactivated);
      
      // ============ MODULE 2: Viewport (shown when enabled) ============
      moduleTwo.className = CSS_CLASSES.SUBPANEL;
      moduleTwo.classList.add('pb-buddy-module-two');
      moduleTwo.style.display = actualEnabledState ? 'block' : 'none';
      
      // Render feature-specific content based on module ID
      if (module.id === MODULE_IDS.TAG_VIEWER && window.PB_TagViewerUI?.renderTagViewerPanel) {
        window.PB_TagViewerUI.renderTagViewerPanel(moduleTwo);
      }
      
      panel.appendChild(moduleTwo);

      // ============ SEPARATOR 2 ============
      const separatorContainer2 = document.createElement('div');
      separatorContainer2.className = 'pb-buddy-separator-container';
      const moduleSeparator2 = document.createElement('span');
      moduleSeparator2.className = 'syn_divider--horizontal syn_divider--no-side-margin divider';
      separatorContainer2.appendChild(moduleSeparator2);
      panel.appendChild(separatorContainer2);

      // ============ MODULE 3: Settings ============
      moduleThree.className = CSS_CLASSES.SUBPANEL;
      moduleThree.classList.add('pb-buddy-module-three');
      moduleThree.style.display = actualEnabledState ? 'block' : 'none';
      
      // Render settings for Tag Viewer
      if (module.id === MODULE_IDS.TAG_VIEWER && window.PB_TagViewerUI?.renderTagViewerSettings) {
        window.PB_TagViewerUI.renderTagViewerSettings(moduleThree);
      }
      
      panel.appendChild(moduleThree);
    } else if (module.id === MODULE_IDS.SETTINGS) {
      // For Settings tab, build panel with Reset button
      panel.appendChild(buildSettingsPanel());
    } else {
      // For other non-stacked modules, just use content directly
      panel.innerHTML = module.content;
    }

    panelsContainer.appendChild(panel);
  });
}

/**
 * Builds the Settings panel with Reset All Tools button.
 * @returns {HTMLElement} A container div with settings content.
 */
function buildSettingsPanel() {
  const container = document.createElement('div');
  container.style.padding = '12px';
  container.style.display = 'flex';
  container.style.flexDirection = 'column';
  container.style.gap = '16px';
  
  // Title section
  const title = document.createElement('h3');
  title.textContent = 'Phrase Buddy global settings';
  title.style.margin = '0 0 8px 0';
  title.style.fontSize = '14px';
  title.style.fontWeight = '600';
  title.style.textAlign = 'left';
  container.appendChild(title);
  
  // Reset button
  const resetBtn = document.createElement('button');
  resetBtn.textContent = 'Reset all tools to defaults';
  resetBtn.className = 'syn_btn syn_btn--primary syn_btn--small';
  resetBtn.style.alignSelf = 'center';
  resetBtn.style.padding = '2px 6px';
  resetBtn.style.height = '26px';
  resetBtn.style.cursor = 'pointer';
  resetBtn.style.minWidth = '50px';
  resetBtn.onclick = handleResetAllTools;
  
  container.appendChild(resetBtn);
  
  return container;
}

/**
 * Handles resetting all tools to their default states.
 * Calls resetAllToolsToDefaults() and updates the UI.
 */
function handleResetAllTools() {
  // Show confirmation modal first
  showResetConfirmation();
}

/**
 * Show a confirmation modal before resetting all tools
 */
function showResetConfirmation() {
  // Create modal overlay
  const overlay = document.createElement('div');
  overlay.id = 'pb-reset-confirmation-overlay';
  overlay.style.position = 'fixed';
  overlay.style.top = '0';
  overlay.style.left = '0';
  overlay.style.right = '0';
  overlay.style.bottom = '0';
  overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.zIndex = '2147482000';
  
  // Create modal container
  const modal = document.createElement('div');
  modal.className = 'pb-beta-modal';
  modal.style.position = 'relative';
  modal.style.display = 'flex';
  modal.style.flexDirection = 'column';
  modal.style.pointerEvents = 'auto';
  modal.style.borderRadius = '0.375rem';
  modal.style.border = '1px solid rgba(128, 128, 128, 0.2)';
  modal.style.boxShadow = 'rgba(0, 0, 0, 0.15) 0px 0.125rem 0.625rem';
  modal.style.overflow = 'hidden';
  modal.style.fontFamily = 'inherit';
  modal.style.maxWidth = '400px';
  modal.style.minWidth = '300px';
  
  // Sample Phrase's current theme colors for modal background/text
  const { bg, fg } = window.PB_TagViewerModalTheme?.samplePhraseSurfaceTokens?.() || { bg: '#ffffff', fg: '#111111' };
  modal.style.backgroundColor = bg;
  modal.style.color = fg;
  
  // Detect theme scheme
  const bgRgb = window.PB_TagViewerModalTheme?.parseColor?.(bg) || { r: 255, g: 255, b: 255 };
  const bgLuminance = window.PB_TagViewerModalTheme?.getLuminance?.(bgRgb) || 0.5;
  const scheme = bgLuminance > 0.5 ? 'light' : 'dark';
  modal.style.colorScheme = scheme;
  
  // Create header
  const header = document.createElement('div');
  header.className = 'pb-beta-modal__footer';
  header.style.display = 'flex';
  header.style.alignItems = 'center';
  header.style.height = '32px';
  header.style.minHeight = '32px';
  header.style.padding = '0px 10px';
  header.style.borderBottom = '1px solid rgba(128, 128, 128, 0.2)';
  header.style.flexShrink = '0';
  
  const headerTitle = document.createElement('div');
  headerTitle.className = 'syn_form-row__label';
  headerTitle.style.fontSize = '14px';
  headerTitle.style.fontWeight = '700';
  headerTitle.style.lineHeight = '21px';
  headerTitle.style.margin = '0';
  headerTitle.textContent = 'Reset confirmation';
  header.appendChild(headerTitle);
  modal.appendChild(header);
  
  // Create inner content container
  const content = document.createElement('div');
  content.className = 'pb-beta-modal__content';
  content.style.flex = '1 1 auto';
  content.style.minHeight = '0px';
  content.style.display = 'flex';
  content.style.flexDirection = 'column';
  content.style.padding = '24px';
  
  // Create message
  const message = document.createElement('div');
  message.style.fontSize = '14px';
  message.style.marginBottom = '24px';
  message.style.lineHeight = '1.5';
  message.style.textAlign = 'center';
  message.textContent = 'Resetting all tools to defaults requires a page refresh. Continue?';
  content.appendChild(message);
  
  // Create button container
  const buttonContainer = document.createElement('div');
  buttonContainer.style.display = 'flex';
  buttonContainer.style.gap = '8px';
  buttonContainer.style.justifyContent = 'flex-end';
  
  // Cancel button
  const cancelBtn = document.createElement('button');
  cancelBtn.textContent = 'Cancel';
  cancelBtn.className = 'syn_btn syn_btn--primary syn_btn--small';
  cancelBtn.style.padding = '2px 12px';
  cancelBtn.style.height = '26px';
  cancelBtn.style.cursor = 'pointer';
  cancelBtn.onclick = () => {
    document.body.removeChild(overlay);
  };
  buttonContainer.appendChild(cancelBtn);
  
  // Confirm button
  const confirmBtn = document.createElement('button');
  confirmBtn.textContent = 'Continue';
  confirmBtn.className = 'syn_btn syn_btn--primary syn_btn--small';
  confirmBtn.style.padding = '2px 12px';
  confirmBtn.style.height = '26px';
  confirmBtn.style.cursor = 'pointer';
  confirmBtn.onclick = () => {
    document.body.removeChild(overlay);
    performResetAllTools();
  };
  buttonContainer.appendChild(confirmBtn);
  
  content.appendChild(buttonContainer);
  modal.appendChild(content);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
}

/**
 * Perform the actual reset of all tools to their default states.
 */
function performResetAllTools() {
  // Get the default values from tool-defaults
  // Include ALL modules with an id (not just ones with .modules property)
  const actualDefaults = {};
  MODULES.forEach((module) => {
    if (module.id && module.id !== MODULE_IDS.SETTINGS) {  // Include all tool modules, skip settings
      const defaultState = window.PB_ToolDefaults?.getDefaultState?.(module.id);
      if (defaultState !== undefined) {
        actualDefaults[module.id] = defaultState;
      }
    }
  });
  
  // Reset all tools in storage (this handles master enable states like 'phrase-tag-viewer')
  window.PB_ToolStateManager?.resetAllToolsToDefaults?.(actualDefaults);
  
  // Reset Tag Viewer specific settings (these are separate from master enable)
  const tagViewerDefaults = window.PB_ToolDefaults?.getDefaultConfig?.('phrase-tag-viewer');
  if (tagViewerDefaults) {
    // Reset tag clicking state (separate tool state)
    window.PB_ToolStateManager?.setToolState?.(window.PB_ToolDefaults?.TOOL_STATE_KEYS?.TAG_CLICK_ENABLED, tagViewerDefaults.tagClickingEnabled);
    
    // Reset window enabled state (separate tool state)
    window.PB_ToolStateManager?.setToolState?.(window.PB_ToolDefaults?.TOOL_STATE_KEYS?.TAG_WINDOW_ENABLED, tagViewerDefaults.windowEnabled);
    
    // Reset window position and size via modal persistence
    if (window.PB_TagViewerModalPersistence) {
      // Convert default position format to what persistence expects
      // Defaults use { left, top: 'auto', bottom } but persistence needs numeric { left, top }
      const defaultPos = tagViewerDefaults.windowPosition;
      if (defaultPos) {
        // If bottom is specified, convert to top position
        let topPos = defaultPos.top;
        if (defaultPos.bottom !== undefined && defaultPos.bottom !== null) {
          // For bottom positioning, we'll use a large top value that will be clamped
          topPos = window.innerHeight - defaultPos.bottom - 160; // 160 is default height
        }
        const posToSave = { left: defaultPos.left, top: topPos };
        window.PB_TagViewerModalPersistence.saveModalPosition?.(posToSave);
      }
      
      window.PB_TagViewerModalPersistence.saveModalSize?.(tagViewerDefaults.windowSize);
    }
    
    // Reset font sizes via tool state manager
    if (window.PB_ToolStateManager) {
      window.PB_ToolStateManager.saveTabFontSize?.(tagViewerDefaults.tabFontSize);
      window.PB_ToolStateManager.saveWindowFontSize?.(tagViewerDefaults.windowFontSize);
    }
  }
  
  // Update module.enabled to match defaults
  MODULES.forEach((module) => {
    if (module.modules && actualDefaults[module.id] !== undefined) {
      module.enabled = actualDefaults[module.id];
    }
  });
  
  console.log('[Phrase Buddy] All tools reset to defaults');
  
  // Re-render the entire module host to reflect new states
  setTimeout(() => {
    const buddyPaneEl = document.getElementById('phrase-buddy-pane');
    if (buddyPaneEl) {
      renderBuddyModuleHost(buddyPaneEl);
    }
    
    // Reload the page after a brief delay to apply changes
    setTimeout(() => {
      location.reload();
    }, 500);
  }, 50);
}


/**
 * Clones a cogwheel icon from a native Phrase icon SVG.
 * Wraps it in a label span like text tabs to inherit all styling.
 * Falls back to creating a custom SVG if no native icon is available to clone.
 * @returns {HTMLElement} A label span containing the cogwheel icon.
 */
function createSettingsIcon() {
  // Try to clone a native Phrase icon (SVG) to inherit all styling
  const nativeSvg = document.querySelector('#right-panel-navigation-tabs .sidebar-tab button svg');
  
  if (nativeSvg) {
    // Clone just the SVG element - it has all the classes and styling attributes
    const svg = nativeSvg.cloneNode(true);
    
    // Clear existing paths
    const existingPaths = svg.querySelectorAll('path');
    existingPaths.forEach(p => p.remove());
    
    // Set cogwheel viewBox and size
    svg.setAttribute('viewBox', '0 0 36 36');
    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
    svg.style.width = '16px';
    svg.style.height = '16px';
    
    // Add cogwheel paths
    const p1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    p1.setAttribute('d', 'M18.1,11c-3.9,0-7,3.1-7,7s3.1,7,7,7c3.9,0,7-3.1,7-7S22,11,18.1,11z M18.1,23c-2.8,0-5-2.2-5-5s2.2-5,5-5c2.8,0,5,2.2,5,5S20.9,23,18.1,23z');
    
    const p2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    p2.setAttribute('d', 'M32.8,14.7L30,13.8l-0.6-1.5l1.4-2.6c0.3-0.6,0.2-1.4-0.3-1.9l-2.4-2.4c-0.5-0.5-1.3-0.6-1.9-0.3l-2.6,1.4l-1.5-0.6l-0.9-2.8C21,2.5,20.4,2,19.7,2h-3.4c-0.7,0-1.3,0.5-1.4,1.2L14,6c-0.6,0.1-1.1,0.3-1.6,0.6L9.8,5.2C9.2,4.9,8.4,5,7.9,5.5L5.5,7.9C5,8.4,4.9,9.2,5.2,9.8l1.3,2.5c-0.2,0.5-0.4,1.1-0.6,1.6l-2.8,0.9C2.5,15,2,15.6,2,16.3v3.4c0,0.7,0.5,1.3,1.2,1.5L6,22.1l0.6,1.5l-1.4,2.6c-0.3,0.6-0.2,1.4,0.3,1.9l2.4,2.4c0.5,0.5,1.3,0.6,1.9,0.3l2.6-1.4l1.5,0.6l0.9,2.9c0.2,0.6,0.8,1.1,1.5,1.1h3.4c0.7,0,1.3-0.5,1.5-1.1l0.9-2.9l1.5-0.6l2.6,1.4c0.6,0.3,1.4,0.2,1.9-0.3l2.4-2.4c0.5-0.5,0.6-1.3,0.3-1.9l-1.4-2.6l0.6-1.5l2.9-0.9c0.6-0.2,1.1-0.8,1.1-1.5v-3.4C34,15.6,33.5,14.9,32.8,14.7z M32,19.4l-3.6,1.1L28.3,21c-0.3,0.7-0.6,1.4-0.9,2.1l-0.3,0.5l1.8,3.3l-2,2l-3.3-1.8l-0.5,0.3c-0.7,0.4-1.4,0.7-2.1,0.9l-0.5,0.1L19.4,32h-2.8l-1.1-3.6L15,28.3c-0.7-0.3-1.4-0.6-2.1-0.9l-0.5-0.3l-3.3,1.8l-2-2l1.8-3.3l-0.3-0.5c-0.4-0.7-0.7-1.4-0.9-2.1l-0.1-0.5L4,19.4v-2.8l3.4-1l0.2-0.5c0.2-0.8,0.5-1.5,0.9-2.2l0.3-0.5L7.1,9.1l2-2l3.2,1.8l0.5-0.3c0.7-0.4,1.4-0.7,2.2-0.9l0.5-0.2L16.6,4h2.8l1.1,3.5L21,7.7c0.7,0.2,1.4,0.5,2.1,0.9l0.5,0.3l3.3-1.8l2,2l-1.8,3.3l0.3,0.5c0.4,0.7,0.7,1.4,0.9,2.1l0.1,0.5l3.6,1.1V19.4z');
    
    svg.appendChild(p1);
    svg.appendChild(p2);
    
    // Wrap in label span to inherit text styling from active/inactive states
    const wrapper = document.createElement('span');
    wrapper.className = 'syn_tab__label syn_tab__content';
    wrapper.appendChild(svg);
    
    return wrapper;
  }
  
  // Fallback: create a cogwheel SVG from scratch if no native icon found
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('viewBox', '0 0 36 36');
  svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
  svg.style.width = '16px';
  svg.style.height = '16px';
  svg.setAttribute('aria-hidden', 'true');
  svg.classList.add('syn_icon', 'syn_icon--compact');
  svg.setAttribute('fill', 'currentColor');
  svg.setAttribute('stroke', 'currentColor');

  const p1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  p1.setAttribute('d', 'M18.1,11c-3.9,0-7,3.1-7,7s3.1,7,7,7c3.9,0,7-3.1,7-7S22,11,18.1,11z M18.1,23c-2.8,0-5-2.2-5-5s2.2-5,5-5c2.8,0,5,2.2,5,5S20.9,23,18.1,23z');

  const p2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  p2.setAttribute('d', 'M32.8,14.7L30,13.8l-0.6-1.5l1.4-2.6c0.3-0.6,0.2-1.4-0.3-1.9l-2.4-2.4c-0.5-0.5-1.3-0.6-1.9-0.3l-2.6,1.4l-1.5-0.6l-0.9-2.8C21,2.5,20.4,2,19.7,2h-3.4c-0.7,0-1.3,0.5-1.4,1.2L14,6c-0.6,0.1-1.1,0.3-1.6,0.6L9.8,5.2C9.2,4.9,8.4,5,7.9,5.5L5.5,7.9C5,8.4,4.9,9.2,5.2,9.8l1.3,2.5c-0.2,0.5-0.4,1.1-0.6,1.6l-2.8,0.9C2.5,15,2,15.6,2,16.3v3.4c0,0.7,0.5,1.3,1.2,1.5L6,22.1l0.6,1.5l-1.4,2.6c-0.3,0.6-0.2,1.4,0.3,1.9l2.4,2.4c0.5,0.5,1.3,0.6,1.9,0.3l2.6-1.4l1.5,0.6l0.9,2.9c0.2,0.6,0.8,1.1,1.5,1.1h3.4c0.7,0,1.3-0.5,1.5-1.1l0.9-2.9l1.5-0.6l2.6,1.4c0.6,0.3,1.4,0.2,1.9-0.3l2.4-2.4c0.5-0.5,0.6-1.3,0.3-1.9l-1.4-2.6l0.6-1.5l2.9-0.9c0.6-0.2,1.1-0.8,1.1-1.5v-3.4C34,15.6,33.5,14.9,32.8,14.7z M32,19.4l-3.6,1.1L28.3,21c-0.3,0.7-0.6,1.4-0.9,2.1l-0.3,0.5l1.8,3.3l-2,2l-3.3-1.8l-0.5,0.3c-0.7,0.4-1.4,0.7-2.1,0.9l-0.5,0.1L19.4,32h-2.8l-1.1-3.6L15,28.3c-0.7-0.3-1.4-0.6-2.1-0.9l-0.5-0.3l-3.3,1.8l-2-2l1.8-3.3l-0.3-0.5c-0.4-0.7-0.7-1.4-0.9-2.1l-0.1-0.5L4,19.4v-2.8l3.4-1l0.2-0.5c0.2-0.8,0.5-1.5,0.9-2.2l0.3-0.5L7.1,9.1l2-2l3.2,1.8l0.5-0.3c0.7-0.4,1.4-0.7,2.2-0.9l0.5-0.2L16.6,4h2.8l1.1,3.5L21,7.7c0.7,0.2,1.4,0.5,2.1,0.9l0.5,0.3l3.3-1.8l2,2l-1.8,3.3l0.3,0.5c0.4,0.7,0.7,1.4,0.9,2.1l0.1,0.5l3.6,1.1V19.4z');

  svg.appendChild(p1);
  svg.appendChild(p2);
  
  // Wrap in label span to inherit text styling from active/inactive states
  const wrapper = document.createElement('span');
  wrapper.className = 'syn_tab__label syn_tab__content';
  wrapper.appendChild(svg);
  
  return wrapper;
}

/**
 * Sets the active module and updates panel visibility.
 * @param {string} moduleId - The module ID to activate.
 * @param {HTMLElement} panelsContainer - The container with all panels.
 */
function setActiveModule(moduleId, panelsContainer) {
  activeModuleId = moduleId;

  // Hide all top-level panels (use ID selector to only target main panels, not subpanels)
  const allPanels = panelsContainer.querySelectorAll('[id^="pb-panel-"]');
  allPanels.forEach((panel) => {
    panel.style.display = 'none';
    panel.setAttribute('aria-hidden', 'true');
  });

  // Show active panel
  const activePanel = panelsContainer.querySelector(`#pb-panel-${moduleId}`);
  if (activePanel) {
    activePanel.style.display = 'block';
    activePanel.setAttribute('aria-hidden', 'false');
  } else {
    console.warn('[Pane Modules] Could not find panel with ID: pb-panel-' + moduleId);
  }
}

/**
 * Updates tab button visuals to reflect the active state.
 * Uses Phrase's native active state classes for styling.
 * Cogwheel icon automatically inherits styling from cloned wrapper.
 * @param {HTMLElement} tabsContainer - The tabs container.
 * @param {string} activeModuleId - The active module ID.
 */
function updateTabVisuals(tabsContainer, activeModuleId) {
  const allTabs = tabsContainer.querySelectorAll('.syn_tab');
  
  allTabs.forEach((tab) => {
    const isActive = tab.dataset.pbModuleId === activeModuleId;
    
    if (isActive) {
      tab.classList.add('syn_tab--active');
      tab.setAttribute('aria-selected', 'true');
      tab.tabIndex = 0;
    } else {
      tab.classList.remove('syn_tab--active');
      tab.setAttribute('aria-selected', 'false');
      tab.tabIndex = -1;
    }
    
    // Cogwheel icon automatically inherits styling - no manual painting needed
  });
}

/**
 * Gets the currently active module ID.
 * @returns {string} The active module ID.
 */
function getActiveModuleId() {
  return activeModuleId;
}

// Export public API
window.PB_PaneModules = {
  renderBuddyModuleHost,
  setActiveModule,
  updateTabVisuals,
  getActiveModuleId,
  MODULE_IDS,
  CSS_CLASSES,
};

/**
 * Module: main
 * Responsibility: Orchestrates the initialization of all Buddy modules.
 *                 Sets up the Buddy tab, pane, icon, and event handlers.
 *                 Serves as the entry point that coordinates tab-integration,
 *                 icon-manager, ui-state, styles, and pane-modules.
 *                 Installs theme change listeners for dynamic color and checkbox updates.
 * Dependencies: tab-integration, icon-manager, ui-state, styles, pane-modules,
 *               ui-theme, tool-state-manager, tool-runtime-manager
 */

// Modules are concatenated during build; they initialize automatically.

/**
 * Repaints the Buddy smiley icon when theme changes.
 * Also resamples Phrase blue color for checkbox styling.
 * Cogwheel icons automatically inherit styling from cloned Phrase wrappers - no painting needed.
 */
function repaintBuddySmileyOnThemeChange() {
  console.log('[Phrase Buddy] Theme change detected!');
  
  const tabsContainer = window.PB_TabIntegration?.findTabsContainer?.();
  
  // Repaint smiley icon with new colors
  const buddyTab = document.getElementById('phrase-buddy-tab');
  if (tabsContainer && buddyTab && window.PB_IconManager?.updatePhraseIconColors) {
    console.log('[Phrase Buddy] Updating phrase icon colors');
    window.PB_IconManager.updatePhraseIconColors(tabsContainer, buddyTab.id);
  }

  if (buddyTab && window.PB_IconManager?.paintBuddyIcon) {
    const isActive = buddyTab.classList.contains('active');
    console.log('[Phrase Buddy] Repainting buddy icon, active:', isActive);
    window.PB_IconManager.paintBuddyIcon(buddyTab, isActive);
  }
}

/**
 * Sets up a listener for theme changes in Phrase.
 * When the theme changes (light/dark mode), refreshes Phrase blue CSS variable.
 * Watches both document.documentElement and document.body for comprehensive detection.
 */
function setupThemeChangeListener() {
  let rafPending = false;
  
  const handleThemeChange = () => {
    if (rafPending) return;
    rafPending = true;
    requestAnimationFrame(() => {
      rafPending = false;
      repaintBuddySmileyOnThemeChange();
      
      // Refresh Phrase blue CSS variable for adaptive colors (updates tags automatically via CSS)
      if (typeof window.PB_UITheme?.refreshPhraseBlueVar === 'function') {
        window.PB_UITheme.refreshPhraseBlueVar();
      }
      
      // Repaint checkboxes (they use direct fill attributes, not CSS variables)
      if (typeof window.PB_UITheme?.paintCheckboxes === 'function') {
        window.PB_UITheme.paintCheckboxes();
      }
    });
  };

  // Watch for attribute changes on document element (Phrase adds/removes dark mode classes/attributes)
  const observer = new MutationObserver(handleThemeChange);
  
  observer.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['class', 'style', 'data-theme', 'data-color-mode'],
  });
  
  // Also watch body element (some themes change body attributes)
  if (document.body) {
    observer.observe(document.body, {
      attributes: true,
      attributeFilter: ['class', 'style', 'data-theme', 'data-color-mode'],
    });
  }

  // Watch for OS-level theme changes
  try {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    const mediaHandler = () => handleThemeChange();
    
    if (typeof mediaQuery.addEventListener === 'function') {
      mediaQuery.addEventListener('change', mediaHandler);
    } else if (typeof mediaQuery.addListener === 'function') {
      mediaQuery.addListener(mediaHandler);
    }
  } catch (e) {
    // Silently fail if matchMedia not supported
  }

  console.log('[Phrase Buddy] Theme change listener installed');
}

/**
 * Sets up event-driven checkbox repainting.
 * Observes mutations on the buddy pane and repaints checkboxes only when needed.
 * Much more efficient than polling every 500ms.
 * @param {HTMLElement} buddyPane - The buddy pane element to observe.
 */
function setupCheckboxRepaintListener(buddyPane) {
  if (!buddyPane) {
    console.warn('[Phrase Buddy] setupCheckboxRepaintListener: buddyPane not provided, skipping observer setup');
    return;
  }

  let repaintScheduled = false;

  const observer = new MutationObserver(() => {
    // Debounce: only schedule one repaint per animation frame
    if (!repaintScheduled) {
      repaintScheduled = true;
      requestAnimationFrame(() => {
        if (window.PB_UITheme?.paintCheckboxes) {
          console.log('[Phrase Buddy] Repainting checkboxes due to pane DOM mutation');
          window.PB_UITheme.paintCheckboxes();
        } else {
          console.error('[Phrase Buddy] PB_UITheme.paintCheckboxes not available in mutation observer!');
        }
        repaintScheduled = false;
      });
    }
  });

  // Watch for any DOM mutations within the buddy pane (children added/removed/modified)
  observer.observe(buddyPane, {
    childList: true,      // Watch for added/removed child nodes
    subtree: true,        // Watch all descendants
    attributes: false,    // Don't watch attributes (avoid re-triggering on our own paint changes)
  });

  console.log('[Phrase Buddy] Checkbox repaint listener installed (event-driven)');
}

/**
 * Waits for a selector to exist in the DOM, with timeout.
 * @param {string} selector - The CSS selector to wait for.
 * @param {number} timeoutMs - Maximum time to wait in milliseconds.
 * @param {number} intervalMs - Polling interval in milliseconds.
 * @returns {Promise<HTMLElement|null>} Resolves with element or null on timeout.
 */
function waitForElement(selector, timeoutMs = 5000, intervalMs = 100) {
  return new Promise((resolve) => {
    const startTime = Date.now();
    const interval = setInterval(() => {
      const el = document.querySelector(selector);
      if (el) {
        clearInterval(interval);
        resolve(el);
      } else if (Date.now() - startTime > timeoutMs) {
        clearInterval(interval);
        resolve(null);
      }
    }, intervalMs);
  });
}

/**
 * Initializes the Buddy tab and pane, setting up all event handlers.
 * Called once when the Phrase interface is ready.
 */
async function initializeBuddy() {
  console.log('[Phrase Buddy] Initializing...');

  // Initialize state synchronization (cross-tab sync, error recovery)
  window.PB_StateSynchronizer?.initializeStateSynchronization?.();

  // Inject styles for Buddy UI
  window.PB_Styles?.injectStyles?.();

  // Wait for the Phrase tabs container to be available
  const tabsContainer = await waitForElement('#right-panel-navigation-tabs .sidebar-tabs-container');
  if (!tabsContainer) {
    console.error('[Phrase Buddy] Failed to find tabs container');
    return;
  }

  console.log('[Phrase Buddy] Found tabs container:', tabsContainer);

  const panesContainer = window.PB_TabIntegration?.findPanesContainer?.();
  if (!panesContainer) {
    console.error('[Phrase Buddy] Failed to find panes container');
    
    // Debug: log what's in the DOM
    const allPanes = document.querySelectorAll('[class*="pane"]');
    console.log('[Phrase Buddy] Found elements with "pane" in class:', allPanes.length, allPanes);
    
    const tabPanes = document.querySelectorAll('.tab-pane');
    console.log('[Phrase Buddy] Found .tab-pane elements:', tabPanes.length, tabPanes);
    
    const rightPanel = document.querySelector('#right-panel-navigation');
    console.log('[Phrase Buddy] Right panel container:', rightPanel);
    
    return;
  }



  // Ensure Buddy tab exists in the DOM
  const buddyTab = window.PB_TabIntegration?.ensureBuddyTab?.(tabsContainer);
  if (!buddyTab) {
    console.error('[Phrase Buddy] Failed to create Buddy tab');
    return;
  }



  // Set up the icon
  if (window.PB_IconManager?.setBuddyIcon) {
    window.PB_IconManager.setBuddyIcon(buddyTab);
  }

  // Initialize icon colors
  if (window.PB_IconManager?.initializeIconColors) {
    window.PB_IconManager.initializeIconColors(buddyTab, tabsContainer, buddyTab.id);
  }

  // Ensure Buddy pane exists in the DOM
  const buddyPane = window.PB_TabIntegration?.ensureBuddyPane?.(panesContainer);
  if (!buddyPane) {
    console.error('[Phrase Buddy] Failed to create Buddy pane');
    return;
  }



  // Render the internal tab menu within the Buddy pane
  window.PB_PaneModules?.renderBuddyModuleHost?.(buddyPane);
  console.log('[Phrase Buddy] Rendered internal module tabs');

  // Apply sampled Phrase typography to internal UI elements
  if (typeof window.PB_UITheme?.applyBuddyTypographyAuthority === 'function') {
    window.PB_UITheme.applyBuddyTypographyAuthority();
  }

  // Paint checkboxes with Phrase blue after they're rendered
  if (window.PB_UITheme?.paintCheckboxes) {
    console.log('[Phrase Buddy] Scheduling initial checkbox paint...');
    setTimeout(() => {
      console.log('[Phrase Buddy] Executing initial checkbox paint');
      window.PB_UITheme.paintCheckboxes();
    }, 100);
  } else {
    console.error('[Phrase Buddy] PB_UITheme.paintCheckboxes not available!');
  }

  // Set up click handler for the Buddy tab button
  const buddyTabBtn = buddyTab.querySelector('button');
  if (buddyTabBtn) {
    buddyTabBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      // Only open Buddy if it's not already open; clicking while active does nothing
      if (!window.PB_UiState?.isBuddyOpen?.()) {
        window.PB_UiState?.openBuddy?.(buddyTab, buddyPane, panesContainer, tabsContainer);
      }
    });
  }

  // Set up click handlers for native tabs to auto-close Buddy when switching
  const nativeTabs = tabsContainer.querySelectorAll('.sidebar-tab:not(#' + buddyTab.id + ') button');
  nativeTabs.forEach(nativeTabBtn => {
    nativeTabBtn.addEventListener('click', (e) => {
      // If Buddy is open, close it and let the native tab become active
      if (window.PB_UiState?.isBuddyOpen?.()) {
        window.PB_UiState.closeBuddy(buddyTab, buddyPane);
      }
    });
  });

  // Set up theme change listener to repaint icons when Phrase switches light/dark mode
  setupThemeChangeListener();

  // Set up event-driven checkbox repainting (observes pane mutations instead of polling)
  setupCheckboxRepaintListener(buddyPane);

  // Wire tooltip to Buddy tab button
  if (buddyTab && window.PB_TooltipManager?.wire) {
    window.PB_TooltipManager.wire(buddyTab, 'Phrase Buddy');
  }

  // Set up Tag Viewer activation/deactivation
  document.addEventListener('tool:activated', (e) => {
    if (e.detail.toolId === 'phrase-tag-viewer') {
      // Start Tag Viewer monitoring and UI
      if (window.PB_TagViewerUI?.initializeTagViewer) {
        window.PB_TagViewerUI.initializeTagViewer();
      }
      // Also enable tag clicking cursor affordance if needed
      if (window.PB_TagClickHandler?.applyTagClickCursorUi) {
        window.PB_TagClickHandler.applyTagClickCursorUi();
      }
    }
  });

  document.addEventListener('tool:deactivated', (e) => {
    if (e.detail.toolId === 'phrase-tag-viewer') {
      // Clean up Tag Viewer monitoring
      if (window.PB_TagViewerUI?.cleanupTagViewer) {
        window.PB_TagViewerUI.cleanupTagViewer();
      }
      // Disable tag clicking completely when tool is disabled
      if (window.PB_TagClickHandler?.disableTagClicking) {
        window.PB_TagClickHandler.disableTagClicking();
      }
      // Remove cursor affordance
      if (window.PB_TagClickHandler?.applyTagClickCursorUi) {
        window.PB_TagClickHandler.applyTagClickCursorUi();
      }
    }
  });

  console.log('[Phrase Buddy] Initialization complete');
}

/**
 * Checks if the Phrase environment is ready for Buddy initialization.
 * @returns {boolean} True if Phrase is ready.
 */
function isPhraseReady() {
  return !!document.querySelector('#right-panel-navigation-tabs');
}

/**
 * Main entry point - called when DOM is ready.
 */
function initialize() {
  console.log('[Phrase Buddy] Starting userscript');

  // If Phrase is already loaded, initialize immediately
  if (isPhraseReady()) {
    initializeBuddy();
  } else {
    // Otherwise wait for Phrase to load
    const observer = new MutationObserver(() => {
      if (isPhraseReady()) {
        observer.disconnect();
        initializeBuddy();
      }
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true,
    });

    // Timeout: give Phrase 10 seconds to load
    setTimeout(() => {
      observer.disconnect();
      if (!isPhraseReady()) {
        console.error('[Phrase Buddy] Phrase interface did not load within timeout');
      }
    }, 10000);
  }
}

// Start the userscript when the DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initialize);
} else {
  initialize();
}


  </script>
  <script>
    (function(){
      const payloadTag = document.getElementById('pb-payload');
      const codeblock  = document.getElementById('pbCodeblock');
      const btn        = document.getElementById('copyPBCodeBtn');

      const userscript = (payloadTag && payloadTag.textContent) ? payloadTag.textContent.trim() : '';
      codeblock.textContent = userscript || '(no script pasted yet)';

      btn.addEventListener('click', async () => {
        const text = userscript || '';
        if (!text) { btn.textContent = 'Nothing to copy'; setTimeout(()=>btn.textContent='Copy code', 1300); return; }
        try {
          await navigator.clipboard.writeText(text);
          btn.textContent = 'Copied!';
          setTimeout(() => btn.textContent = 'Copy code', 1400);
        } catch (e) {
          const ta = document.createElement('textarea');
          ta.value = text; ta.style.position = 'fixed'; ta.style.left='-9999px'; ta.style.top='-9999px';
          document.body.appendChild(ta); ta.focus(); ta.select();
          const ok = document.execCommand('copy');
          document.body.removeChild(ta);
          btn.textContent = ok ? 'Copied!' : 'Select & Ctrl+C';
          setTimeout(() => btn.textContent = 'Copy code', 1400);
        }
      });
    })();
  </script>
</body>
</html>
