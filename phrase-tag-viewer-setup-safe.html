
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Phrase Tag Viewer — Installation Guide</title>
  <style>
    :root { --bg:#0b1220; --panel:#0f1629; --text:#e6eefc; --muted:#9fb3d9; --accent:#7aa2ff; --ok:#2bd48f; }
    * { box-sizing:border-box; }
    body { margin:0; background:var(--bg); color:var(--text); font:16px/1.55 system-ui,-apple-system,"Segoe UI",Roboto,Inter,Arial,sans-serif; }
    .wrap { max-width:960px; margin:40px auto; padding:0 20px; }
    h1 { font-size:28px; margin:0 0 8px; }
    h2 { margin:28px 0 10px; font-size:20px; }
    p  { color:var(--muted); }
    .card { background:var(--panel); border:1px solid rgba(255,255,255,.07); border-radius:12px; padding:18px; margin:16px 0; }
    ol.steps { padding-left:20px; }
    .codewrap { position:relative; margin-top:12px; }
    .copybtn {
      position:absolute; top:10px; right:10px; padding:8px 12px; border-radius:8px;
      background:var(--accent); color:#06131f; border:none; font-weight:700; cursor:pointer;
      box-shadow:0 6px 16px rgba(0,0,0,.25);
    }
    .copybtn:active { transform:translateY(1px); }
    pre { margin:0; max-height:420px; overflow:auto; background:#0a1020; border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:16px; }
    code { color:#c7d7ff; font-family:ui-monospace,Menlo,Consolas,Monaco,monospace; font-size:13px;
           white-space:pre-wrap; overflow-wrap:anywhere; word-break:break-word; }
    .tip { color:#b7c7ee; font-size:14px; }
    .ok { color:var(--ok); font-weight:700; }
    a.btn {
      display:inline-block; padding:10px 14px; border-radius:10px; text-decoration:none;
      background:#18233b; color:#dbe7ff; border:1px solid rgba(255,255,255,.08);
    }
    a.btn:hover { background:#1b2744; }
    ul { margin:0; padding-left:20px; }
    .notice { font-size:14px; color:#c8d6ff; opacity:.9; margin:8px 0 0; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Phrase Tag Viewer</h1>
    <p class="tip">
      A small helper that reads the <b>active target segment</b> in Phrase/Memsource and shows a
      copy-ready string where <b>Phrase tag widgets are replaced by their literal values</b>.
      It supports <code>mq:rxt</code> (via <code>displaytext</code>/<code>val</code>) and
      paired tags (<code>bpt/ept</code>, e.g. <code>&lt;strong&gt;</code>…<code>&lt;/strong&gt;</code>).
      Numbers inside braces like <code>{{123}}</code> are output as <code>123</code>.
    </p>

    <div class="card">
      <h2>1) Install Tampermonkey</h2>
      <p>Install the Tampermonkey extension for your browser:</p>
      <p><a class="btn" href="https://www.tampermonkey.net/" target="_blank" rel="noopener noreferrer">Go to tampermonkey.net</a></p>
      <p class="tip">On that page, pick your browser (Chrome, Edge, Firefox, etc.) and follow the store link to install.</p>
    </div>

    <div class="card">
      <h2>2) Create a new userscript</h2>
      <ol class="steps">
        <li>Click the Tampermonkey icon in your browser toolbar (you may need to enable it in your browser's extension settings).</li>
        <li>Click <b>+ Create a new script…</b>.</li>
      </ol>
    </div>

    <div class="card">
      <h2>3) Paste the script, then save</h2>
      <p>Copy the script below by clicking <b>Copy code</b>, then paste into the Tampermonkey editor, replacing any previous content. Save by going to <b>File → Save</b> or using <b>Ctrl+S</b>.</p>

      <div class="codewrap">
        <button class="copybtn" id="copyCodeBtn">Copy code</button>
        <pre><code id="codeblock">(no script pasted yet)</code></pre>
      </div>
      <!-- The payload below is NEVER executed and NEVER parsed as HTML/JS. It's plain text. -->
      <script id="payload" type="text/plain">
// ==UserScript==
// @name         Phrase Tag Viewer
// @namespace    hs.phrase.copyexport
// @version      1.3.0
// @description  Copy-ready export of active Phrase target segment: tag widgets → values (mq:rxt) and bpt/ept inner markup; strip {123}→123; ignore [[...]] in preview/copy and when choosing the relevant @; colored tags by theme; light/dark w/ memory; iframe-safe; selection-safe; variable toggles (single-@ and |4) in one vertical list with switch controls above the “Toggle Variables” checkbox.
// @match        https://app.phrase.com/*
// @match        https://*.phrase.com/*
// @match        https://cloud.memsource.com/*
// @match        https://*.memsource.com/*
// @exclude      https://cloud.memsource.com/web/project*
// @exclude      https://cloud.memsource.com/web/job2/list*
// @exclude      https://cloud.memsource.com/tms/transMemory/list*
// @exclude      https://cloud.memsource.com/tms/setup/*
// @exclude      https://cloud.memsource.com/web/setup/*
// @run-at       document-idle
// @grant        GM_setClipboard
// ==/UserScript==

(() => {
  /* ===================== Base / utils ===================== */
  const IS_TOP = window.top === window;
  const ORIGIN_ID = `${location.origin}${location.pathname}`;
  const THEME_KEY = 'ptv-theme';         // 'light' | 'dark'
  const VARS_KEY  = 'ptv-vars-enabled';  // remember toggle ON/OFF per user
  const $ = (s, r = document) => r.querySelector(s);

  let ui, showBtn, lastActive = null;
  let PTV_SELECTING = false;
  const PTV_RENDER_CACHE = { plain: '', html: '' };

  // Variable mode state for current segment
  let VARS_ENABLED = false;
  let VARS_TOGGLE;
  let VARS_FLY; // compact vertical flyout above the Toggle Variables control

  // choices: at = 'before'|'after' (single); or = array of 'a'|'b'
  let VAR_CHOICES = { at: 'before', or: [] };
  // selected @ in the original string: nth occurrence (1-based). 0 = none/useful not found
  let VAR_AT_NTH = 0;

  let PREV_BASE_PLAIN = ''; // to detect segment change and rebuild panel

  // Button click feedback
  function addClickFeedback(btn){
    if (!btn || btn.dataset._ptvClickFx) return;
    btn.dataset._ptvClickFx = '1';
    btn.addEventListener('click', () => {
      btn.classList.add('ptv-pressed');
      setTimeout(() => btn.classList.remove('ptv-pressed'), 150);
    }, true);
  }

  /* ===================== UI ===================== */
  function ensureUI() {
    if (!IS_TOP) return;
    if ($('#hs-copybox')) {
      ui = $('#hs-copybox');
      showBtn = $('#hs-showbtn');
      VARS_TOGGLE = $('#hs-vars-toggle');
      if (!VARS_FLY) createVarsFlyout(); // ensure flyout exists if reusing UI
      return;
    }

    ui = document.createElement('div');
    ui.id = 'hs-copybox';
    ui.innerHTML = `
      <div class="hs-head">
        <strong>Phrase Tag Viewer</strong>
        <div class="hs-menu">
          <label class="hs-vars-toggle" title="Resolve variables">
            <input id="hs-vars-toggle" type="checkbox"/><span>Toggle Variables</span>
          </label>
          <label class="hs-fontctrl" title="Preview font size (px)">
            <span class="hs-fs-label">A</span>
            <input id="hs-fs" type="number" min="10" max="48" step="1" value="14"/>
          </label>
          <label class="hs-theme-toggle" title="Toggle dark mode">
            <input id="hs-theme" type="checkbox"/><span>Dark</span>
          </label>
        </div>
      </div>
      <div id="hs-body">
        <div class="hs-textwrap">
          <div id="hs-pretty" aria-label="Converted preview" tabindex="0"></div>
          <textarea id="hs-out" aria-hidden="true"></textarea>
        </div>
        <div class="hs-buttons">
          <button id="hs-copybtn" title="Copy to clipboard">Copy</button>
          <button id="hs-hide" title="Hide panel">Hide</button>
        </div>
      </div>`;

    Object.assign(ui.style, {
      position:'fixed', left:'12px', bottom:'40px', width:'1420px', height:'110px', maxWidth:'98vw',
      zIndex:2147483647, borderRadius:'10px', boxShadow:'0 8px 24px rgba(0,0,0,.4)',
      font:'12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif', padding:'10px',
      display:'flex', flexDirection:'column'
    });

    const style = document.createElement('style');
    style.textContent = `
      /* Layout */
      #hs-copybox .hs-head{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;min-height:20px}
      #hs-copybox .hs-menu{display:flex;gap:10px;align-items:center}
      #hs-copybox .hs-menu > * { display:flex; align-items:center; gap:6px; }
      #hs-body{display:flex;gap:6px;flex:1;min-height:0}
      #hs-body .hs-textwrap{flex:1;display:flex;min-width:0}
      #hs-pretty{width:100%;height:100%;border-radius:8px;padding:6px;box-sizing:border-box;overflow:auto;white-space:pre-wrap;word-break:break-word;line-height:1.4;font-size:14px;
        font-family:"Inter","IBM Plex Sans","Segoe UI",system-ui,-apple-system,Roboto,Arial,sans-serif}
      #hs-out{display:none}
      #hs-copybox .hs-buttons{display:flex;flex-direction:column;gap:6px;align-items:stretch;justify-content:flex-start;min-width:110px}
      #hs-copybox button{border-radius:6px;cursor:pointer;font-size:12px;line-height:1;height:32px;padding:6px 10px;min-width:72px}

      /* Font size control */
      #hs-copybox .hs-fontctrl{user-select:none}
      #hs-copybox .hs-fs-label{font-weight:700;opacity:.85;display:inline-block;width:14px;text-align:center;font-size:12px}
      #hs-copybox #hs-fs{width:56px;height:24px;border-radius:6px;padding:2px 6px;font-size:12px}

      /* Toggle Variables (small, inline) */
      #hs-copybox .hs-vars-toggle{user-select:none;cursor:pointer;font-size:12px}

      /* Compact Vertical Variables Flyout */
      #hs-vars-flyout{
        position:fixed; z-index:2147483647;
        /* auto width/height based on content; compact vertical layout */
        border:1px solid; border-radius:10px; padding:10px; font:12px/1.4 system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;
        box-shadow:0 10px 24px rgba(0,0,0,.35);
        max-width:340px; max-height:50vh; overflow:auto;
      }
      #hs-vars-flyout.hidden{ display:none!important }
      #hs-vars-flyout .vars-list{display:flex;flex-direction:column;gap:8px}
      #hs-vars-flyout .vars-item{display:flex;align-items:center;justify-content:space-between;gap:10px}
      #hs-vars-flyout .vars-label{flex:1;display:flex;align-items:center;gap:8px;min-width:0}
      #hs-vars-flyout .vars-option{white-space:nowrap;opacity:.9}
      #hs-vars-flyout .vars-option.right{margin-left:10px}

      /* Switch control */
      .ptv-switch{position:relative;width:46px;height:22px;flex:0 0 auto}
      .ptv-switch input{position:absolute;opacity:0;width:0;height:0}
      .ptv-switch .track{
        position:absolute;inset:0;border-radius:999px;border:1px solid currentColor;opacity:.7;
      }
      .ptv-switch .thumb{
        position:absolute;top:1px;left:1px;width:20px;height:20px;border-radius:50%;
        background:currentColor;transition:transform 160ms ease;
      }
      .ptv-switch input:checked + .track + .thumb{ transform:translateX(24px); }

      /* Show button */
      #hs-showbtn{position:fixed;z-index:2147483647;border-radius:999px;padding:6px 10px;cursor:pointer;font:12px/1 system-ui,-apple-system,"Segoe UI",Roboto,sans-serif;box-shadow:0 8px 24px rgba(0,0,0,.4)}
      #hs-showbtn.hidden{display:none!important}

      /* Theme: light (default) */
      #hs-copybox.ptv-light{background:#f7f8fa;color:#0b0f12;border:1px solid #cfd8e3}
      #hs-copybox.ptv-light #hs-pretty{background:#fff;color:#111827;border:1px solid #cfd8e3}
      #hs-copybox.ptv-light .hs-taglit{color:#1d4ed8;font-weight:600}
      #hs-copybox.ptv-light button{background:#eef2f7;color:#0b0f12;border:1px solid #cbd5e1}
      #hs-copybox.ptv-light button:hover{background:#e6edf7}
      #hs-copybox.ptv-light #hs-fs{background:#fff;color:#0b0f12;border:1px solid #cbd5e1}
      #hs-vars-flyout.ptv-light{background:#ffffff;border-color:#cfd8e3;color:#0b0f12}
      #hs-showbtn.ptv-light{background:#eef2f7;color:#0b0f12;border:1px solid #cbd5e1}
      #hs-showbtn.ptv-light:hover{background:#e6edf7}

      /* Theme: dark */
      #hs-copybox.ptv-dark{background:#0b0f12;color:#d7e2ea;border:1px solid #1f2a33}
      #hs-copybox.ptv-dark #hs-pretty{background:#0e1317;color:#e8f3ff;border:1px solid #1e2a33}
      #hs-copybox.ptv-dark .hs-taglit{color:#f6c560;font-weight:600}
      #hs-copybox.ptv-dark button{background:#10202a;color:#bfe8ff;border:1px solid #1e2f3a}
      #hs-copybox.ptv-dark button:hover{background:#143040}
      #hs-copybox.ptv-dark #hs-fs{background:#0e1317;color:#e8f3ff;border:1px solid #1e2a33}
      #hs-vars-flyout.ptv-dark{background:#0e1317;border-color:#1e2a33;color:#d7e2ea}
      #hs-copybox.hidden{display:none!important}
      #hs-showbtn.ptv-dark{background:#10202a;color:#bfe8ff;border:1px solid #1e2f3a}
      #hs-showbtn.ptv-dark:hover{background:#143040}

      /* Selection: allow text dragging fully */
      #hs-pretty, #hs-pretty *{-webkit-user-select:text!important;-moz-user-select:text!important;user-select:text!important;pointer-events:auto!important}
      #hs-pretty{cursor:text}

      /* Button press feedback */
      #hs-copybox button{transition:transform 120ms ease, filter 120ms ease, background-color 120ms ease}
      #hs-copybox button:active{transform:translateY(1px) scale(0.99);filter:brightness(0.96)}
      #hs-copybox button.ptv-pressed{transform:translateY(1px) scale(0.98);filter:brightness(0.92)}
    `;
    document.documentElement.append(style, ui);

    // Bind once: selection guard to prevent mid-drag rerenders
    const prettyEl = $('#hs-pretty');
    if (prettyEl && !prettyEl.dataset._ptvBound) {
      prettyEl.dataset._ptvBound = '1';
      prettyEl.addEventListener('mousedown', () => { PTV_SELECTING = true; }, true);
      window.addEventListener('mouseup', () => { PTV_SELECTING = false; }, true);
    }

    // Persistent Show button
    showBtn = document.createElement('button');
    showBtn.id = 'hs-showbtn'; showBtn.textContent = 'Show'; showBtn.className = 'hidden';
    document.documentElement.appendChild(showBtn);

    // Theme
    const themeInput = $('#hs-theme');
    const applyTheme = t => {
      ui.classList.toggle('ptv-light', t==='light');
      ui.classList.toggle('ptv-dark',  t==='dark');
      showBtn.classList.toggle('ptv-light', t==='light');
      showBtn.classList.toggle('ptv-dark',  t==='dark');
      if (VARS_FLY) {
        VARS_FLY.classList.toggle('ptv-light', t==='light');
        VARS_FLY.classList.toggle('ptv-dark',  t==='dark');
      }
      localStorage.setItem(THEME_KEY, t);
      themeInput.checked = (t === 'dark');
    };
    applyTheme(localStorage.getItem(THEME_KEY) || 'light');
    themeInput.addEventListener('change', () => applyTheme(themeInput.checked ? 'dark' : 'light'));

    // Toggle Variables
    VARS_TOGGLE = $('#hs-vars-toggle');
    VARS_ENABLED = false; // default OFF
VARS_TOGGLE.checked = VARS_ENABLED;
// (optional) keep storage in sync:
localStorage.setItem(VARS_KEY, '0');
    VARS_TOGGLE.checked = VARS_ENABLED;
    VARS_TOGGLE.addEventListener('change', () => {
      VARS_ENABLED = VARS_TOGGLE.checked;
      localStorage.setItem(VARS_KEY, VARS_ENABLED ? '1' : '0');
      if (VARS_ENABLED) { if (!VARS_FLY) createVarsFlyout(); positionVarsFlyout(); VARS_FLY.classList.remove('hidden'); }
      else { VARS_FLY?.classList.add('hidden'); }
      // Reset choices on toggle (fresh from current segment)
      PREV_BASE_PLAIN = ''; // force rebuild on next render
      render();
    });

    // Copy
    const copyHandler = async () => {
      const text = $('#hs-out')?.value || '';
      try {
        if (typeof GM_setClipboard === 'function') return GM_setClipboard(text, { type:'text', mimetype:'text/plain' });
        await navigator.clipboard.writeText(text);
      } catch {
        const ta = $('#hs-out'); if (ta) { ta.focus(); ta.select(); document.execCommand('copy'); }
      }
    };
    $('#hs-copybtn').addEventListener('click', copyHandler);
    addClickFeedback($('#hs-copybtn'));

    // Font size controller
    const fsInput = $('#hs-fs'), applyFs = () => {
      const px = Math.max(10, Math.min(48, Number(fsInput.value || 14) || 14));
      const pretty = $('#hs-pretty'); if (pretty) pretty.style.fontSize = px + 'px';
    };
    fsInput.addEventListener('input', applyFs);
    fsInput.addEventListener('change', applyFs);
    applyFs();

    // Show button near panel's right edge
    const positionShowButtonNearHide = () => {
      if (!ui || !showBtn) return;
      const r = ui.getBoundingClientRect();
      showBtn.style.left = Math.round(r.left + r.width - 88) + 'px';
      showBtn.style.bottom = Math.max(8, Math.round(window.innerHeight - r.bottom)) + 'px';
    };

    // Hide/Show
    const doHide = () => { positionShowButtonNearHide(); ui.classList.add('hidden'); showBtn.classList.remove('hidden'); VARS_FLY?.classList.add('hidden'); };
    const doShow = () => { ui.classList.remove('hidden'); showBtn.classList.add('hidden'); if (VARS_ENABLED) { positionVarsFlyout(); VARS_FLY?.classList.remove('hidden'); } };
    $('#hs-hide').addEventListener('click', doHide);
    addClickFeedback($('#hs-hide'));
    showBtn.addEventListener('click', doShow);

    // Reposition flyout / show button on resize
    window.addEventListener('resize', () => {
      if (ui.classList.contains('hidden')) { positionShowButtonNearHide(); }
      if (VARS_ENABLED && !ui.classList.contains('hidden')) positionVarsFlyout();
    });

    // Keyboard toggle (Alt+P)
    window.addEventListener('keydown', e => {
      if (e.altKey && (e.key==='p'||e.key==='P')) ui.classList.contains('hidden') ? showBtn.click() : $('#hs-hide').click();
    }, true);

    // Create the flyout after UI exists
    createVarsFlyout();
    // Initial visibility
    if (VARS_ENABLED) { positionVarsFlyout(); VARS_FLY.classList.remove('hidden'); }
    else { VARS_FLY.classList.add('hidden'); }
  }

  function createVarsFlyout(){
    if (VARS_FLY) return;
    VARS_FLY = document.createElement('div');
    VARS_FLY.id = 'hs-vars-flyout';
    VARS_FLY.className = 'hidden'; // visible only when enabled
    // match theme
    const t = localStorage.getItem(THEME_KEY) || 'light';
    VARS_FLY.classList.add(t === 'dark' ? 'ptv-dark' : 'ptv-light');
    VARS_FLY.innerHTML = `<div class="vars-list" id="hs-vars-list"></div>`;
    document.documentElement.appendChild(VARS_FLY);
  }

  function positionVarsFlyout(){
    if (!ui || !VARS_FLY) return;
    const toggleLabel = $('.hs-vars-toggle'); // label that contains the checkbox + text
    const r = toggleLabel?.getBoundingClientRect();
    if (!r) return;
    // Align left to the label's left; place directly above it with a small gap.
    VARS_FLY.style.left = Math.round(r.left) + 'px';
    VARS_FLY.style.bottom = Math.max(8, Math.round(window.innerHeight - r.top + 6)) + 'px';
  }

  const setPreview = (plain, html) => {
    const pretty = $('#hs-pretty'), ta = $('#hs-out');
    if (!pretty || !ta) return;
    if (PTV_RENDER_CACHE.plain === (plain||'') && PTV_RENDER_CACHE.html === (html||'')) return; // no-op
    PTV_RENDER_CACHE.plain = plain || ''; PTV_RENDER_CACHE.html = html || '';
    pretty.innerHTML = PTV_RENDER_CACHE.html; ta.value = PTV_RENDER_CACHE.plain;
  };

  /* ===================== Decoding / conversion ===================== */
  const decodeHtml = s => { const t = document.createElement('textarea'); t.innerHTML = s; return t.value; };
  const escapeHtml = s => String(s ?? '').replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch]));
  const stripNumericBraces = s => String(s ?? '').replace(/\{(\d+)\}/g, '$1'); // "{123}" → "123"

  // Remove everything between [[...]] non-greedily (works on plain or html; spans are fine)
  const stripDoubleBrackets = s => String(s ?? '').replace(/\[\[[\s\S]*?\]\]/g, '');

  // For logic that must *ignore* bracketed text (without modifying original), compute ranges.
  function findBracketRanges(s) {
    const ranges = [];
    const re = /\[\[|\]\]/g;
    let m, stack = [];
    while ((m = re.exec(s))) {
      if (m[0] === '[[') stack.push(m.index);
      else if (m[0] === ']]' && stack.length) {
        const start = stack.pop();
        ranges.push([start, m.index + 2]); // half-open [start,end)
      }
    }
    return ranges.sort((a,b)=>a[0]-b[0]);
  }
  function indexInRanges(i, ranges){
    for (const [a,b] of ranges) { if (i>=a && i<b) return true; if (i<b) continue; }
    return false;
  }
  const removeBracketed = s => stripDoubleBrackets(s); // alias for clarity

  function extractPhraseTagValue(el) {
    const meta = el.querySelector?.('.tag_metadata_content')?.textContent || el.getAttribute?.('tmp-title') || el.getAttribute?.('title') || '';
    if (!meta) return { text:'', fromTag:true };
    const un = decodeHtml(meta);
    // mq:rxt
    let m = un.match(/displaytext="([^"]*)"/i) || un.match(/val="([^"]*)"/i);
    if (m) return { text: decodeHtml(m[1]||''), fromTag:true };
    // bpt/ept or generic inner
    let inner = un.match(/<(?:bpt|ept)\b[^>]*>([\s\S]*?)<\/(?:bpt|ept)>/i) || un.match(/<\w+\b[^>]*>([\s\S]*?)<\/\w+>/i);
    if (inner) return { text: decodeHtml(inner[1]||''), fromTag:true };
    // placeholder fallback
    return { text: el.getAttribute?.('data-tag-content') || '', fromTag:true };
  }

  function rebuildConvertedRich(container) {
    if (!container) return { plain:'', html:'' };
    let plain = '', html = '';
    container.childNodes.forEach(n => {
      if (n.nodeType === 3) { const t = n.nodeValue || ''; plain += t; html += escapeHtml(t); return; }
      if (n.nodeType !== 1) return;
      const el = n;
      if (el.classList?.contains('te_txt')) {
        const t = el.textContent || ''; plain += t; html += escapeHtml(t); return;
      }
      if (el.classList?.contains('te_tag') || el.matches?.('[data-testid="tag"],[data-tag],[data-tag-type]')) {
        const { text } = extractPhraseTagValue(el);
        const m = /^\{(\d+)\}$/.exec(text);
        if (m) { const num = m[1]; plain += num; html += `<span class="hs-taglit">${escapeHtml(num)}</span>`; }
        else   { plain += text; html += `<span class="hs-taglit">${escapeHtml(text)}</span>`; }
      }
    });
    return { plain: stripNumericBraces(plain), html };
  }

  /* ===================== Variable scanning / applying ===================== */
  // Utility: scan all '@' positions and also return 1-based index for each (@#)
  function scanAtPositions(s) {
    const pos = [];
    for (let i = 0, nth = 0; i < s.length; i++) if (s[i] === '@') { nth++; pos.push({ idx:i, nth }); }
    return pos;
  }

  // Collect all |4(a,b) occurrences (in textual order)
  function scanOrPairs(s) {
    const re = /\|4\(\s*([^,]*?)\s*,\s*([^)]+?)\s*\)/g;
    const out = [];
    let m; while ((m = re.exec(s))) {
      out.push({ a: m[1].trim(), b: m[2].trim() });
    }
    return out;
  }

  // --------- Normalization + Dice overlap scoring ---------
  const DICE_MIN = 0.55;      // tweakable
  const RATIO_MIN = 0.65;     // min(min(nL,nR)/max(nL,nR))
  const MIN_TOKENS = 4;       // avoid tiny stubs

  function neutralizeOr(s) { return s.replace(/\|4\(\s*[^,]+?\s*,\s*[^)]+?\s*\)/g, ' ALT '); }
  function stripHtmlTags(s) { return s.replace(/<[^>]+>/g, ' '); }
  function tokenize(s) {
    const m = s.toLowerCase().match(/[0-9A-Za-zÀ-ÖØ-öø-ÿ]+/g);
    return m ? m : [];
  }
  function bag(tokens) {
    const map = new Map();
    for (const t of tokens) map.set(t, (map.get(t)||0) + 1);
    return map;
  }
  function bagSize(map) { let n = 0; for (const v of map.values()) n += v; return n; }
  function bagIntersectionSize(a, b) {
    let n = 0; for (const [tok, ca] of a.entries()) { const cb = b.get(tok); if (cb) n += Math.min(ca, cb); } return n;
  }

  // Choose ONE useful '@' split by Dice + size sanity, ignoring any @ inside [[...]].
  // Return {nth} where nth is the 1-based ordinal in the ORIGINAL string (including bracketed areas).
  function pickBestAtNth(original) {
    const ranges = findBracketRanges(original);
    const atPos = scanAtPositions(original).filter(p => !indexInRanges(p.idx, ranges));
    if (!atPos.length) return { nth: 0 };

    // Prepare a bracket-stripped copy for size/similarity decisions
    const s = removeBracketed(original);

    // Map from original index to index in stripped string to slice cleanly
    // (We can approximate by rebuilding with a walk.)
    const mapOrigToStripped = (() => {
      const arr = new Array(original.length).fill(-1);
      let j = 0, k = 0;
      while (k < original.length) {
        // If we're inside a bracket range, skip until end of that range
        let skipped = false;
        for (const [a,b] of ranges) {
          if (k >= a && k < b) { k = b; skipped = true; break; }
        }
        if (skipped) continue;
        arr[k] = j; j++; k++;
      }
      return arr;
    })();

    let bestNth = 0;
    let bestDice = -1;

    for (const { idx, nth } of atPos) {
      const si = mapOrigToStripped[idx];
      if (si < 0) continue; // shouldn't happen; safety

      const left  = s.slice(0, si);
      const right = s.slice(si + 1);

      // normalize: neutralize |4(...), strip tags, collapse spaces
      let Ls = stripHtmlTags(neutralizeOr(left)).replace(/\s+/g, ' ').trim();
      let Rs = stripHtmlTags(neutralizeOr(right)).replace(/\s+/g, ' ').trim();

      const L = tokenize(Ls), R = tokenize(Rs);
      const nL = L.length, nR = R.length;
      if (nL < MIN_TOKENS || nR < MIN_TOKENS) continue;

      const ratio = Math.min(nL, nR) / Math.max(nL, nR);
      if (ratio < RATIO_MIN) continue;

      const BL = bag(L), BR = bag(R);
      const inter = bagIntersectionSize(BL, BR);
      const dice = (2 * inter) / (bagSize(BL) + bagSize(BR));

      if (dice >= DICE_MIN && dice > bestDice) {
        bestDice = dice; bestNth = nth; // NOTE: nth refers to original-string order
      }
    }

    return { nth: bestNth };
  }

  // Resolve the Nth '@' (1-based, in ORIGINAL string). If nth=0 or not found, return original.
  // choice: 'before' -> keep left side; 'after' -> keep right side
  function resolveAtNth(text, choice, nth) {
    if (!nth || (choice !== 'before' && choice !== 'after')) return text;
    let seen = 0;
    for (let i = 0; i < text.length; i++) {
      if (text[i] === '@') {
        seen++;
        if (seen === nth) {
          return (choice === 'after') ? text.slice(i+1) : text.slice(0, i);
        }
      }
    }
    return text;
  }

  // Resolve |4(a,b) with provided choices (array of 'a'|'b')
  function resolveOr(text, choices) {
    const re = /\|4\(\s*([^,]*?)\s*,\s*([^)]+?)\s*\)/g;
    let k = 0;
    return text.replace(re, (_, a, b) => ((choices && choices[k++] === 'b') ? b : a));
  }

  // Build/refresh variable flyout for a given base text (vertical list, unified, switch controls)
  function buildVarsFlyout(basePlain) {
    if (!VARS_FLY) return;
    const list = $('#hs-vars-list');
    if (!list) return;
    list.textContent = '';

    // Choose the single useful '@' (or none), ignoring [[...]]
    const picked = pickBestAtNth(basePlain);
    VAR_AT_NTH = picked.nth || 0;

    // Scan all |4 pairs
    const orPairs = scanOrPairs(basePlain);

    // Reset choices on segment change
    VAR_CHOICES = {
      at: 'before',
      or: new Array(orPairs.length).fill('a')
    };

    // Helper to make a switch row
    function makeSwitchRow(leftLabel, rightLabel, checked, onChange) {
      const row = document.createElement('div');
      row.className = 'vars-item';

      const left = document.createElement('span');
      left.className = 'vars-option left';
      left.textContent = leftLabel;

      const right = document.createElement('span');
      right.className = 'vars-option right';
      right.textContent = rightLabel;

      const sw = document.createElement('label');
      sw.className = 'ptv-switch';
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.checked = !!checked;
      const track = document.createElement('span'); track.className = 'track';
      const thumb = document.createElement('span'); thumb.className = 'thumb';
      input.addEventListener('change', () => onChange(input.checked));

      sw.appendChild(input); sw.appendChild(track); sw.appendChild(thumb);

      const labelWrap = document.createElement('div');
      labelWrap.className = 'vars-label';
      // layout: LeftLabel  [switch]  RightLabel
      labelWrap.appendChild(left);
      labelWrap.appendChild(sw);
      labelWrap.appendChild(right);

      row.appendChild(labelWrap);
      return row;
    }

    // Single @ toggle (only if we found a useful split)
    if (VAR_AT_NTH > 0) {
      // Checked (ball on right) → "After @"
      const row = makeSwitchRow('Before @', 'After @', false, (checked) => {
        VAR_CHOICES.at = checked ? 'after' : 'before';
        render();
      });
      list.appendChild(row);
    }

    // |4 toggles (each pair in its own vertical row)
    orPairs.forEach((p, i) => {
      // Checked (ball on right) → choose 'b'
      const row = makeSwitchRow(p.a || 'a', p.b || 'b', false, (checked) => {
        VAR_CHOICES.or[i] = checked ? 'b' : 'a';
        render();
      });
      list.appendChild(row);
    });

    if (list.children.length === 0) {
      const none = document.createElement('div');
      none.className = 'vars-item';
      none.textContent = 'No variables found in this segment.';
      list.appendChild(none);
    }
  }

  // Apply variable choices to both plain and html strings, then strip [[...]] for final output
  function applyVariablesToOutputs(basePlain, baseHtml) {
    // Resolve the selected @ (same Nth in both plain/html based on ORIGINAL strings)
    let p = resolveAtNth(basePlain, VAR_CHOICES.at, VAR_AT_NTH);
    let h = resolveAtNth(baseHtml,  VAR_CHOICES.at, VAR_AT_NTH);
    // Then resolve |4(a,b)
    p = resolveOr(p, VAR_CHOICES.or);
    h = resolveOr(h, VAR_CHOICES.or);
    // Finally, remove double-bracketed content from both outputs for printing
    p = stripDoubleBrackets(p);
    h = stripDoubleBrackets(h);
    return { plain: p, html: h };
  }

  /* ===================== Active row ===================== */
  const finders = {
    byCaret: d => d.getElementById?.('segment-text-editor-input')?.closest?.('.twe_segment') || null,
    byCursor: d => d.querySelector?.('.twe_segment .twe_target .te_selection_container .te_cursor')?.closest?.('.twe_segment') || null,
    byFocusedInput(d) {
      const a = d.activeElement; if (!a) return null;
      return a.matches?.('input.twe-main-input, textarea.twe-main-input, [contenteditable="true"]')
        ? (a.closest('.twe_segment') || a.closest('[data-testid="segment"]') || null) : null;
    },
    byActiveClass: d => d.querySelector?.('.twe_segment.twe_active, .twe_segment.twe_active_background, [data-testid="segment"][data-selected="true"]')
  };

  function readActiveFromDoc(doc) {
    const row = finders.byCaret(doc) || finders.byCursor(doc) || finders.byFocusedInput(doc) || finders.byActiveClass(doc);
    if (!row) return { row:null, plain:'', html:'' };
    const cont = row.querySelector?.('.twe_target .te_text_container') ||
                 row.querySelector?.('[data-testid="target"] .te_text_container') ||
                 row.querySelector?.('.twe_target [data-role="text-container"]');
    if (cont) return { row, ...rebuildConvertedRich(cont) };
    const live = row.querySelector?.('.twe_target .twe-main-input, textarea.twe-main-input, [contenteditable="true"]');
    const raw = (live && (live.value || live.textContent)) || '';
    return { row, plain: stripNumericBraces(raw), html: escapeHtml(raw) };
  }

  /* ===================== Iframes (same-origin sweep) ===================== */
  function getAllDocs(rootDoc = document, acc = new Set()) {
    if (!rootDoc || acc.has(rootDoc)) return { docs: Array.from(acc), totalFrames:0, okFrames:0 };
    acc.add(rootDoc);
    const ifr = rootDoc.querySelectorAll('iframe'); let total=0, ok=0;
    for (const f of ifr) {
      total++;
      try {
        const d = f.contentDocument || f.contentWindow?.document;
        if (d) { ok++; const nested = getAllDocs(d, acc); total += nested.totalFrames; ok += nested.okFrames; }
      } catch {}
    }
    return { docs: Array.from(acc), totalFrames:total, okFrames:ok };
  }

  /* ===================== Bridge ===================== */
  const MSG_MARK = '__hs_bridge__';
  const postToChildren = msg => { if (!IS_TOP) return; for (let i=0;i<window.frames.length;i++) { try { window.frames[i].postMessage({[MSG_MARK]:true, ...msg}, '*'); } catch {} } };
  const postToParent   = msg => { if (IS_TOP) return; try { window.parent.postMessage({[MSG_MARK]:true, ...msg }, '*'); } catch {} };

  window.addEventListener('message', e => {
    const d = e?.data; if (!d || !d[MSG_MARK]) return;
    if (IS_TOP) {
      if (d.type === 'ACTIVE') {
        lastActive = { plain: (d.payload?.plain ?? d.payload?.text) || '', html: d.payload?.html || '' };
        ensureUI(); render();
      }
    } else {
      if (d.type === 'PING')            postToParent({ type:'PONG', frameId:ORIGIN_ID, info:'editor-frame' });
      if (d.type === 'REQUEST_ACTIVE') {
        const r = readActiveFromDoc(document);
        postToParent({ type:'ACTIVE', frameId:ORIGIN_ID, info:'editor-frame', payload:{ plain:r.plain||'', html:r.html||'' } });
      }
    }
  }, true);

  /* ===================== Render/update ===================== */
  function render() {
    if (!IS_TOP || PTV_SELECTING) return;
    ensureUI();

    // same-origin first
    const { docs } = getAllDocs(document);
    let found = null;
    for (const d of docs) { const r = readActiveFromDoc(d); if (r.row) { found = r; break; } }
    const active = found || lastActive || null;

    const basePlain = active?.plain || '';
    const baseHtml  = active?.html  || '';

    if (!VARS_ENABLED) {
      // Even without variables, we must hide [[...]] in preview/copy
      const p = stripDoubleBrackets(basePlain);
      const h = stripDoubleBrackets(baseHtml);
      setPreview(p, h);
      PREV_BASE_PLAIN = basePlain; // cache even when off
      VARS_FLY?.classList.add('hidden'); // ensure flyout hidden when disabled
      return;
    }

    // VARS mode: ensure flyout visible & positioned
    positionVarsFlyout();
    VARS_FLY?.classList.remove('hidden');

    // Rebuild flyout if segment changed
    if (PREV_BASE_PLAIN !== basePlain) {
      buildVarsFlyout(basePlain);
      PREV_BASE_PLAIN = basePlain;
    }

    // Apply choices → outputs (then strip [[...]])
    const resolved = applyVariablesToOutputs(basePlain, baseHtml);
    setPreview(resolved.plain, resolved.html);
  }

  function wireInstantSignals() {
    const instant = () => { IS_TOP ? render() : tickFrame(); };
    ['input','keyup','selectionchange','pointerup','focusin'].forEach(ev => document.addEventListener(ev, instant, true));
  }

  function tickTop()   { postToChildren({type:'PING'}); postToChildren({type:'REQUEST_ACTIVE'}); render(); }
  function tickFrame() {
    const r = readActiveFromDoc(document);
    if (r && (r.row || r.plain || r.html)) postToParent({ type:'ACTIVE', frameId:ORIGIN_ID, info:'editor-frame', payload:{ plain:r.plain||'', html:r.html||'' } });
    else                                   postToParent({ type:'PONG',   frameId:ORIGIN_ID, info:'probe' });
  }

  /* ===================== Boot ===================== */
  function boot() {
    if (IS_TOP) ensureUI();
    // Load last-used variable toggle preference
    VARS_ENABLED = false; // default OFF on every load
if (IS_TOP && $('#hs-vars-toggle')) $('#hs-vars-toggle').checked = VARS_ENABLED;
// (optional)
localStorage.setItem(VARS_KEY, '0');
    if (IS_TOP && $('#hs-vars-toggle')) $('#hs-vars-toggle').checked = VARS_ENABLED;
    wireInstantSignals();
    const tick = IS_TOP ? tickTop : tickFrame;
    setTimeout(tick, 300);
    setInterval(tick, 350);
  }
  boot();
})();
      </script>
    </div>

    <div class="card">
      <h2>4) Open Phrase and try it</h2>
      <ul>
        <li>Open a job in <b>app.phrase.com</b> (or your Memsource domain).</li>
        <li>Select a <b>target segment</b>.</li>
        <li>Look for the “<b>Phrase Tag Viewer</b>” panel at the bottom-left of the page.</li>
        <li>Use <b>Copy</b> to copy the plain converted string, or toggle Dark mode / font size from the menu.</li>
      </ul>
      <p class="ok">If you see text appearing in the panel as you click segments, you’re all set!</p>
    </div>

    <div class="card">
      <h2>Troubleshooting</h2>
      <ul>
        <li>Make sure the userscript is <b>Enabled</b> in Tampermonkey’s Dashboard.</li>
        <li>Ensure the tab URL matches the script’s <code>@match</code> lines (e.g., <code>https://app.phrase.com/…</code>).</li>
        <li>Open the browser console (F12 → Console) and check for red error messages.</li>
        <li>If your team uses multiple Phrase domains, add extra <code>@match</code> lines as needed.</li>
      </ul>
    </div>
  </div>

  <script>
    (function(){
      const payloadTag = document.getElementById('payload');   // <script type="text/plain">
      const codeblock  = document.getElementById('codeblock'); // <code> preview
      const btn        = document.getElementById('copyCodeBtn');

      // Read the userscript as raw text (safe; not parsed/executed)
      const userscript = (payloadTag && payloadTag.textContent) ? payloadTag.textContent.trim() : '';

      // Show in the visible code box (use textContent for safety)
      codeblock.textContent = userscript || '(no script pasted yet)';

      btn.addEventListener('click', async () => {
        const text = userscript || '';
        if (!text) { btn.textContent = 'Nothing to copy'; setTimeout(()=>btn.textContent='Copy code', 1300); return; }
        try {
          await navigator.clipboard.writeText(text);
          btn.textContent = 'Copied!';
          setTimeout(() => btn.textContent = 'Copy code', 1400);
        } catch (e) {
          // Fallback
          const ta = document.createElement('textarea');
          ta.value = text; ta.style.position = 'fixed'; ta.style.left='-9999px'; ta.style.top='-9999px';
          document.body.appendChild(ta); ta.focus(); ta.select();
          const ok = document.execCommand('copy');
          document.body.removeChild(ta);
          btn.textContent = ok ? 'Copied!' : 'Select & Ctrl+C';
          setTimeout(() => btn.textContent = 'Copy code', 1400);
        }
      });
    })();
  </script>
</body>
</html>
